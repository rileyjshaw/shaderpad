{"version":3,"sources":["../../src/plugins/hands.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tcalculateBoundingBoxCenter,\n\tgenerateGLSLFn,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { HandLandmarker, HandLandmarkerResult, NormalizedLandmark } from '@mediapipe/tasks-vision';\n\nexport interface HandsPluginOptions {\n\tmodelPath?: string;\n\tmaxHands?: number;\n\tminHandDetectionConfidence?: number;\n\tminHandPresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\thistory?: number;\n}\n\nconst STANDARD_LANDMARK_COUNT = 21; // See https://ai.google.dev/edge/mediapipe/solutions/vision/hand_landmarker#models.\nconst CUSTOM_LANDMARK_COUNT = 1;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst HAND_CENTER_LANDMARKS = [0, 0, 5, 9, 13, 17] as const; // Wrist + MCP joints, weighted toward wrist.\nconst LANDMARKS_TEXTURE_WIDTH = 512;\nconst N_LANDMARK_METADATA_SLOTS = 1;\n\nconst DEFAULT_HANDS_OPTIONS: Required<Omit<HandsPluginOptions, 'history'>> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',\n\tmaxHands: 2,\n\tminHandDetectionConfidence: 0.5,\n\tminHandPresenceConfidence: 0.5,\n\tminTrackingConfidence: 0.5,\n};\n\ninterface Detector {\n\tlandmarker: HandLandmarker;\n\tmediapipeCanvas: OffscreenCanvas;\n\tsubscribers: Map<() => void, boolean>;\n\tmaxHands: number;\n\tstate: {\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: HandLandmarkerResult | null;\n\t\tpending: Promise<void>;\n\t\tnHands: number;\n\t};\n\tlandmarks: {\n\t\tdata: Float32Array;\n\t\ttextureHeight: number;\n\t};\n}\nconst sharedDetectors = new Map<string, Detector>();\n\nfunction updateLandmarksData(\n\tdetector: Detector,\n\thands: NormalizedLandmark[][],\n\thandedness: { categoryName: string }[][]\n) {\n\tconst data = detector.landmarks.data;\n\tconst nHands = hands.length;\n\n\tdata[0] = nHands;\n\n\tfor (let handIdx = 0; handIdx < nHands; ++handIdx) {\n\t\tconst landmarks = hands[handIdx];\n\t\tconst isRightHand = handedness[handIdx]?.[0]?.categoryName === 'Right';\n\t\tfor (let lmIdx = 0; lmIdx < STANDARD_LANDMARK_COUNT; ++lmIdx) {\n\t\t\tconst landmark = landmarks[lmIdx];\n\t\t\tconst dataIdx = (N_LANDMARK_METADATA_SLOTS + handIdx * LANDMARK_COUNT + lmIdx) * 4;\n\t\t\tdata[dataIdx] = landmark.x;\n\t\t\tdata[dataIdx + 1] = 1 - landmark.y;\n\t\t\tdata[dataIdx + 2] = landmark.z ?? 0;\n\t\t\tdata[dataIdx + 3] = isRightHand ? 1 : 0;\n\t\t}\n\n\t\tconst handCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\thandIdx,\n\t\t\tHAND_CENTER_LANDMARKS,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst handCenterIdx = (N_LANDMARK_METADATA_SLOTS + handIdx * LANDMARK_COUNT + STANDARD_LANDMARK_COUNT) * 4;\n\t\tdata[handCenterIdx] = handCenter[0];\n\t\tdata[handCenterIdx + 1] = handCenter[1];\n\t\tdata[handCenterIdx + 2] = handCenter[2];\n\t\tdata[handCenterIdx + 3] = isRightHand ? 1 : 0;\n\t}\n\n\tdetector.state.nHands = nHands;\n}\n\nfunction hands(config: { textureName: string; options?: HandsPluginOptions }) {\n\tconst { textureName, options: { history, ...mediapipeOptions } = {} } = config;\n\tconst options = { ...DEFAULT_HANDS_OPTIONS, ...mediapipeOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\tconst nLandmarksMax = options.maxHands * LANDMARK_COUNT + N_LANDMARK_METADATA_SLOTS;\n\tconst textureHeight = Math.ceil(nLandmarksMax / LANDMARKS_TEXTURE_WIDTH);\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst landmarksData =\n\t\t\texistingDetector?.landmarks.data ?? new Float32Array(LANDMARKS_TEXTURE_WIDTH * textureHeight * 4);\n\t\tlet detector: Detector | null = null;\n\t\tlet skipHistoryWrite = false;\n\n\t\tfunction onResult() {\n\t\t\tif (!detector) return;\n\t\t\tconst { nHands } = detector.state;\n\t\t\tconst nSlots = nHands * LANDMARK_COUNT + N_LANDMARK_METADATA_SLOTS;\n\t\t\tconst rowsToUpdate = Math.ceil(nSlots / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures(\n\t\t\t\t{\n\t\t\t\t\tu_handLandmarksTex: {\n\t\t\t\t\t\tdata: detector.landmarks.data,\n\t\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t\t\tisPartial: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{ skipHistoryWrite }\n\t\t\t);\n\t\t\tshaderPad.updateUniforms({ u_nHands: nHands });\n\t\t\temitHook('hands:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { HandLandmarker }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\tconst mediapipeCanvas = new OffscreenCanvas(1, 1);\n\t\t\t\tconst handLandmarker = await HandLandmarker.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\tnumHands: options.maxHands,\n\t\t\t\t\tminHandDetectionConfidence: options.minHandDetectionConfidence,\n\t\t\t\t\tminHandPresenceConfidence: options.minHandPresenceConfidence,\n\t\t\t\t\tminTrackingConfidence: options.minTrackingConfidence,\n\t\t\t\t});\n\n\t\t\t\tdetector = {\n\t\t\t\t\tlandmarker: handLandmarker,\n\t\t\t\t\tmediapipeCanvas,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tmaxHands: options.maxHands,\n\t\t\t\t\tstate: {\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t\tnHands: 0,\n\t\t\t\t\t},\n\t\t\t\t\tlandmarks: {\n\t\t\t\t\t\tdata: landmarksData,\n\t\t\t\t\t\ttextureHeight,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_maxHands', 'int', options.maxHands);\n\t\t\tshaderPad.initializeUniform('u_nHands', 'int', 0);\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_handLandmarksTex',\n\t\t\t\t{ data: landmarksData, width: LANDMARKS_TEXTURE_WIDTH, height: textureHeight },\n\t\t\t\t{ internalFormat: 'RGBA32F', type: 'FLOAT', minFilter: 'NEAREST', magFilter: 'NEAREST', history }\n\t\t\t);\n\t\t\tinitPromise.then(() => emitHook('hands:ready'));\n\t\t});\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) detectHands(source);\n\t\t});\n\n\t\tshaderPad.on(\n\t\t\t'updateTextures',\n\t\t\t(updates: Record<string, TextureSource>, options?: { skipHistoryWrite?: boolean }) => {\n\t\t\t\tconst source = updates[textureName];\n\t\t\t\tif (isMediaPipeSource(source)) {\n\t\t\t\t\tskipHistoryWrite = options?.skipHistoryWrite ?? false;\n\t\t\t\t\tdetectHands(source);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectHands(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tconst callOrder = ++nDetectionCalls;\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (callOrder !== nDetectionCalls || !detector) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.landmarker.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: HandLandmarkerResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.landmarker.detectForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.landmarker.detect(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tupdateLandmarksData(detector, result.landmarks, result.handedness);\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result && !detector.subscribers.get(onResult)) {\n\t\t\t\t\tonResult();\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.landmarker.close();\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tconst { fn, historyParams } = generateGLSLFn(history);\n\n\t\tinjectGLSL(`\nuniform int u_maxHands;\nuniform int u_nHands;\nuniform highp sampler2D${history ? 'Array' : ''} u_handLandmarksTex;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_handLandmarksTexFrameOffset;`\n\t\t\t\t: ''\n\t\t}\n\n${fn(\n\t'int',\n\t'nHandsAt',\n\t'',\n\thistory\n\t\t? `\n\tint layer = (u_handLandmarksTexFrameOffset - framesAgo + ${history}) % ${history};\n\treturn int(texelFetch(u_handLandmarksTex, ivec3(0, 0, layer), 0).r + 0.5);`\n\t\t: `\n\treturn int(texelFetch(u_handLandmarksTex, ivec2(0, 0), 0).r + 0.5);`\n)}\n${fn(\n\t'vec4',\n\t'handLandmark',\n\t'int handIndex, int landmarkIndex',\n\t`int i = ${N_LANDMARK_METADATA_SLOTS} + handIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};${\n\t\thistory\n\t\t\t? `\n\tint layer = (u_handLandmarksTexFrameOffset - framesAgo + ${history}) % ${history};\n\treturn texelFetch(u_handLandmarksTex, ivec3(x, y, layer), 0);`\n\t\t\t: `\n\treturn texelFetch(u_handLandmarksTex, ivec2(x, y), 0);`\n\t}`\n)}\n${fn('float', 'isRightHand', 'int handIndex', `return handLandmark(handIndex, 0${historyParams}).w;`)}\n${fn('float', 'isLeftHand', 'int handIndex', `return 1.0 - handLandmark(handIndex, 0${historyParams}).w;`)}`);\n\t};\n}\n\nexport default hands;\n"],"mappings":"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","names":["STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","HAND_CENTER_LANDMARKS","LANDMARKS_TEXTURE_WIDTH","N_LANDMARK_METADATA_SLOTS","DEFAULT_HANDS_OPTIONS","sharedDetectors","updateLandmarksData","detector","hands","handedness","data","nHands","handIdx","landmarks","isRightHand","lmIdx","landmark","dataIdx","handCenter","calculateBoundingBoxCenter","handCenterIdx","config","textureName","history","mediapipeOptions","options","optionsKey","hashOptions","nLandmarksMax","textureHeight","shaderPad","context","injectGLSL","emitHook","landmarksData","skipHistoryWrite","onResult","nSlots","rowsToUpdate","initializeDetector","mediaPipe","HandLandmarker","getSharedFileset","mediapipeCanvas","initPromise","name","source","isMediaPipeSource","detectHands","updates","nDetectionCalls","now","callOrder","requiredMode","shouldDetect","result","cb","fn","historyParams","generateGLSLFn","hands_default"]}