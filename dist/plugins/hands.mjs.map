{"version":3,"sources":["../../src/plugins/hands.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tcalculateBoundingBoxCenter,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { HandLandmarker, HandLandmarkerResult, NormalizedLandmark } from '@mediapipe/tasks-vision';\n\nexport interface HandsPluginOptions {\n\tmodelPath?: string;\n\tmaxHands?: number;\n\tminHandDetectionConfidence?: number;\n\tminHandPresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n}\n\nconst STANDARD_LANDMARK_COUNT = 21; // See https://ai.google.dev/edge/mediapipe/solutions/vision/hand_landmarker#models.\nconst CUSTOM_LANDMARK_COUNT = 1;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst HAND_CENTER_LANDMARKS = [0, 0, 5, 9, 13, 17] as const; // Wrist + MCP joints, weighted toward wrist.\nconst LANDMARKS_TEXTURE_WIDTH = 512;\n\nconst DEFAULT_HANDS_OPTIONS: Required<HandsPluginOptions> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',\n\tmaxHands: 2,\n\tminHandDetectionConfidence: 0.5,\n\tminHandPresenceConfidence: 0.5,\n\tminTrackingConfidence: 0.5,\n};\n\ninterface Detector {\n\tlandmarker: HandLandmarker;\n\tcanvas: OffscreenCanvas;\n\tsubscribers: Map<() => void, boolean>;\n\tstate: {\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: HandLandmarkerResult | null;\n\t\tpending: Promise<void>;\n\t\tnHands: number;\n\t};\n\tlandmarks: {\n\t\tdata: Float32Array;\n\t\ttextureHeight: number;\n\t};\n}\nconst sharedDetectors = new Map<string, Detector>();\n\nfunction updateLandmarksData(\n\tdetector: Detector,\n\thands: NormalizedLandmark[][],\n\thandedness: { categoryName: string }[][]\n) {\n\tconst data = detector.landmarks.data;\n\tconst nHands = hands.length;\n\n\tfor (let handIdx = 0; handIdx < nHands; ++handIdx) {\n\t\tconst landmarks = hands[handIdx];\n\t\tconst isRightHand = handedness[handIdx]?.[0]?.categoryName === 'Right';\n\t\tfor (let lmIdx = 0; lmIdx < STANDARD_LANDMARK_COUNT; ++lmIdx) {\n\t\t\tconst landmark = landmarks[lmIdx];\n\t\t\tconst dataIdx = (handIdx * LANDMARK_COUNT + lmIdx) * 4;\n\t\t\tdata[dataIdx] = landmark.x;\n\t\t\tdata[dataIdx + 1] = 1 - landmark.y;\n\t\t\tdata[dataIdx + 2] = landmark.z ?? 0;\n\t\t\tdata[dataIdx + 3] = isRightHand ? 1 : 0;\n\t\t}\n\n\t\tconst handCenter = calculateBoundingBoxCenter(data, handIdx, HAND_CENTER_LANDMARKS, LANDMARK_COUNT);\n\t\tconst handCenterIdx = (handIdx * LANDMARK_COUNT + STANDARD_LANDMARK_COUNT) * 4;\n\t\tdata[handCenterIdx] = handCenter[0];\n\t\tdata[handCenterIdx + 1] = handCenter[1];\n\t\tdata[handCenterIdx + 2] = handCenter[2];\n\t\tdata[handCenterIdx + 3] = isRightHand ? 1 : 0;\n\t}\n\n\tdetector.state.nHands = nHands;\n}\n\nfunction hands(config: { textureName: string; options?: HandsPluginOptions }) {\n\tconst { textureName, options: configOptions = {} } = config;\n\tconst options = { ...DEFAULT_HANDS_OPTIONS, ...configOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\tconst nLandmarksMax = options.maxHands * LANDMARK_COUNT;\n\tconst textureHeight = Math.ceil(nLandmarksMax / LANDMARKS_TEXTURE_WIDTH);\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, gl, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst landmarksData =\n\t\t\texistingDetector?.landmarks.data ?? new Float32Array(LANDMARKS_TEXTURE_WIDTH * textureHeight * 4);\n\t\tlet detector: Detector | null = null;\n\n\t\tfunction onResult() {\n\t\t\tif (!detector) return;\n\t\t\tconst { nHands } = detector.state;\n\t\t\tconst nLandmarks = nHands * LANDMARK_COUNT;\n\t\t\tconst rowsToUpdate = Math.ceil(nLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures({\n\t\t\t\tu_handLandmarksTex: {\n\t\t\t\t\tdata: detector.landmarks.data,\n\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t\tisPartial: nHands !== options.maxHands,\n\t\t\t\t},\n\t\t\t});\n\t\t\tshaderPad.updateUniforms({ u_nHands: nHands });\n\t\t\temitHook('hands:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { HandLandmarker }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\tconst mediapipeCanvas = new OffscreenCanvas(1, 1);\n\t\t\t\tconst handLandmarker = await HandLandmarker.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\tnumHands: options.maxHands,\n\t\t\t\t\tminHandDetectionConfidence: options.minHandDetectionConfidence,\n\t\t\t\t\tminHandPresenceConfidence: options.minHandPresenceConfidence,\n\t\t\t\t\tminTrackingConfidence: options.minTrackingConfidence,\n\t\t\t\t});\n\n\t\t\t\tdetector = {\n\t\t\t\t\tlandmarker: handLandmarker,\n\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tstate: {\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t\tnHands: 0,\n\t\t\t\t\t},\n\t\t\t\t\tlandmarks: {\n\t\t\t\t\t\tdata: landmarksData,\n\t\t\t\t\t\ttextureHeight,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_maxHands', 'int', options.maxHands);\n\t\t\tshaderPad.initializeUniform('u_nHands', 'int', 0);\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_handLandmarksTex',\n\t\t\t\t{ data: landmarksData, width: LANDMARKS_TEXTURE_WIDTH, height: textureHeight },\n\t\t\t\t{ internalFormat: gl.RGBA32F, type: gl.FLOAT, minFilter: gl.NEAREST, magFilter: gl.NEAREST }\n\t\t\t);\n\t\t\tinitPromise.then(() => emitHook('hands:ready'));\n\t\t});\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) detectHands(source);\n\t\t});\n\n\t\tshaderPad.on('updateTextures', (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (isMediaPipeSource(source)) detectHands(source);\n\t\t});\n\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectHands(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tconst callOrder = ++nDetectionCalls;\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (callOrder !== nDetectionCalls || !detector) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.landmarker.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: HandLandmarkerResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.landmarker.detectForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.landmarker.detect(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tupdateLandmarksData(detector, result.landmarks, result.handedness);\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result && !detector.subscribers.get(onResult)) {\n\t\t\t\t\tonResult();\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.landmarker.close();\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tinjectGLSL(`\nuniform int u_maxHands;\nuniform int u_nHands;\nuniform sampler2D u_handLandmarksTex;\n\nvec4 handLandmark(int handIndex, int landmarkIndex) {\n\tint i = handIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};\n\treturn texelFetch(u_handLandmarksTex, ivec2(x, y), 0);\n}\n\nfloat isRightHand(int handIndex) {\n\treturn handLandmark(handIndex, 0).w;\n}\n\nfloat isLeftHand(int handIndex) {\n\treturn 1.0 - handLandmark(handIndex, 0).w;\n}`);\n\t};\n}\n\nexport default hands;\n"],"mappings":"+DAkBA,IAAMA,EAA0B,GAC1BC,EAAwB,EACxBC,EAAiBF,EAA0BC,EAC3CE,EAAwB,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,EAAE,EAC3CC,EAA0B,IAE1BC,EAAsD,CAC3D,UACC,iHACD,SAAU,EACV,2BAA4B,GAC5B,0BAA2B,GAC3B,sBAAuB,EACxB,EAoBMC,EAAkB,IAAI,IAE5B,SAASC,EACRC,EACAC,EACAC,EACC,CACD,IAAMC,EAAOH,EAAS,UAAU,KAC1BI,EAASH,EAAM,OAErB,QAASI,EAAU,EAAGA,EAAUD,EAAQ,EAAEC,EAAS,CAClD,IAAMC,EAAYL,EAAMI,CAAO,EACzBE,EAAcL,EAAWG,CAAO,IAAI,CAAC,GAAG,eAAiB,QAC/D,QAASG,EAAQ,EAAGA,EAAQhB,EAAyB,EAAEgB,EAAO,CAC7D,IAAMC,EAAWH,EAAUE,CAAK,EAC1BE,GAAWL,EAAUX,EAAiBc,GAAS,EACrDL,EAAKO,CAAO,EAAID,EAAS,EACzBN,EAAKO,EAAU,CAAC,EAAI,EAAID,EAAS,EACjCN,EAAKO,EAAU,CAAC,EAAID,EAAS,GAAK,EAClCN,EAAKO,EAAU,CAAC,EAAIH,EAAc,EAAI,CACvC,CAEA,IAAMI,EAAaC,EAA2BT,EAAME,EAASV,EAAuBD,CAAc,EAC5FmB,GAAiBR,EAAUX,EAAiBF,GAA2B,EAC7EW,EAAKU,CAAa,EAAIF,EAAW,CAAC,EAClCR,EAAKU,EAAgB,CAAC,EAAIF,EAAW,CAAC,EACtCR,EAAKU,EAAgB,CAAC,EAAIF,EAAW,CAAC,EACtCR,EAAKU,EAAgB,CAAC,EAAIN,EAAc,EAAI,CAC7C,CAEAP,EAAS,MAAM,OAASI,CACzB,CAEA,SAASH,EAAMa,EAA+D,CAC7E,GAAM,CAAE,YAAAC,EAAa,QAASC,EAAgB,CAAC,CAAE,EAAIF,EAC/CG,EAAU,CAAE,GAAGpB,EAAuB,GAAGmB,CAAc,EACvDE,EAAaC,EAAY,CAAE,GAAGF,EAAS,YAAAF,CAAY,CAAC,EAEpDK,EAAgBH,EAAQ,SAAWvB,EACnC2B,EAAgB,KAAK,KAAKD,EAAgBxB,CAAuB,EAEvE,OAAO,SAAU0B,EAAsBC,EAAwB,CAC9D,GAAM,CAAE,WAAAC,EAAY,GAAAC,EAAI,SAAAC,CAAS,EAAIH,EAG/BI,EADmB7B,EAAgB,IAAIoB,CAAU,GAEpC,UAAU,MAAQ,IAAI,aAAatB,EAA0ByB,EAAgB,CAAC,EAC7FrB,EAA4B,KAEhC,SAAS4B,GAAW,CACnB,GAAI,CAAC5B,EAAU,OACf,GAAM,CAAE,OAAAI,CAAO,EAAIJ,EAAS,MACtB6B,EAAazB,EAASV,EACtBoC,EAAe,KAAK,KAAKD,EAAajC,CAAuB,EACnE0B,EAAU,eAAe,CACxB,mBAAoB,CACnB,KAAMtB,EAAS,UAAU,KACzB,MAAOJ,EACP,OAAQkC,EACR,UAAW1B,IAAWa,EAAQ,QAC/B,CACD,CAAC,EACDK,EAAU,eAAe,CAAE,SAAUlB,CAAO,CAAC,EAC7CsB,EAAS,eAAgB1B,EAAS,MAAM,MAAM,CAC/C,CAEA,eAAe+B,GAAqB,CACnC,GAAIjC,EAAgB,IAAIoB,CAAU,EACjClB,EAAWF,EAAgB,IAAIoB,CAAU,MACnC,CACN,GAAM,CAACc,EAAW,CAAE,eAAAC,CAAe,CAAC,EAAI,MAAM,QAAQ,IAAI,CACzDC,EAAiB,EACjB,OAAO,yBAAyB,CACjC,CAAC,EACKC,EAAkB,IAAI,gBAAgB,EAAG,CAAC,EAchDnC,EAAW,CACV,WAdsB,MAAMiC,EAAe,kBAAkBD,EAAW,CACxE,YAAa,CACZ,eAAgBf,EAAQ,UACxB,SAAU,KACX,EACA,OAAQkB,EACR,YAAa,QACb,SAAUlB,EAAQ,SAClB,2BAA4BA,EAAQ,2BACpC,0BAA2BA,EAAQ,0BACnC,sBAAuBA,EAAQ,qBAChC,CAAC,EAIA,OAAQkB,EACR,YAAa,IAAI,IACjB,MAAO,CACN,YAAa,QACb,OAAQ,KACR,UAAW,GACX,gBAAiB,EACjB,OAAQ,KACR,QAAS,QAAQ,QAAQ,EACzB,OAAQ,CACT,EACA,UAAW,CACV,KAAMR,EACN,cAAAN,CACD,CACD,EACAvB,EAAgB,IAAIoB,EAAYlB,CAAQ,CACzC,CAEAA,EAAS,YAAY,IAAI4B,EAAU,EAAK,CACzC,CACA,IAAMQ,EAAcL,EAAmB,EAEvCT,EAAU,GAAG,OAAQ,IAAM,CAC1BA,EAAU,kBAAkB,aAAc,MAAOL,EAAQ,QAAQ,EACjEK,EAAU,kBAAkB,WAAY,MAAO,CAAC,EAChDA,EAAU,kBACT,qBACA,CAAE,KAAMK,EAAe,MAAO/B,EAAyB,OAAQyB,CAAc,EAC7E,CAAE,eAAgBI,EAAG,QAAS,KAAMA,EAAG,MAAO,UAAWA,EAAG,QAAS,UAAWA,EAAG,OAAQ,CAC5F,EACAW,EAAY,KAAK,IAAMV,EAAS,aAAa,CAAC,CAC/C,CAAC,EAEDJ,EAAU,GAAG,oBAAqB,CAACe,EAAcC,IAA0B,CACtED,IAAStB,GAAewB,EAAkBD,CAAM,GAAGE,EAAYF,CAAM,CAC1E,CAAC,EAEDhB,EAAU,GAAG,iBAAmBmB,GAA2C,CAC1E,IAAMH,EAASG,EAAQ1B,CAAW,EAC9BwB,EAAkBD,CAAM,GAAGE,EAAYF,CAAM,CAClD,CAAC,EAED,IAAII,EAAkB,EACtB,eAAeF,EAAYF,EAAyB,CACnD,IAAMK,EAAM,YAAY,IAAI,EACtBC,EAAY,EAAEF,EACpB,MAAMN,EACDpC,IAELA,EAAS,MAAM,QAAUA,EAAS,MAAM,QAAQ,KAAK,SAAY,CAChE,GAAI4C,IAAcF,GAAmB,CAAC1C,EAAU,OAEhD,IAAM6C,EAAeP,aAAkB,iBAAmB,QAAU,QAChEtC,EAAS,MAAM,cAAgB6C,IAClC7C,EAAS,MAAM,YAAc6C,EAC7B,MAAM7C,EAAS,WAAW,WAAW,CAAE,YAAa6C,CAAa,CAAC,GAGnE,IAAIC,EAAe,GAiBnB,GAfIR,IAAWtC,EAAS,MAAM,QAC7BA,EAAS,MAAM,OAASsC,EACxBtC,EAAS,MAAM,UAAY,GAC3B8C,EAAe,IACLR,aAAkB,iBACxBA,EAAO,cAAgBtC,EAAS,MAAM,YACzCA,EAAS,MAAM,UAAYsC,EAAO,YAClCQ,EAAe,IAEJR,aAAkB,kBAC1BK,EAAM3C,EAAS,MAAM,gBAAkB,IAC1C8C,EAAe,IAIbA,EAAc,CACjB,IAAIC,EACJ,GAAIT,aAAkB,iBAAkB,CACvC,GAAIA,EAAO,aAAe,GAAKA,EAAO,cAAgB,GAAKA,EAAO,WAAa,EAAG,OAClFS,EAAS/C,EAAS,WAAW,eAAesC,EAAQK,CAAG,CACxD,KAAO,CACN,GAAIL,EAAO,QAAU,GAAKA,EAAO,SAAW,EAAG,OAC/CS,EAAS/C,EAAS,WAAW,OAAOsC,CAAM,CAC3C,CAEA,GAAIS,EAAQ,CACX/C,EAAS,MAAM,gBAAkB2C,EACjC3C,EAAS,MAAM,OAAS+C,EACxBhD,EAAoBC,EAAU+C,EAAO,UAAWA,EAAO,UAAU,EACjE,QAAWC,KAAMhD,EAAS,YAAY,KAAK,EAC1CgD,EAAG,EACHhD,EAAS,YAAY,IAAIgD,EAAI,EAAI,CAEnC,CACD,MAAWhD,EAAS,MAAM,QAAU,CAACA,EAAS,YAAY,IAAI4B,CAAQ,IACrEA,EAAS,EACT5B,EAAS,YAAY,IAAI4B,EAAU,EAAI,EAEzC,CAAC,EAED,MAAM5B,EAAS,MAAM,QACtB,CAEAsB,EAAU,GAAG,UAAW,IAAM,CACzBtB,IACHA,EAAS,YAAY,OAAO4B,CAAQ,EAChC5B,EAAS,YAAY,OAAS,IACjCA,EAAS,WAAW,MAAM,EAC1BF,EAAgB,OAAOoB,CAAU,IAGnClB,EAAW,IACZ,CAAC,EAEDwB,EAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAMU9B,CAAc;AAAA,eACtBE,CAAuB;AAAA,eACvBA,CAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUpC,CACD,CACD,CAEA,IAAOqD,EAAQhD","names":["STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","HAND_CENTER_LANDMARKS","LANDMARKS_TEXTURE_WIDTH","DEFAULT_HANDS_OPTIONS","sharedDetectors","updateLandmarksData","detector","hands","handedness","data","nHands","handIdx","landmarks","isRightHand","lmIdx","landmark","dataIdx","handCenter","calculateBoundingBoxCenter","handCenterIdx","config","textureName","configOptions","options","optionsKey","hashOptions","nLandmarksMax","textureHeight","shaderPad","context","injectGLSL","gl","emitHook","landmarksData","onResult","nLandmarks","rowsToUpdate","initializeDetector","mediaPipe","HandLandmarker","getSharedFileset","mediapipeCanvas","initPromise","name","source","isMediaPipeSource","detectHands","updates","nDetectionCalls","now","callOrder","requiredMode","shouldDetect","result","cb","hands_default"]}