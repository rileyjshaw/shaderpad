"use strict";var U=Object.create;var x=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var H=Object.getOwnPropertyNames;var F=Object.getPrototypeOf,R=Object.prototype.hasOwnProperty;var V=(r,c)=>{for(var s in c)x(r,s,{get:c[s],enumerable:!0})},v=(r,c,s,P)=>{if(c&&typeof c=="object"||typeof c=="function")for(let m of H(c))!R.call(r,m)&&m!==s&&x(r,m,{get:()=>c[m],enumerable:!(P=A(c,m))||P.enumerable});return r};var j=(r,c,s)=>(s=r!=null?U(F(r)):{},v(c||!r||!r.__esModule?x(s,"default",{value:r,enumerable:!0}):s,r)),W=r=>v(x({},"__esModule",{value:!0}),r);var $={};V($,{default:()=>Y});module.exports=W($);var C=33;function X(r){let{textureName:c,options:s}=r,P="https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task";return function(m,I){let{injectGLSL:S}=I,f=null,y=null,M=-1,_=new Map,g=s?.maxPoses??1,D=512,O=512,i=document.createElement("canvas");i.width=D,i.height=O;let l=i.getContext("2d"),h=document.createElement("canvas"),w=h.getContext("2d");l.globalCompositeOperation=w.globalCompositeOperation="lighten";let b=[];async function z(){try{let{FilesetResolver:n,PoseLandmarker:o}=await import("@mediapipe/tasks-vision");y=await n.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"),b.push(...o.POSE_CONNECTIONS),f=await o.createFromOptions(y,{baseOptions:{modelAssetPath:s?.modelPath||P},runningMode:"VIDEO",numPoses:s?.maxPoses??1,minPoseDetectionConfidence:s?.minPoseDetectionConfidence??.5,minPosePresenceConfidence:s?.minPosePresenceConfidence??.5,minTrackingConfidence:s?.minTrackingConfidence??.5,outputSegmentationMasks:s?.outputSegmentationMasks??!0})}catch(n){throw console.error("[Pose Plugin] Failed to initialize Pose Landmarker:",n),n}}function E(n){let o=1/0,e=-1/0,t=1/0,a=-1/0;for(let u of n)o=Math.min(o,u.x),e=Math.max(e,u.x),t=Math.min(t,u.y),a=Math.max(a,u.y);let d=(o+e)/2,p=(t+a)/2;return[d,p]}async function N(n,o){if(!f){console.warn("[Pose Plugin] Cannot update mask: poseLandmarker missing");return}try{if(l.clearRect(0,0,i.width,i.height),o&&o.length>0&&o.forEach(e=>{if(!e)return;let{width:t,height:a}=e,d=e.getAsUint8Array(),p=t*a,u=new Uint8ClampedArray(p*4);for(let k=0;k<p;k++)u[k*4+1]=d[k],u[k*4+3]=255;let T=new ImageData(u,t,a);t===i.width&&a===i.height?l.putImageData(T,0,0):((h.width!==t||h.height!==a)&&(h.width=t,h.height=a),w.putImageData(T,0,0),l.drawImage(h,0,0,i.width,i.height))}),b.length){let e=Math.max(2,i.width/256);l.lineWidth=e,l.lineCap="round",l.strokeStyle="#00f",n.forEach(t=>{b.forEach(({start:a,end:d})=>{let p=t[a],u=t[d];!p||!u||(p.visibility??1)<.3||(u.visibility??1)<.3||(l.beginPath(),l.moveTo(p.x*i.width,p.y*i.height),l.lineTo(u.x*i.width,u.y*i.height),l.stroke())})})}m.updateTextures({u_poseMask:i})}catch(e){console.error("[Pose Plugin] Failed to generate mask texture:",e)}}function L(n){if(!n.landmarks)return;N(n.landmarks,n.segmentationMasks).catch(t=>{console.warn("[Pose Plugin] Mask texture update error:",t)});let o=n.landmarks.length,e={u_nPoses:o};if(o){e.u_poseLandmarks=n.landmarks.flatMap(a=>a.map(d=>[d.x,1-d.y]));let t=[];for(let a of n.landmarks){let d=E(a);t.push([d[0],1-d[1]])}e.u_poseCenter=t}m.updateUniforms(e)}m.registerHook("init",async()=>{m.initializeTexture("u_poseMask",i),m.initializeUniform("u_maxPoses","int",g),m.initializeUniform("u_nPoses","int",0);let n=Array.from({length:g*C},()=>[.5,.5]);m.initializeUniform("u_poseLandmarks","float",n,{arrayLength:g*C});let o=Array.from({length:g},()=>[.5,.5]);m.initializeUniform("u_poseCenter","float",o,{arrayLength:g}),await z()}),m.registerHook("updateTextures",n=>{Object.entries(n).forEach(([o,e])=>{if(o===c&&(_.set(o,e),!!f))try{if(e instanceof HTMLVideoElement){if(e.currentTime!==M){M=e.currentTime;let t=performance.now(),a=f.detectForVideo(e,t);L(a)}}else if(e instanceof HTMLImageElement){let t=f.detect(e);L(t)}}catch(t){console.error("[Pose Plugin] Pose detection error:",t)}})}),m.registerHook("destroy",()=>{f&&(f.close(),f=null),y=null,_.clear(),i.remove()}),S(`
uniform int u_maxPoses;
uniform int u_nPoses;
uniform vec2 u_poseLandmarks[${g*C}];
uniform sampler2D u_poseMask;
uniform vec2 u_poseCenter[${g}];
vec2 poseLandmark(int poseIndex, int landmarkIndex) {
	return u_poseLandmarks[poseIndex * ${C} + landmarkIndex];
}
float getBody(vec2 pos) { return texture(u_poseMask, pos).g; }
float getSkeleton(vec2 pos) { return texture(u_poseMask, pos).b; }`)}}var Y=X;
//# sourceMappingURL=pose.js.map