"use strict";var ee=Object.create;var w=Object.defineProperty;var te=Object.getOwnPropertyDescriptor;var ne=Object.getOwnPropertyNames;var oe=Object.getPrototypeOf,ie=Object.prototype.hasOwnProperty;var se=(r,_)=>{for(var s in _)w(r,s,{get:_[s],enumerable:!0})},X=(r,_,s,M)=>{if(_&&typeof _=="object"||typeof _=="function")for(let a of ne(_))!ie.call(r,a)&&a!==s&&w(r,a,{get:()=>_[a],enumerable:!(M=te(_,a))||M.enumerable});return r};var re=(r,_,s)=>(s=r!=null?ee(oe(r)):{},X(_||!r||!r.__esModule?w(s,"default",{value:r,enumerable:!0}):s,r)),ae=r=>X(w({},"__esModule",{value:!0}),r);var ce={};se(ce,{default:()=>Te});module.exports=ae(ce);var H=33,Ee=6,u=H+Ee,t={LEFT_EYE:2,RIGHT_EYE:5,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32,BODY_CENTER:H,LEFT_HAND_CENTER:H+1,RIGHT_HAND_CENTER:H+2,LEFT_FOOT_CENTER:H+3,RIGHT_FOOT_CENTER:H+4,TORSO_CENTER:H+5};function _e(r){let{textureName:_,options:s}=r,M="https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task";return function(a,z){let{injectGLSL:V,gl:k}=z,L=null,U=null,v=-1,S="VIDEO",b=new Map,B=s?.maxPoses??1,N=512,$=0,e=null,j=512,Z=512,l=document.createElement("canvas");l.width=j,l.height=Z;let G=l.getContext("2d"),p=document.createElement("canvas"),Y=p.getContext("2d");G.globalCompositeOperation=Y.globalCompositeOperation="lighten";async function q(){try{let{FilesetResolver:o,PoseLandmarker:n}=await import("@mediapipe/tasks-vision");U=await o.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"),L=await n.createFromOptions(U,{baseOptions:{modelAssetPath:s?.modelPath||M},runningMode:S,numPoses:s?.maxPoses??1,minPoseDetectionConfidence:s?.minPoseDetectionConfidence??.5,minPosePresenceConfidence:s?.minPosePresenceConfidence??.5,minTrackingConfidence:s?.minTrackingConfidence??.5,outputSegmentationMasks:s?.outputSegmentationMasks??!0})}catch(o){throw console.error("[Pose Plugin] Failed to initialize Pose Landmarker:",o),o}}function g(o,n,T){let E=1/0,i=-1/0,d=1/0,m=-1/0,R=0,c=0;for(let D of T){let I=(n*u+D)*4,f=o[I],O=o[I+1];E=Math.min(E,f),i=Math.max(i,f),d=Math.min(d,O),m=Math.max(m,O),R+=o[I+2],c+=o[I+3]}let P=(E+i)/2,A=(d+m)/2,F=R/T.length,C=c/T.length;return[P,A,F,C]}async function J(o){if(!L||!e){console.warn("[Pose Plugin] Cannot update mask: poseLandmarker or landmarksDataArray missing");return}try{G.clearRect(0,0,l.width,l.height),o&&o.length>0&&o.forEach(n=>{if(!n)return;let{width:T,height:E}=n,i=n.getAsUint8Array(),d=T*E,m=new Uint8ClampedArray(d*4);for(let c=0;c<d;c++)m[c*4+1]=i[c],m[c*4+3]=255;let R=new ImageData(m,T,E);T===l.width&&E===l.height?G.putImageData(R,0,0):(p.width!==T&&(p.width=T),p.height!==E&&(p.height=E),Y.putImageData(R,0,0),G.drawImage(p,0,0,l.width,l.height))}),a.updateTextures({u_poseMask:l})}catch(n){console.error("[Pose Plugin] Failed to generate mask texture:",n)}}function Q(o){if(!e)return;let n=o.length,T=n*u;for(let i=0;i<n;++i){let d=o[i];for(let h=0;h<H;++h){let x=d[h],y=(i*u+h)*4;e[y]=x.x,e[y+1]=1-x.y,e[y+2]=x.z??0,e[y+3]=x.visibility??1}let m=g(e,i,Array.from({length:H},(h,x)=>x)),R=(i*u+t.BODY_CENTER)*4;e[R]=m[0],e[R+1]=m[1],e[R+2]=m[2],e[R+3]=m[3];let c=g(e,i,[t.LEFT_WRIST,t.LEFT_PINKY,t.LEFT_THUMB,t.LEFT_INDEX]),P=(i*u+t.LEFT_HAND_CENTER)*4;e[P]=c[0],e[P+1]=c[1],e[P+2]=c[2],e[P+3]=c[3];let A=g(e,i,[t.RIGHT_WRIST,t.RIGHT_PINKY,t.RIGHT_THUMB,t.RIGHT_INDEX]),F=(i*u+t.RIGHT_HAND_CENTER)*4;e[F]=A[0],e[F+1]=A[1],e[F+2]=A[2],e[F+3]=A[3];let C=g(e,i,[t.LEFT_ANKLE,t.LEFT_HEEL,t.LEFT_FOOT_INDEX]),D=(i*u+t.LEFT_FOOT_CENTER)*4;e[D]=C[0],e[D+1]=C[1],e[D+2]=C[2],e[D+3]=C[3];let I=g(e,i,[t.RIGHT_ANKLE,t.RIGHT_HEEL,t.RIGHT_FOOT_INDEX]),f=(i*u+t.RIGHT_FOOT_CENTER)*4;e[f]=I[0],e[f+1]=I[1],e[f+2]=I[2],e[f+3]=I[3];let O=g(e,i,[t.LEFT_SHOULDER,t.RIGHT_SHOULDER,t.LEFT_HIP,t.RIGHT_HIP]),K=(i*u+t.TORSO_CENTER)*4;e[K]=O[0],e[K+1]=O[1],e[K+2]=O[2],e[K+3]=O[3]}let E=Math.ceil(T/N);a.updateTextures({u_poseLandmarksTex:{data:e,width:N,height:E}})}function W(o){if(!o.landmarks||!e)return;let n=o.landmarks.length;Q(o.landmarks),J(o.segmentationMasks).catch(T=>{console.warn("[Pose Plugin] Mask texture update error:",T)}),a.updateUniforms({u_nPoses:n}),s?.onResults?.(o)}a.registerHook("init",async()=>{a.initializeTexture("u_poseMask",l),a.initializeUniform("u_maxPoses","int",B),a.initializeUniform("u_nPoses","int",0);let o=B*u;$=Math.ceil(o/N);let n=N*$*4;e=new Float32Array(n),a.initializeTexture("u_poseLandmarksTex",{data:e,width:N,height:$},{internalFormat:k.RGBA32F,type:k.FLOAT,minFilter:k.NEAREST,magFilter:k.NEAREST}),await q()}),a.registerHook("updateTextures",async o=>{let n=o[_];if(!(!n||(b.get(_)!==n&&(v=-1),b.set(_,n),!L)))try{let E=n instanceof HTMLVideoElement?"VIDEO":"IMAGE";if(S!==E&&(S=E,await L.setOptions({runningMode:S})),n instanceof HTMLVideoElement){if(n.videoWidth===0||n.videoHeight===0||n.readyState<2)return;if(n.currentTime!==v){v=n.currentTime;let i=performance.now(),d=L.detectForVideo(n,i);W(d)}}else if(n instanceof HTMLImageElement||n instanceof HTMLCanvasElement){if(n.width===0||n.height===0)return;let i=L.detect(n);W(i)}}catch(E){console.error("[Pose Plugin] Pose detection error:",E)}}),a.registerHook("destroy",()=>{L&&(L.close(),L=null),U=null,b.clear(),l.remove(),e=null}),V(`
uniform int u_maxPoses;
uniform int u_nPoses;
uniform sampler2D u_poseLandmarksTex;
uniform sampler2D u_poseMask;

#define POSE_LANDMARK_LEFT_EYE ${t.LEFT_EYE}
#define POSE_LANDMARK_RIGHT_EYE ${t.RIGHT_EYE}
#define POSE_LANDMARK_LEFT_SHOULDER ${t.LEFT_SHOULDER}
#define POSE_LANDMARK_RIGHT_SHOULDER ${t.RIGHT_SHOULDER}
#define POSE_LANDMARK_LEFT_ELBOW ${t.LEFT_ELBOW}
#define POSE_LANDMARK_RIGHT_ELBOW ${t.RIGHT_ELBOW}
#define POSE_LANDMARK_LEFT_HIP ${t.LEFT_HIP}
#define POSE_LANDMARK_RIGHT_HIP ${t.RIGHT_HIP}
#define POSE_LANDMARK_LEFT_KNEE ${t.LEFT_KNEE}
#define POSE_LANDMARK_RIGHT_KNEE ${t.RIGHT_KNEE}
#define POSE_LANDMARK_BODY_CENTER ${t.BODY_CENTER}
#define POSE_LANDMARK_LEFT_HAND_CENTER ${t.LEFT_HAND_CENTER}
#define POSE_LANDMARK_RIGHT_HAND_CENTER ${t.RIGHT_HAND_CENTER}
#define POSE_LANDMARK_LEFT_FOOT_CENTER ${t.LEFT_FOOT_CENTER}
#define POSE_LANDMARK_RIGHT_FOOT_CENTER ${t.RIGHT_FOOT_CENTER}
#define POSE_LANDMARK_TORSO_CENTER ${t.TORSO_CENTER}

vec4 poseLandmark(int poseIndex, int landmarkIndex) {
	int i = poseIndex * ${u} + landmarkIndex;
	int x = i % ${N};
	int y = i / ${N};
	return texelFetch(u_poseLandmarksTex, ivec2(x, y), 0);
}
float inBody(vec2 pos) { return texture(u_poseMask, pos).g; }`)}}var Te=_e;
//# sourceMappingURL=pose.js.map