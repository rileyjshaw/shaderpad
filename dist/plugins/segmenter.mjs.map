{"version":3,"sources":["../../src/plugins/segmenter.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tgenerateGLSLFn,\n\tdummyTexture,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { ImageSegmenter, ImageSegmenterResult, MPMask } from '@mediapipe/tasks-vision';\n\nexport interface SegmenterPluginOptions {\n\tmodelPath?: string;\n\toutputCategoryMask?: boolean;\n\thistory?: number;\n}\n\nconst DEFAULT_SEGMENTER_OPTIONS: Required<Omit<SegmenterPluginOptions, 'history'>> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/image_segmenter/hair_segmenter/float32/latest/hair_segmenter.tflite',\n\toutputCategoryMask: false,\n};\n\nfunction createMaskShaderSource(numMasks: number): string {\n\tconst uniforms = Array.from({ length: numMasks }, (_, i) => `uniform sampler2D u_confidenceMask${i};`).join('\\n');\n\n\tconst sampleByIndex = Array.from(\n\t\t{ length: numMasks },\n\t\t(_, i) => `\\t\\t${i > 0 ? 'else ' : ''}if (i == ${i}) c = texelFetch(u_confidenceMask${i}, texCoord, 0).r;`\n\t).join('\\n');\n\n\treturn `#version 300 es\nprecision mediump float;\nin vec2 v_uv;\nout vec4 outColor;\n${uniforms}\n\nvoid main() {\n\tivec2 texCoord = ivec2(v_uv * vec2(textureSize(u_confidenceMask0, 0)));\n\tfloat maxConfidence = 0.0;\n\tint maxIndex = 0;\n\n\tfor (int i = 0; i < ${numMasks}; ++i) {\n\t\tfloat c = 0.0;\n${sampleByIndex}\n\t\tif (c > maxConfidence) {\n\t\t\tmaxConfidence = c;\n\t\t\tmaxIndex = i;\n\t\t}\n\t}\n\n\t// Normalize index: 0 = background, 1/(n-1) to 1 for foreground categories.\n\tfloat normalizedIndex = float(maxIndex) / float(max(1, ${numMasks - 1}));\n\toutColor = vec4(normalizedIndex, maxConfidence, 0.0, 1.0);\n}`;\n}\n\ninterface SharedDetector {\n\tsegmenter: ImageSegmenter;\n\tcanvas: OffscreenCanvas;\n\tsubscribers: Map<() => void, boolean>;\n\tstate: {\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: ImageSegmenterResult | null;\n\t\tpending: Promise<void>;\n\t};\n\tlabels: string[];\n\tnumCategories: number;\n\tmask: {\n\t\tshader: ShaderPad;\n\t};\n}\nconst sharedDetectors = new Map<string, SharedDetector>();\n\nfunction updateMaskCanvas(detector: SharedDetector, confidenceMasks: MPMask[]) {\n\tconst {\n\t\tmask: { shader },\n\t} = detector;\n\n\tconst textures: Record<string, WebGLTexture> = {};\n\tfor (let i = 0; i < confidenceMasks.length; ++i) {\n\t\ttextures[`u_confidenceMask${i}`] = confidenceMasks[i].getAsWebGLTexture();\n\t}\n\tshader.updateTextures(textures);\n\tshader.draw();\n\tconfidenceMasks.forEach(m => m.close());\n}\n\nfunction segmenter(config: { textureName: string; options?: SegmenterPluginOptions }) {\n\tconst { textureName, options: { history, ...mediapipeOptions } = {} } = config;\n\tconst options = { ...DEFAULT_SEGMENTER_OPTIONS, ...mediapipeOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst sharedCanvas = existingDetector?.canvas ?? new OffscreenCanvas(1, 1);\n\t\tlet detector: SharedDetector | null = null;\n\t\tlet skipHistoryWrite = false;\n\n\t\tfunction onResult() {\n\t\t\tif (!detector) return;\n\t\t\tshaderPad.updateTextures({ u_segmentMask: detector.canvas }, { skipHistoryWrite });\n\t\t\temitHook('segmenter:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { ImageSegmenter }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\t// Single shared canvas for MediaPipe and maskShader (same WebGL context required\n\t\t\t\t// because maskShader uses textures from MediaPipe via getAsWebGLTexture).\n\t\t\t\tconst imageSegmenter = await ImageSegmenter.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: sharedCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\toutputCategoryMask: options.outputCategoryMask,\n\t\t\t\t\toutputConfidenceMasks: true,\n\t\t\t\t});\n\n\t\t\t\tconst labels = imageSegmenter.getLabels();\n\t\t\t\tconst numCategories = labels.length || 1;\n\n\t\t\t\tconst maskShader = new ShaderPad(createMaskShaderSource(numCategories), { canvas: sharedCanvas });\n\t\t\t\tfor (let i = 0; i < numCategories; ++i) {\n\t\t\t\t\tmaskShader.initializeTexture(`u_confidenceMask${i}`, dummyTexture);\n\t\t\t\t}\n\n\t\t\t\tdetector = {\n\t\t\t\t\tsegmenter: imageSegmenter,\n\t\t\t\t\tcanvas: sharedCanvas,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tstate: {\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t},\n\t\t\t\t\tlabels,\n\t\t\t\t\tnumCategories,\n\t\t\t\t\tmask: {\n\t\t\t\t\t\tshader: maskShader,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector!.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_numCategories', 'int', 1);\n\t\t\tshaderPad.initializeTexture('u_segmentMask', sharedCanvas, {\n\t\t\t\tpreserveY: true,\n\t\t\t\tminFilter: 'NEAREST',\n\t\t\t\tmagFilter: 'NEAREST',\n\t\t\t\thistory,\n\t\t\t});\n\t\t\tinitPromise.then(() => {\n\t\t\t\tshaderPad.updateUniforms({ u_numCategories: detector!.numCategories });\n\t\t\t\temitHook('segmenter:ready');\n\t\t\t});\n\t\t});\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) detectSegments(source);\n\t\t});\n\n\t\tshaderPad.on(\n\t\t\t'updateTextures',\n\t\t\t(updates: Record<string, TextureSource>, options?: { skipHistoryWrite?: boolean }) => {\n\t\t\t\tconst source = updates[textureName];\n\t\t\t\tif (isMediaPipeSource(source)) {\n\t\t\t\t\tskipHistoryWrite = options?.skipHistoryWrite ?? false;\n\t\t\t\t\tdetectSegments(source);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectSegments(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tconst callOrder = ++nDetectionCalls;\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (callOrder !== nDetectionCalls || !detector) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.segmenter.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: ImageSegmenterResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.segmenter.segmentForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.segmenter.segment(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result?.confidenceMasks && result.confidenceMasks.length > 0) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tupdateMaskCanvas(detector, result.confidenceMasks);\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result && !detector.subscribers.get(onResult)) {\n\t\t\t\t\tonResult();\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.segmenter.close();\n\t\t\t\t\tdetector.mask.shader?.destroy();\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tconst { fn } = generateGLSLFn(history);\n\t\tconst sampleMask = history\n\t\t\t? `int layer = (u_segmentMaskFrameOffset - framesAgo + ${history}) % ${history};\n\tvec4 mask = texture(u_segmentMask, vec3(pos, float(layer)));`\n\t\t\t: `vec4 mask = texture(u_segmentMask, pos);`;\n\n\t\tinjectGLSL(`\nuniform sampler2D${history ? 'Array' : ''} u_segmentMask;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_segmentMaskFrameOffset;`\n\t\t\t\t: ''\n\t\t}\nuniform int u_numCategories;\n\n${fn(\n\t'vec2',\n\t'segmentAt',\n\t'vec2 pos',\n\t`${sampleMask}\n\treturn vec2(mask.r, mask.g);`\n)}`);\n\t};\n}\n\nexport default segmenter;\n"],"mappings":"gHAiBA,IAAMA,EAA+E,CACpF,UACC,sHACD,mBAAoB,EACrB,EAEA,SAASC,EAAuBC,EAA0B,CACzD,IAAMC,EAAW,MAAM,KAAK,CAAE,OAAQD,CAAS,EAAG,CAACE,EAAGC,IAAM,qCAAqCA,CAAC,GAAG,EAAE,KAAK;AAAA,CAAI,EAE1GC,EAAgB,MAAM,KAC3B,CAAE,OAAQJ,CAAS,EACnB,CAACE,EAAGC,IAAM,KAAOA,EAAI,EAAI,QAAU,EAAE,YAAYA,CAAC,oCAAoCA,CAAC,mBACxF,EAAE,KAAK;AAAA,CAAI,EAEX,MAAO;AAAA;AAAA;AAAA;AAAA,EAINF,CAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAOaD,CAAQ;AAAA;AAAA,EAE7BI,CAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0DAQ2CJ,EAAW,CAAC;AAAA;AAAA,EAGtE,CAoBA,IAAMK,EAAkB,IAAI,IAE5B,SAASC,EAAiBC,EAA0BC,EAA2B,CAC9E,GAAM,CACL,KAAM,CAAE,OAAAC,CAAO,CAChB,EAAIF,EAEEG,EAAyC,CAAC,EAChD,QAASP,EAAI,EAAGA,EAAIK,EAAgB,OAAQ,EAAEL,EAC7CO,EAAS,mBAAmBP,CAAC,EAAE,EAAIK,EAAgBL,CAAC,EAAE,kBAAkB,EAEzEM,EAAO,eAAeC,CAAQ,EAC9BD,EAAO,KAAK,EACZD,EAAgB,QAAQG,GAAKA,EAAE,MAAM,CAAC,CACvC,CAEA,SAASC,EAAUC,EAAmE,CACrF,GAAM,CAAE,YAAAC,EAAa,QAAS,CAAE,QAAAC,EAAS,GAAGC,CAAiB,EAAI,CAAC,CAAE,EAAIH,EAClEI,EAAU,CAAE,GAAGnB,EAA2B,GAAGkB,CAAiB,EAC9DE,EAAaC,EAAY,CAAE,GAAGF,EAAS,YAAAH,CAAY,CAAC,EAE1D,OAAO,SAAUM,EAAsBC,EAAwB,CAC9D,GAAM,CAAE,WAAAC,EAAY,SAAAC,CAAS,EAAIF,EAG3BG,EADmBnB,EAAgB,IAAIa,CAAU,GAChB,QAAU,IAAI,gBAAgB,EAAG,CAAC,EACrEX,EAAkC,KAClCkB,EAAmB,GAEvB,SAASC,GAAW,CACdnB,IACLa,EAAU,eAAe,CAAE,cAAeb,EAAS,MAAO,EAAG,CAAE,iBAAAkB,CAAiB,CAAC,EACjFF,EAAS,mBAAoBhB,EAAS,MAAM,MAAM,EACnD,CAEA,eAAeoB,GAAqB,CACnC,GAAItB,EAAgB,IAAIa,CAAU,EACjCX,EAAWF,EAAgB,IAAIa,CAAU,MACnC,CACN,GAAM,CAACU,EAAW,CAAE,eAAAC,CAAe,CAAC,EAAI,MAAM,QAAQ,IAAI,CACzDC,EAAiB,EACjB,OAAO,yBAAyB,CACjC,CAAC,EAGKC,EAAiB,MAAMF,EAAe,kBAAkBD,EAAW,CACxE,YAAa,CACZ,eAAgBX,EAAQ,UACxB,SAAU,KACX,EACA,OAAQO,EACR,YAAa,QACb,mBAAoBP,EAAQ,mBAC5B,sBAAuB,EACxB,CAAC,EAEKe,EAASD,EAAe,UAAU,EAClCE,EAAgBD,EAAO,QAAU,EAEjCE,EAAa,IAAIC,EAAUpC,EAAuBkC,CAAa,EAAG,CAAE,OAAQT,CAAa,CAAC,EAChG,QAASrB,EAAI,EAAGA,EAAI8B,EAAe,EAAE9B,EACpC+B,EAAW,kBAAkB,mBAAmB/B,CAAC,GAAIiC,CAAY,EAGlE7B,EAAW,CACV,UAAWwB,EACX,OAAQP,EACR,YAAa,IAAI,IACjB,MAAO,CACN,YAAa,QACb,OAAQ,KACR,UAAW,GACX,gBAAiB,EACjB,OAAQ,KACR,QAAS,QAAQ,QAAQ,CAC1B,EACA,OAAAQ,EACA,cAAAC,EACA,KAAM,CACL,OAAQC,CACT,CACD,EACA7B,EAAgB,IAAIa,EAAYX,CAAQ,CACzC,CAEAA,EAAU,YAAY,IAAImB,EAAU,EAAK,CAC1C,CACA,IAAMW,EAAcV,EAAmB,EAEvCP,EAAU,GAAG,OAAQ,IAAM,CAC1BA,EAAU,kBAAkB,kBAAmB,MAAO,CAAC,EACvDA,EAAU,kBAAkB,gBAAiBI,EAAc,CAC1D,UAAW,GACX,UAAW,UACX,UAAW,UACX,QAAAT,CACD,CAAC,EACDsB,EAAY,KAAK,IAAM,CACtBjB,EAAU,eAAe,CAAE,gBAAiBb,EAAU,aAAc,CAAC,EACrEgB,EAAS,iBAAiB,CAC3B,CAAC,CACF,CAAC,EAEDH,EAAU,GAAG,oBAAqB,CAACkB,EAAcC,IAA0B,CACtED,IAASxB,GAAe0B,EAAkBD,CAAM,GAAGE,EAAeF,CAAM,CAC7E,CAAC,EAEDnB,EAAU,GACT,iBACA,CAACsB,EAAwCzB,IAA6C,CACrF,IAAMsB,EAASG,EAAQ5B,CAAW,EAC9B0B,EAAkBD,CAAM,IAC3Bd,EAAmBR,GAAS,kBAAoB,GAChDwB,EAAeF,CAAM,EAEvB,CACD,EAEA,IAAII,EAAkB,EACtB,eAAeF,EAAeF,EAAyB,CACtD,IAAMK,EAAM,YAAY,IAAI,EACtBC,EAAY,EAAEF,EACpB,MAAMN,EACD9B,IAELA,EAAS,MAAM,QAAUA,EAAS,MAAM,QAAQ,KAAK,SAAY,CAChE,GAAIsC,IAAcF,GAAmB,CAACpC,EAAU,OAEhD,IAAMuC,EAAeP,aAAkB,iBAAmB,QAAU,QAChEhC,EAAS,MAAM,cAAgBuC,IAClCvC,EAAS,MAAM,YAAcuC,EAC7B,MAAMvC,EAAS,UAAU,WAAW,CAAE,YAAauC,CAAa,CAAC,GAGlE,IAAIC,EAAe,GAiBnB,GAfIR,IAAWhC,EAAS,MAAM,QAC7BA,EAAS,MAAM,OAASgC,EACxBhC,EAAS,MAAM,UAAY,GAC3BwC,EAAe,IACLR,aAAkB,iBACxBA,EAAO,cAAgBhC,EAAS,MAAM,YACzCA,EAAS,MAAM,UAAYgC,EAAO,YAClCQ,EAAe,IAEJR,aAAkB,kBAC1BK,EAAMrC,EAAS,MAAM,gBAAkB,IAC1CwC,EAAe,IAIbA,EAAc,CACjB,IAAIC,EACJ,GAAIT,aAAkB,iBAAkB,CACvC,GAAIA,EAAO,aAAe,GAAKA,EAAO,cAAgB,GAAKA,EAAO,WAAa,EAAG,OAClFS,EAASzC,EAAS,UAAU,gBAAgBgC,EAAQK,CAAG,CACxD,KAAO,CACN,GAAIL,EAAO,QAAU,GAAKA,EAAO,SAAW,EAAG,OAC/CS,EAASzC,EAAS,UAAU,QAAQgC,CAAM,CAC3C,CAEA,GAAIS,GAAQ,iBAAmBA,EAAO,gBAAgB,OAAS,EAAG,CACjEzC,EAAS,MAAM,gBAAkBqC,EACjCrC,EAAS,MAAM,OAASyC,EACxB1C,EAAiBC,EAAUyC,EAAO,eAAe,EACjD,QAAWC,KAAM1C,EAAS,YAAY,KAAK,EAC1C0C,EAAG,EACH1C,EAAS,YAAY,IAAI0C,EAAI,EAAI,CAEnC,CACD,MAAW1C,EAAS,MAAM,QAAU,CAACA,EAAS,YAAY,IAAImB,CAAQ,IACrEA,EAAS,EACTnB,EAAS,YAAY,IAAImB,EAAU,EAAI,EAEzC,CAAC,EAED,MAAMnB,EAAS,MAAM,QACtB,CAEAa,EAAU,GAAG,UAAW,IAAM,CACzBb,IACHA,EAAS,YAAY,OAAOmB,CAAQ,EAChCnB,EAAS,YAAY,OAAS,IACjCA,EAAS,UAAU,MAAM,EACzBA,EAAS,KAAK,QAAQ,QAAQ,EAC9BF,EAAgB,OAAOa,CAAU,IAGnCX,EAAW,IACZ,CAAC,EAED,GAAM,CAAE,GAAA2C,CAAG,EAAIC,EAAepC,CAAO,EAC/BqC,EAAarC,EAChB,uDAAuDA,CAAO,OAAOA,CAAO;AAAA,+DAE5E,2CAEHO,EAAW;AAAA,mBACMP,EAAU,QAAU,EAAE,kBACtCA,EACG;AAAA,uCAEA,EACJ;AAAA;AAAA;AAAA,EAGAmC,EACD,OACA,YACA,WACA,GAAGE,CAAU;AAAA,8BAEd,CAAC,EAAE,CACF,CACD,CAEA,IAAOC,EAAQzC","names":["DEFAULT_SEGMENTER_OPTIONS","createMaskShaderSource","numMasks","uniforms","_","i","sampleByIndex","sharedDetectors","updateMaskCanvas","detector","confidenceMasks","shader","textures","m","segmenter","config","textureName","history","mediapipeOptions","options","optionsKey","hashOptions","shaderPad","context","injectGLSL","emitHook","sharedCanvas","skipHistoryWrite","onResult","initializeDetector","mediaPipe","ImageSegmenter","getSharedFileset","imageSegmenter","labels","numCategories","maskShader","index_default","dummyTexture","initPromise","name","source","isMediaPipeSource","detectSegments","updates","nDetectionCalls","now","callOrder","requiredMode","shouldDetect","result","cb","fn","generateGLSLFn","sampleMask","segmenter_default"]}