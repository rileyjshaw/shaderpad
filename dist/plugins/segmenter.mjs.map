{"version":3,"sources":["../../src/plugins/segmenter.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tgenerateGLSLFn,\n\tdummyTexture,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { ImageSegmenter, ImageSegmenterResult, MPMask } from '@mediapipe/tasks-vision';\n\nexport interface SegmenterPluginOptions {\n\tmodelPath?: string;\n\toutputConfidenceMasks?: boolean;\n\thistory?: number;\n}\n\nconst dummyTextureFloat32 = { data: new Float32Array(1).fill(1), width: 1, height: 1 };\n\nconst DEFAULT_SEGMENTER_OPTIONS: Required<Omit<SegmenterPluginOptions, 'history'>> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter/float16/latest/selfie_segmenter.tflite',\n\toutputConfidenceMasks: false,\n};\n\nconst MASK_SHADER_SOURCE = `#version 300 es\nprecision mediump float;\nin vec2 v_uv;\nout vec4 outColor;\nuniform sampler2D u_categoryMask;\nuniform sampler2D u_confidenceMask;\nuniform float u_maxCategoryIndex;\n\nvoid main() {\n\tvec2 uv = vec2(v_uv.x, 1.0 - v_uv.y);\n\tfloat normalizedCategoryIndex = texture(u_categoryMask, uv).r * 255.0 / u_maxCategoryIndex;\n\tfloat confidence = texture(u_confidenceMask, uv).r;\n\toutColor = vec4(confidence, normalizedCategoryIndex, 0.0, 1.0);\n}`;\n\ninterface SharedDetector {\n\tsegmenter: ImageSegmenter;\n\toutputConfidenceMasks: boolean;\n\tsubscribers: Map<Function, boolean>;\n\tnumCategories: number;\n\tstate: {\n\t\tnCalls: number;\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: ImageSegmenterResult | null;\n\t\tpending: Promise<void>;\n\t};\n\tmask: {\n\t\tcanvas: OffscreenCanvas;\n\t\tshader: ShaderPad;\n\t\tconfidence: {\n\t\t\tdata: Float32Array | null;\n\t\t\twidth: number;\n\t\t\theight: number;\n\t\t};\n\t};\n}\nconst sharedDetectors = new Map<string, SharedDetector>();\n\nfunction updateMask(detector: SharedDetector, categoryMask: MPMask, confidenceMasks?: MPMask[]) {\n\tconst {\n\t\tnumCategories,\n\t\toutputConfidenceMasks,\n\t\tmask: { shader, confidence },\n\t} = detector;\n\tconst { width, height } = categoryMask;\n\n\tif (confidence.width !== width || confidence.height !== height) {\n\t\tconfidence.width = width;\n\t\tconfidence.height = height;\n\t\tconfidence.data = new Float32Array(width * height).fill(1);\n\t}\n\n\tif (outputConfidenceMasks && confidenceMasks?.length) {\n\t\tconst categoryData = categoryMask.getAsUint8Array();\n\t\tconst confidenceArrays = confidenceMasks.map(m => m.getAsFloat32Array());\n\t\tconst data = confidence.data!;\n\t\tfor (let i = 0; i < categoryData.length; ++i) {\n\t\t\tconst categoryIndex = categoryData[i];\n\t\t\tdata[i] = confidenceArrays[categoryIndex][i];\n\t\t}\n\t}\n\n\tshader.updateTextures({\n\t\tu_categoryMask: categoryMask.getAsWebGLTexture(),\n\t\tu_confidenceMask: confidence,\n\t});\n\tshader.step();\n\tcategoryMask.close();\n\tconfidenceMasks?.forEach(m => m.close());\n}\n\nfunction segmenter(config: { textureName: string; options?: SegmenterPluginOptions }) {\n\tconst { textureName, options: { history, ...mediapipeOptions } = {} } = config;\n\tconst options = { ...DEFAULT_SEGMENTER_OPTIONS, ...mediapipeOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst mediapipeCanvas = existingDetector?.mask.canvas ?? new OffscreenCanvas(1, 1);\n\t\tlet detector: SharedDetector | null = null;\n\t\tlet destroyed = false;\n\t\tlet skipHistoryWrite = false;\n\n\t\tfunction onResult(singleHistoryWriteIndex?: number) {\n\t\t\tif (!detector) return;\n\t\t\tlet historyWriteIndex: number | number[] | undefined = singleHistoryWriteIndex;\n\t\t\tif (typeof historyWriteIndex === 'undefined' && pendingBackfillSlots.length > 0) {\n\t\t\t\thistoryWriteIndex = pendingBackfillSlots;\n\t\t\t\tpendingBackfillSlots = [];\n\t\t\t}\n\t\t\tshaderPad.updateTextures(\n\t\t\t\t{ u_segmentMask: detector.mask.shader },\n\t\t\t\thistory ? { skipHistoryWrite, historyWriteIndex } : undefined\n\t\t\t);\n\t\t\temitHook('segmenter:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { ImageSegmenter }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\tif (destroyed) return;\n\n\t\t\t\tconst imageSegmenter = await ImageSegmenter.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\toutputCategoryMask: true,\n\t\t\t\t\toutputConfidenceMasks: options.outputConfidenceMasks,\n\t\t\t\t});\n\t\t\t\tif (destroyed) {\n\t\t\t\t\timageSegmenter.close();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst maskShader = new ShaderPad(MASK_SHADER_SOURCE, { canvas: mediapipeCanvas });\n\t\t\t\tmaskShader.initializeTexture('u_categoryMask', dummyTexture);\n\t\t\t\tmaskShader.initializeTexture('u_confidenceMask', dummyTextureFloat32, {\n\t\t\t\t\tformat: 'RED',\n\t\t\t\t\tinternalFormat: 'R32F',\n\t\t\t\t\ttype: 'FLOAT',\n\t\t\t\t\tminFilter: 'NEAREST',\n\t\t\t\t\tmagFilter: 'NEAREST',\n\t\t\t\t});\n\t\t\t\tconst numCategories = imageSegmenter.getLabels().length || 1;\n\t\t\t\tmaskShader.initializeUniform('u_maxCategoryIndex', 'float', Math.max(1, numCategories - 1));\n\n\t\t\t\tdetector = {\n\t\t\t\t\tsegmenter: imageSegmenter,\n\t\t\t\t\toutputConfidenceMasks: options.outputConfidenceMasks,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tnumCategories,\n\t\t\t\t\tstate: {\n\t\t\t\t\t\tnCalls: 0,\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t},\n\t\t\t\t\tmask: {\n\t\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\t\tshader: maskShader,\n\t\t\t\t\t\tconfidence: {\n\t\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\t\theight: 0,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector!.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_numCategories', 'int', 1);\n\t\t\tshaderPad.initializeTexture('u_segmentMask', mediapipeCanvas, {\n\t\t\t\tminFilter: 'NEAREST',\n\t\t\t\tmagFilter: 'NEAREST',\n\t\t\t\thistory,\n\t\t\t});\n\t\t\tinitPromise.then(() => {\n\t\t\t\tif (destroyed || !detector) return;\n\t\t\t\tshaderPad.updateUniforms({ u_numCategories: detector.numCategories });\n\t\t\t\temitHook('segmenter:ready');\n\t\t\t});\n\t\t});\n\n\t\tlet historyWriteCounter = 0;\n\t\tlet pendingBackfillSlots: number[] = [];\n\t\tconst writeToHistory = () => {\n\t\t\tif (!history) return;\n\t\t\tonResult(historyWriteCounter); // Write stale data immediately.\n\t\t\tpendingBackfillSlots.push(historyWriteCounter); // Queue up backfill with more recent data.\n\t\t\thistoryWriteCounter = (historyWriteCounter + 1) % (history + 1);\n\t\t};\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) {\n\t\t\t\twriteToHistory();\n\t\t\t\tdetectSegments(source);\n\t\t\t}\n\t\t});\n\n\t\tshaderPad.on(\n\t\t\t'updateTextures',\n\t\t\t(updates: Record<string, TextureSource>, options?: { skipHistoryWrite?: boolean }) => {\n\t\t\t\tconst source = updates[textureName];\n\t\t\t\tif (isMediaPipeSource(source)) {\n\t\t\t\t\tskipHistoryWrite = options?.skipHistoryWrite ?? false;\n\t\t\t\t\tif (!skipHistoryWrite) writeToHistory();\n\t\t\t\t\tdetectSegments(source);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tasync function detectSegments(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\t\t\tconst callOrder = ++detector.state.nCalls;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (!detector || callOrder !== detector.state.nCalls) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.segmenter.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: ImageSegmenterResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.segmenter.segmentForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.segmenter.segment(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tif (result.categoryMask) {\n\t\t\t\t\t\t\tupdateMask(detector, result.categoryMask, result.confidenceMasks);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result) {\n\t\t\t\t\tfor (const [cb, hasCalled] of detector.subscribers.entries()) {\n\t\t\t\t\t\tif (!hasCalled) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tdestroyed = true;\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.segmenter.close();\n\t\t\t\t\tdetector.mask.shader.destroy();\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tconst { fn } = generateGLSLFn(history);\n\t\tconst sampleMask = history\n\t\t\t? `int layer = (u_segmentMaskFrameOffset - framesAgo + ${history + 1}) % ${history + 1};\n\tvec4 mask = texture(u_segmentMask, vec3(pos, float(layer)));`\n\t\t\t: `vec4 mask = texture(u_segmentMask, pos);`;\n\n\t\tinjectGLSL(`\nuniform ${history ? 'highp' : 'mediump'} sampler2D${history ? 'Array' : ''} u_segmentMask;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_segmentMaskFrameOffset;`\n\t\t\t\t: ''\n\t\t}\nuniform int u_numCategories;\n\n${fn(\n\t'vec2',\n\t'segmentAt',\n\t'vec2 pos',\n\t`${sampleMask}\n\treturn vec2(mask.r, mask.g);`\n)}`);\n\t};\n}\n\nexport default segmenter;\n"],"mappings":"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","names":["dummyTextureFloat32","DEFAULT_SEGMENTER_OPTIONS","MASK_SHADER_SOURCE","sharedDetectors","updateMask","detector","categoryMask","confidenceMasks","numCategories","outputConfidenceMasks","shader","confidence","width","height","categoryData","confidenceArrays","m","data","i","categoryIndex","segmenter","config","textureName","history","mediapipeOptions","options","optionsKey","hashOptions","shaderPad","context","injectGLSL","emitHook","mediapipeCanvas","destroyed","skipHistoryWrite","onResult","singleHistoryWriteIndex","historyWriteIndex","pendingBackfillSlots","initializeDetector","mediaPipe","ImageSegmenter","getSharedFileset","imageSegmenter","maskShader","index_default","dummyTexture","initPromise","historyWriteCounter","writeToHistory","name","source","isMediaPipeSource","detectSegments","updates","now","callOrder","requiredMode","shouldDetect","result","cb","hasCalled","fn","generateGLSLFn","sampleMask","segmenter_default"]}