{"version":3,"sources":["../../src/plugins/segmenter.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tgenerateGLSLFn,\n\tdummyTexture,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { ImageSegmenter, ImageSegmenterResult, MPMask } from '@mediapipe/tasks-vision';\n\nexport interface SegmenterPluginOptions {\n\tmodelPath?: string;\n\toutputCategoryMask?: boolean;\n\thistory?: number;\n}\n\nconst DEFAULT_SEGMENTER_OPTIONS: Required<Omit<SegmenterPluginOptions, 'history'>> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter/float16/latest/selfie_segmenter.tflite',\n\t// 'https://storage.googleapis.com/mediapipe-models/image_segmenter/hair_segmenter/float32/latest/hair_segmenter.tflite',\n\toutputCategoryMask: false,\n};\n\nfunction createMaskShaderSource(numMasks: number): string {\n\tconst uniforms = Array.from({ length: numMasks }, (_, i) => `uniform mediump sampler2D u_confidenceMask${i};`).join(\n\t\t'\\n'\n\t);\n\n\tconst sampleByIndex = Array.from(\n\t\t{ length: numMasks },\n\t\t(_, i) => `\\t\\t${i > 0 ? 'else ' : ''}if (i == ${i}) c = texelFetch(u_confidenceMask${i}, texCoord, 0).r;`\n\t).join('\\n');\n\n\treturn `#version 300 es\nprecision mediump float;\nin vec2 v_uv;\nout vec4 outColor;\n${uniforms}\n\nvoid main() {\n\tivec2 texCoord = ivec2(vec2(v_uv.x, 1.0 - v_uv.y) * vec2(textureSize(u_confidenceMask0, 0)));\n\tfloat maxConfidence = 0.0;\n\tint maxIndex = 0;\n\n\tfor (int i = 0; i < ${numMasks}; ++i) {\n\t\tfloat c = 0.0;\n${sampleByIndex}\n\t\tif (c > maxConfidence) {\n\t\t\tmaxConfidence = c;\n\t\t\tmaxIndex = i;\n\t\t}\n\t}\n\n\t// Normalize index: 0 = background, 1/(n-1) to 1 for foreground categories.\n\tfloat normalizedIndex = float(maxIndex) / float(max(1, ${numMasks - 1}));\n\toutColor = vec4(normalizedIndex, maxConfidence, 0.0, 1.0);\n}`;\n}\n\ninterface SharedDetector {\n\tsegmenter: ImageSegmenter;\n\tmediapipeCanvas: OffscreenCanvas;\n\tmaskShader: ShaderPad;\n\tsubscribers: Map<Function, boolean>;\n\tstate: {\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: ImageSegmenterResult | null;\n\t\tpending: Promise<void>;\n\t};\n\tlabels: string[];\n\tnumCategories: number;\n}\nconst sharedDetectors = new Map<string, SharedDetector>();\n\nfunction updateMask(detector: SharedDetector, confidenceMasks: MPMask[]) {\n\tconst { maskShader } = detector;\n\n\tconst textures: Record<string, WebGLTexture> = {};\n\tfor (let i = 0; i < confidenceMasks.length; ++i) {\n\t\ttextures[`u_confidenceMask${i}`] = confidenceMasks[i].getAsWebGLTexture();\n\t}\n\tmaskShader.updateTextures(textures);\n\tmaskShader.step();\n\tconfidenceMasks.forEach(m => m.close());\n}\n\nfunction segmenter(config: { textureName: string; options?: SegmenterPluginOptions }) {\n\tconst { textureName, options: { history, ...mediapipeOptions } = {} } = config;\n\tconst options = { ...DEFAULT_SEGMENTER_OPTIONS, ...mediapipeOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst mediapipeCanvas = existingDetector?.mediapipeCanvas ?? new OffscreenCanvas(1, 1);\n\t\tlet detector: SharedDetector | null = null;\n\t\tlet destroyed = false;\n\t\tlet skipHistoryWrite = false;\n\n\t\tfunction onResult(singleHistoryWriteIndex?: number) {\n\t\t\tif (!detector) return;\n\t\t\tlet historyWriteIndex: number | number[] | undefined = singleHistoryWriteIndex;\n\t\t\tif (typeof historyWriteIndex === 'undefined' && pendingBackfillSlots.length > 0) {\n\t\t\t\thistoryWriteIndex = pendingBackfillSlots;\n\t\t\t\tpendingBackfillSlots = [];\n\t\t\t}\n\t\t\tshaderPad.updateTextures(\n\t\t\t\t{ u_segmentMask: detector.maskShader },\n\t\t\t\thistory ? { skipHistoryWrite, historyWriteIndex } : undefined\n\t\t\t);\n\t\t\temitHook('segmenter:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { ImageSegmenter }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\tif (destroyed) return;\n\t\t\t\t// Single shared canvas for MediaPipe and maskShader (same WebGL context required\n\t\t\t\t// because maskShader uses textures from MediaPipe via getAsWebGLTexture).\n\t\t\t\tconst imageSegmenter = await ImageSegmenter.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\toutputCategoryMask: options.outputCategoryMask,\n\t\t\t\t\toutputConfidenceMasks: true,\n\t\t\t\t});\n\t\t\t\tif (destroyed) {\n\t\t\t\t\timageSegmenter.close();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst labels = imageSegmenter.getLabels();\n\t\t\t\tconst numCategories = labels.length || 1;\n\n\t\t\t\tconst maskShader = new ShaderPad(createMaskShaderSource(numCategories), { canvas: mediapipeCanvas });\n\t\t\t\tfor (let i = 0; i < numCategories; ++i) {\n\t\t\t\t\tmaskShader.initializeTexture(`u_confidenceMask${i}`, dummyTexture);\n\t\t\t\t}\n\n\t\t\t\tdetector = {\n\t\t\t\t\tsegmenter: imageSegmenter,\n\t\t\t\t\tmediapipeCanvas,\n\t\t\t\t\tmaskShader,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tstate: {\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t},\n\t\t\t\t\tlabels,\n\t\t\t\t\tnumCategories,\n\t\t\t\t};\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector!.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_numCategories', 'int', 1);\n\t\t\tshaderPad.initializeTexture('u_segmentMask', mediapipeCanvas, {\n\t\t\t\tminFilter: 'NEAREST',\n\t\t\t\tmagFilter: 'NEAREST',\n\t\t\t\thistory,\n\t\t\t});\n\t\t\tinitPromise.then(() => {\n\t\t\t\tif (destroyed || !detector) return;\n\t\t\t\tshaderPad.updateUniforms({ u_numCategories: detector.numCategories });\n\t\t\t\temitHook('segmenter:ready');\n\t\t\t});\n\t\t});\n\n\t\tlet historyWriteCounter = 0;\n\t\tlet pendingBackfillSlots: number[] = [];\n\t\tconst writeToHistory = () => {\n\t\t\tif (!history) return;\n\t\t\tonResult(historyWriteCounter); // Write stale data immediately.\n\t\t\tpendingBackfillSlots.push(historyWriteCounter); // Queue up backfill with more recent data.\n\t\t\thistoryWriteCounter = (historyWriteCounter + 1) % (history + 1);\n\t\t};\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) {\n\t\t\t\twriteToHistory();\n\t\t\t\tdetectSegments(source);\n\t\t\t}\n\t\t});\n\n\t\tshaderPad.on(\n\t\t\t'updateTextures',\n\t\t\t(updates: Record<string, TextureSource>, options?: { skipHistoryWrite?: boolean }) => {\n\t\t\t\tconst source = updates[textureName];\n\t\t\t\tif (isMediaPipeSource(source)) {\n\t\t\t\t\tskipHistoryWrite = options?.skipHistoryWrite ?? false;\n\t\t\t\t\tif (!skipHistoryWrite) writeToHistory();\n\t\t\t\t\tdetectSegments(source);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectSegments(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tconst callOrder = ++nDetectionCalls;\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (callOrder !== nDetectionCalls || !detector) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.segmenter.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: ImageSegmenterResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.segmenter.segmentForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.segmenter.segment(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tif (result.confidenceMasks && result.confidenceMasks.length > 0) {\n\t\t\t\t\t\t\tupdateMask(detector, result.confidenceMasks);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdetector.maskShader.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result) {\n\t\t\t\t\tfor (const [cb, hasCalled] of detector.subscribers.entries()) {\n\t\t\t\t\t\tif (!hasCalled) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tdestroyed = true;\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.segmenter.close();\n\t\t\t\t\tdetector.maskShader.destroy();\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tconst { fn } = generateGLSLFn(history);\n\t\tconst sampleMask = history\n\t\t\t? `int layer = (u_segmentMaskFrameOffset - framesAgo + ${history + 1}) % ${history + 1};\n\tvec4 mask = texture(u_segmentMask, vec3(pos, float(layer)));`\n\t\t\t: `vec4 mask = texture(u_segmentMask, pos);`;\n\n\t\tinjectGLSL(`\nuniform ${history ? 'highp' : 'mediump'} sampler2D${history ? 'Array' : ''} u_segmentMask;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_segmentMaskFrameOffset;`\n\t\t\t\t: ''\n\t\t}\nuniform int u_numCategories;\n\n${fn(\n\t'vec2',\n\t'segmentAt',\n\t'vec2 pos',\n\t`${sampleMask}\n\treturn vec2(mask.r, mask.g);`\n)}`);\n\t};\n}\n\nexport default segmenter;\n"],"mappings":"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","names":["DEFAULT_SEGMENTER_OPTIONS","createMaskShaderSource","numMasks","uniforms","_","sampleByIndex","sharedDetectors","updateMask","detector","confidenceMasks","maskShader","textures","m","segmenter","config","textureName","history","mediapipeOptions","options","optionsKey","hashOptions","shaderPad","context","injectGLSL","emitHook","mediapipeCanvas","destroyed","skipHistoryWrite","onResult","singleHistoryWriteIndex","historyWriteIndex","pendingBackfillSlots","initializeDetector","mediaPipe","ImageSegmenter","getSharedFileset","imageSegmenter","labels","numCategories","index_default","i","dummyTexture","initPromise","historyWriteCounter","writeToHistory","name","source","isMediaPipeSource","detectSegments","updates","nDetectionCalls","now","callOrder","requiredMode","shouldDetect","result","cb","hasCalled","fn","generateGLSLFn","sampleMask","segmenter_default"]}