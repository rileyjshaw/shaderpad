{"version":3,"sources":["../../src/plugins/segmenter.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tgenerateGLSLFn,\n\tdummyTexture,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { ImageSegmenter, ImageSegmenterResult, MPMask } from '@mediapipe/tasks-vision';\n\nexport interface SegmenterPluginOptions {\n\tmodelPath?: string;\n\toutputCategoryMask?: boolean;\n\thistory?: number;\n}\n\nconst DEFAULT_SEGMENTER_OPTIONS: Required<Omit<SegmenterPluginOptions, 'history'>> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/image_segmenter/hair_segmenter/float32/latest/hair_segmenter.tflite',\n\toutputCategoryMask: false,\n};\n\nfunction createMaskShaderSource(numMasks: number): string {\n\tconst uniforms = Array.from({ length: numMasks }, (_, i) => `uniform mediump sampler2D u_confidenceMask${i};`).join(\n\t\t'\\n'\n\t);\n\n\tconst sampleByIndex = Array.from(\n\t\t{ length: numMasks },\n\t\t(_, i) => `\\t\\t${i > 0 ? 'else ' : ''}if (i == ${i}) c = texelFetch(u_confidenceMask${i}, texCoord, 0).r;`\n\t).join('\\n');\n\n\treturn `#version 300 es\nprecision mediump float;\nin vec2 v_uv;\nout vec4 outColor;\n${uniforms}\n\nvoid main() {\n\tivec2 texCoord = ivec2(vec2(v_uv.x, 1.0 - v_uv.y) * vec2(textureSize(u_confidenceMask0, 0)));\n\tfloat maxConfidence = 0.0;\n\tint maxIndex = 0;\n\n\tfor (int i = 0; i < ${numMasks}; ++i) {\n\t\tfloat c = 0.0;\n${sampleByIndex}\n\t\tif (c > maxConfidence) {\n\t\t\tmaxConfidence = c;\n\t\t\tmaxIndex = i;\n\t\t}\n\t}\n\n\t// Normalize index: 0 = background, 1/(n-1) to 1 for foreground categories.\n\tfloat normalizedIndex = float(maxIndex) / float(max(1, ${numMasks - 1}));\n\toutColor = vec4(normalizedIndex, maxConfidence, 0.0, 1.0);\n}`;\n}\n\ninterface SharedDetector {\n\tsegmenter: ImageSegmenter;\n\tmediapipeCanvas: OffscreenCanvas;\n\tmaskShader: ShaderPad;\n\tsubscribers: Map<() => void, boolean>;\n\tstate: {\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: ImageSegmenterResult | null;\n\t\tpending: Promise<void>;\n\t};\n\tlabels: string[];\n\tnumCategories: number;\n}\nconst sharedDetectors = new Map<string, SharedDetector>();\n\nfunction updateMask(detector: SharedDetector, confidenceMasks: MPMask[]) {\n\tconst { maskShader } = detector;\n\n\tconst textures: Record<string, WebGLTexture> = {};\n\tfor (let i = 0; i < confidenceMasks.length; ++i) {\n\t\ttextures[`u_confidenceMask${i}`] = confidenceMasks[i].getAsWebGLTexture();\n\t}\n\tmaskShader.updateTextures(textures);\n\tmaskShader.draw();\n\tconfidenceMasks.forEach(m => m.close());\n}\n\nfunction segmenter(config: { textureName: string; options?: SegmenterPluginOptions }) {\n\tconst { textureName, options: { history, ...mediapipeOptions } = {} } = config;\n\tconst options = { ...DEFAULT_SEGMENTER_OPTIONS, ...mediapipeOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst mediapipeCanvas = existingDetector?.mediapipeCanvas ?? new OffscreenCanvas(1, 1);\n\t\tlet detector: SharedDetector | null = null;\n\t\tlet skipHistoryWrite = false;\n\n\t\tfunction onResult() {\n\t\t\tif (!detector) return;\n\t\t\tshaderPad.updateTextures({ u_segmentMask: detector.maskShader }, { skipHistoryWrite });\n\t\t\temitHook('segmenter:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { ImageSegmenter }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\t// Single shared canvas for MediaPipe and maskShader (same WebGL context required\n\t\t\t\t// because maskShader uses textures from MediaPipe via getAsWebGLTexture).\n\t\t\t\tconst imageSegmenter = await ImageSegmenter.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\toutputCategoryMask: options.outputCategoryMask,\n\t\t\t\t\toutputConfidenceMasks: true,\n\t\t\t\t});\n\n\t\t\t\tconst labels = imageSegmenter.getLabels();\n\t\t\t\tconst numCategories = labels.length || 1;\n\n\t\t\t\tconst maskShader = new ShaderPad(createMaskShaderSource(numCategories), { canvas: mediapipeCanvas });\n\t\t\t\tfor (let i = 0; i < numCategories; ++i) {\n\t\t\t\t\tmaskShader.initializeTexture(`u_confidenceMask${i}`, dummyTexture);\n\t\t\t\t}\n\n\t\t\t\tdetector = {\n\t\t\t\t\tsegmenter: imageSegmenter,\n\t\t\t\t\tmediapipeCanvas,\n\t\t\t\t\tmaskShader,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tstate: {\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t},\n\t\t\t\t\tlabels,\n\t\t\t\t\tnumCategories,\n\t\t\t\t};\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector!.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_numCategories', 'int', 1);\n\t\t\tshaderPad.initializeTexture('u_segmentMask', mediapipeCanvas, {\n\t\t\t\tminFilter: 'NEAREST',\n\t\t\t\tmagFilter: 'NEAREST',\n\t\t\t\thistory,\n\t\t\t});\n\t\t\tinitPromise.then(() => {\n\t\t\t\tshaderPad.updateUniforms({ u_numCategories: detector!.numCategories });\n\t\t\t\temitHook('segmenter:ready');\n\t\t\t});\n\t\t});\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) detectSegments(source);\n\t\t});\n\n\t\tshaderPad.on(\n\t\t\t'updateTextures',\n\t\t\t(updates: Record<string, TextureSource>, options?: { skipHistoryWrite?: boolean }) => {\n\t\t\t\tconst source = updates[textureName];\n\t\t\t\tif (isMediaPipeSource(source)) {\n\t\t\t\t\tskipHistoryWrite = options?.skipHistoryWrite ?? false;\n\t\t\t\t\tdetectSegments(source);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectSegments(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tconst callOrder = ++nDetectionCalls;\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (callOrder !== nDetectionCalls || !detector) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.segmenter.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: ImageSegmenterResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.segmenter.segmentForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.segmenter.segment(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tif (result.confidenceMasks && result.confidenceMasks.length > 0) {\n\t\t\t\t\t\t\tupdateMask(detector, result.confidenceMasks);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdetector.maskShader.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result && !detector.subscribers.get(onResult)) {\n\t\t\t\t\tonResult();\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.segmenter.close();\n\t\t\t\t\tdetector.maskShader.destroy();\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tconst { fn } = generateGLSLFn(history);\n\t\tconst sampleMask = history\n\t\t\t? `int layer = (u_segmentMaskFrameOffset - framesAgo + ${history}) % ${history};\n\tvec4 mask = texture(u_segmentMask, vec3(pos, float(layer)));`\n\t\t\t: `vec4 mask = texture(u_segmentMask, pos);`;\n\n\t\tinjectGLSL(`\nuniform ${history ? 'highp' : 'mediump'} sampler2D${history ? 'Array' : ''} u_segmentMask;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_segmentMaskFrameOffset;`\n\t\t\t\t: ''\n\t\t}\nuniform int u_numCategories;\n\n${fn(\n\t'vec2',\n\t'segmentAt',\n\t'vec2 pos',\n\t`${sampleMask}\n\treturn vec2(mask.r, mask.g);`\n)}`);\n\t};\n}\n\nexport default segmenter;\n"],"mappings":"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","names":["DEFAULT_SEGMENTER_OPTIONS","createMaskShaderSource","numMasks","uniforms","_","i","sampleByIndex","sharedDetectors","updateMask","detector","confidenceMasks","maskShader","textures","m","segmenter","config","textureName","history","mediapipeOptions","options","optionsKey","hashOptions","shaderPad","context","injectGLSL","emitHook","mediapipeCanvas","skipHistoryWrite","onResult","initializeDetector","mediaPipe","ImageSegmenter","getSharedFileset","imageSegmenter","labels","numCategories","index_default","dummyTexture","initPromise","name","source","isMediaPipeSource","detectSegments","updates","nDetectionCalls","now","callOrder","requiredMode","shouldDetect","result","cb","fn","generateGLSLFn","sampleMask","segmenter_default"]}