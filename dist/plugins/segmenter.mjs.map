{"version":3,"sources":["../../src/plugins/segmenter.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport { getSharedFileset, hashOptions, isMediaPipeSource, MediaPipeSource } from './mediapipe-common';\nimport type { ImageSegmenter, ImageSegmenterResult, MPMask } from '@mediapipe/tasks-vision';\n\nexport interface SegmenterPluginOptions {\n\tmodelPath?: string;\n\toutputCategoryMask?: boolean;\n}\n\nconst dummyTexture = { data: new Uint8Array(4), width: 1, height: 1 };\n\nconst DEFAULT_SEGMENTER_OPTIONS: Required<SegmenterPluginOptions> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/image_segmenter/hair_segmenter/float32/latest/hair_segmenter.tflite',\n\toutputCategoryMask: false,\n};\n\nfunction createMaskShaderSource(numMasks: number): string {\n\tconst uniforms = Array.from({ length: numMasks }, (_, i) => `uniform sampler2D u_confidenceMask${i};`).join('\\n');\n\n\tconst sampleByIndex = Array.from(\n\t\t{ length: numMasks },\n\t\t(_, i) => `\\t\\t${i > 0 ? 'else ' : ''}if (i == ${i}) c = texelFetch(u_confidenceMask${i}, texCoord, 0).r;`\n\t).join('\\n');\n\n\treturn `#version 300 es\nprecision mediump float;\nin vec2 v_uv;\nout vec4 outColor;\n${uniforms}\n\nvoid main() {\n\tivec2 texCoord = ivec2(v_uv * vec2(textureSize(u_confidenceMask0, 0)));\n\tfloat maxConfidence = 0.0;\n\tint maxIndex = 0;\n\n\tfor (int i = 0; i < ${numMasks}; ++i) {\n\t\tfloat c = 0.0;\n${sampleByIndex}\n\t\tif (c > maxConfidence) {\n\t\t\tmaxConfidence = c;\n\t\t\tmaxIndex = i;\n\t\t}\n\t}\n\n\t// Normalize index: 0 = background, 1/(n-1) to 1 for foreground categories.\n\tfloat normalizedIndex = float(maxIndex) / float(max(1, ${numMasks - 1}));\n\toutColor = vec4(normalizedIndex, maxConfidence, 0.0, 1.0);\n}`;\n}\n\ninterface SharedDetector {\n\tsegmenter: ImageSegmenter;\n\tcanvas: OffscreenCanvas;\n\tsubscribers: Map<() => void, boolean>;\n\tstate: {\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: ImageSegmenterResult | null;\n\t\tpending: Promise<void>;\n\t};\n\tlabels: string[];\n\tnumCategories: number;\n\tmask: {\n\t\tshader: ShaderPad;\n\t};\n}\nconst sharedDetectors = new Map<string, SharedDetector>();\n\nfunction updateMaskCanvas(detector: SharedDetector, confidenceMasks: MPMask[]) {\n\tconst {\n\t\tmask: { shader },\n\t} = detector;\n\n\tconst textures: Record<string, WebGLTexture> = {};\n\tfor (let i = 0; i < confidenceMasks.length; ++i) {\n\t\ttextures[`u_confidenceMask${i}`] = confidenceMasks[i].getAsWebGLTexture();\n\t}\n\tshader.updateTextures(textures);\n\tshader.draw();\n\tconfidenceMasks.forEach(m => m.close());\n}\n\nfunction segmenter(config: { textureName: string; options?: SegmenterPluginOptions }) {\n\tconst { textureName, options: configOptions = {} } = config;\n\tconst options = { ...DEFAULT_SEGMENTER_OPTIONS, ...configOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, gl, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst sharedCanvas = existingDetector?.canvas ?? new OffscreenCanvas(1, 1);\n\t\tlet detector: SharedDetector | null = null;\n\n\t\tfunction onResult() {\n\t\t\tif (!detector) return;\n\t\t\tshaderPad.updateTextures({ u_segmentMask: detector.canvas });\n\t\t\temitHook('segmenter:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { ImageSegmenter }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\t// Single shared canvas for MediaPipe and maskShader (same WebGL context required\n\t\t\t\t// because maskShader uses textures from MediaPipe via getAsWebGLTexture).\n\t\t\t\tconst imageSegmenter = await ImageSegmenter.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: sharedCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\toutputCategoryMask: options.outputCategoryMask,\n\t\t\t\t\toutputConfidenceMasks: true,\n\t\t\t\t});\n\n\t\t\t\tconst labels = imageSegmenter.getLabels();\n\t\t\t\tconst numCategories = labels.length || 1;\n\n\t\t\t\tconst maskShader = new ShaderPad(createMaskShaderSource(numCategories), { canvas: sharedCanvas });\n\t\t\t\tfor (let i = 0; i < numCategories; ++i) {\n\t\t\t\t\tmaskShader.initializeTexture(`u_confidenceMask${i}`, dummyTexture);\n\t\t\t\t}\n\n\t\t\t\tdetector = {\n\t\t\t\t\tsegmenter: imageSegmenter,\n\t\t\t\t\tcanvas: sharedCanvas,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tstate: {\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t},\n\t\t\t\t\tlabels,\n\t\t\t\t\tnumCategories,\n\t\t\t\t\tmask: {\n\t\t\t\t\t\tshader: maskShader,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector!.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_numCategories', 'int', 1);\n\t\t\tshaderPad.initializeTexture('u_segmentMask', sharedCanvas, {\n\t\t\t\tpreserveY: true,\n\t\t\t\tminFilter: gl.NEAREST,\n\t\t\t\tmagFilter: gl.NEAREST,\n\t\t\t});\n\t\t\tinitPromise.then(() => {\n\t\t\t\tshaderPad.updateUniforms({ u_numCategories: detector!.numCategories });\n\t\t\t\temitHook('segmenter:ready');\n\t\t\t});\n\t\t});\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) detectSegments(source);\n\t\t});\n\n\t\tshaderPad.on('updateTextures', (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (isMediaPipeSource(source)) detectSegments(source);\n\t\t});\n\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectSegments(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tconst callOrder = ++nDetectionCalls;\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (callOrder !== nDetectionCalls || !detector) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.segmenter.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: ImageSegmenterResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.segmenter.segmentForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.segmenter.segment(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result?.confidenceMasks && result.confidenceMasks.length > 0) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tupdateMaskCanvas(detector, result.confidenceMasks);\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result && !detector.subscribers.get(onResult)) {\n\t\t\t\t\tonResult();\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.segmenter.close();\n\t\t\t\t\tdetector.mask.shader?.destroy();\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tinjectGLSL(`\nuniform sampler2D u_segmentMask;\nuniform int u_numCategories;\n\nvec2 segmentAt(vec2 pos) {\n\tvec4 mask = texture(u_segmentMask, pos);\n\treturn vec2(mask.r, mask.g);\n}`);\n\t};\n}\n\nexport default segmenter;\n"],"mappings":"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","names":["dummyTexture","DEFAULT_SEGMENTER_OPTIONS","createMaskShaderSource","numMasks","uniforms","_","i","sampleByIndex","sharedDetectors","updateMaskCanvas","detector","confidenceMasks","shader","textures","m","segmenter","config","textureName","configOptions","options","optionsKey","hashOptions","shaderPad","context","injectGLSL","gl","emitHook","sharedCanvas","onResult","initializeDetector","mediaPipe","ImageSegmenter","getSharedFileset","imageSegmenter","labels","numCategories","maskShader","index_default","initPromise","name","source","isMediaPipeSource","detectSegments","updates","nDetectionCalls","now","callOrder","requiredMode","shouldDetect","result","cb","segmenter_default"]}