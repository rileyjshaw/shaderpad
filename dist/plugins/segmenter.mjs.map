{"version":3,"sources":["../../src/plugins/segmenter.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '../index';\nimport type { ImageSegmenter, ImageSegmenterResult, MPMask } from '@mediapipe/tasks-vision';\n\nexport interface SegmenterPluginOptions {\n\tmodelPath?: string;\n\toutputCategoryMask?: boolean;\n}\n\nconst dummyTexture = { data: new Uint8Array(4), width: 1, height: 1 };\nfunction createMaskShaderSource(numMasks: number): string {\n\tconst uniforms = Array.from({ length: numMasks }, (_, i) => `uniform sampler2D u_confidenceMask${i};`).join('\\n');\n\n\t// GLSL doesn't allow dynamic indexing of samplers, so we need a switch-like construct.\n\tconst sampleByIndex = Array.from(\n\t\t{ length: numMasks },\n\t\t(_, i) => `\\t\\t${i > 0 ? 'else ' : ''}if (i == ${i}) c = texelFetch(u_confidenceMask${i}, texCoord, 0).r;`\n\t).join('\\n');\n\n\treturn `#version 300 es\nprecision mediump float;\nin vec2 v_uv;\nout vec4 outColor;\n${uniforms}\n\nvoid main() {\n\tivec2 texCoord = ivec2(v_uv * vec2(textureSize(u_confidenceMask0, 0)));\n\tfloat maxConfidence = 0.0;\n\tint maxIndex = 0;\n\n\tfor (int i = 0; i < ${numMasks}; ++i) {\n\t\tfloat c = 0.0;\n${sampleByIndex}\n\t\tif (c > maxConfidence) {\n\t\t\tmaxConfidence = c;\n\t\t\tmaxIndex = i;\n\t\t}\n\t}\n\n\t// Normalize index: 0 = background, 1/(n-1) to 1 for foreground categories.\n\tfloat normalizedIndex = float(maxIndex) / float(max(1, ${numMasks - 1}));\n\toutColor = vec4(normalizedIndex, maxConfidence, 0.0, 1.0);\n}`;\n}\n\nfunction segmenter(config: { textureName: string; options?: SegmenterPluginOptions }) {\n\tconst { textureName, options } = config;\n\tconst defaultModelPath =\n\t\t'https://storage.googleapis.com/mediapipe-models/image_segmenter/hair_segmenter/float32/latest/hair_segmenter.tflite';\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, gl, emitHook } = context;\n\n\t\tlet imageSegmenter: ImageSegmenter | null = null;\n\t\tlet vision: any = null;\n\t\tlet lastVideoTime = -1;\n\t\tlet runningMode: 'IMAGE' | 'VIDEO' = 'VIDEO';\n\t\tconst textureSources = new Map<string, TextureSource>();\n\t\tlet numCategories = 1;\n\n\t\t// Shared canvas for MediaPipe and maskShader (same WebGL context).\n\t\tconst sharedCanvas = new OffscreenCanvas(1, 1);\n\t\tlet maskShader: ShaderPad | null = null;\n\t\tasync function initializeMediaPipe() {\n\t\t\ttry {\n\t\t\t\tconst { FilesetResolver, ImageSegmenter } = await import('@mediapipe/tasks-vision');\n\t\t\t\tvision = await FilesetResolver.forVisionTasks(\n\t\t\t\t\t'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'\n\t\t\t\t);\n\t\t\t\timageSegmenter = await ImageSegmenter.createFromOptions(vision, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options?.modelPath || defaultModelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: sharedCanvas,\n\t\t\t\t\trunningMode: runningMode,\n\t\t\t\t\toutputCategoryMask: options?.outputCategoryMask ?? false, // Better for perf, and category can be inferred from confidence mask index.\n\t\t\t\t\toutputConfidenceMasks: true,\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Segmenter Plugin] Failed to initialize MediaPipe:', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t\tconst mediaPipeInitPromise = initializeMediaPipe();\n\n\t\tshaderPad.on('init', async () => {\n\t\t\tshaderPad.initializeUniform('u_numCategories', 'int', numCategories);\n\t\t\tshaderPad.initializeTexture('u_segmentMask', sharedCanvas, {\n\t\t\t\tpreserveY: true,\n\t\t\t\tminFilter: gl.NEAREST,\n\t\t\t\tmagFilter: gl.NEAREST,\n\t\t\t});\n\t\t\tawait mediaPipeInitPromise;\n\t\t\tconst labels = imageSegmenter!.getLabels();\n\t\t\tif (labels.length) numCategories = labels.length;\n\t\t\tmaskShader = new ShaderPad(createMaskShaderSource(numCategories), { canvas: sharedCanvas });\n\t\t\tfor (let i = 0; i < numCategories; ++i) {\n\t\t\t\tmaskShader.initializeTexture(`u_confidenceMask${i}`, dummyTexture);\n\t\t\t}\n\t\t\tshaderPad.updateUniforms({ u_numCategories: numCategories });\n\t\t\temitHook('segmenter:ready');\n\t\t});\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName) detectSegments(source);\n\t\t});\n\n\t\tshaderPad.on('updateTextures', (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (source) detectSegments(source);\n\t\t});\n\n\t\tfunction updateMaskTexture(confidenceMasks: MPMask[]) {\n\t\t\tif (!maskShader) return;\n\n\t\t\tconst textures: Record<string, WebGLTexture> = {};\n\t\t\tfor (let i = 0; i < confidenceMasks.length; ++i) {\n\t\t\t\ttextures[`u_confidenceMask${i}`] = confidenceMasks[i].getAsWebGLTexture();\n\t\t\t}\n\t\t\tmaskShader.updateTextures(textures);\n\t\t\tmaskShader.draw();\n\t\t\tshaderPad.updateTextures({ u_segmentMask: sharedCanvas });\n\t\t\tconfidenceMasks.forEach(mask => mask.close());\n\t\t}\n\n\t\tfunction processSegments(result: ImageSegmenterResult) {\n\t\t\tconst { confidenceMasks } = result;\n\t\t\tif (!confidenceMasks || confidenceMasks.length === 0) return;\n\t\t\tupdateMaskTexture(confidenceMasks);\n\t\t\temitHook('segmenter:result', result);\n\t\t}\n\n\t\t// `detectSegments` may be called multiple times before MediaPipe is\n\t\t// initialized. This ensures we only process the last call.\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectSegments(source: TextureSource) {\n\t\t\tconst callOrder = ++nDetectionCalls;\n\t\t\tawait mediaPipeInitPromise;\n\t\t\tif (callOrder !== nDetectionCalls || !imageSegmenter) return;\n\n\t\t\tconst previousSource = textureSources.get(textureName);\n\t\t\tif (previousSource !== source) lastVideoTime = -1;\n\t\t\ttextureSources.set(textureName, source);\n\n\t\t\ttry {\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (runningMode !== requiredMode) {\n\t\t\t\t\trunningMode = requiredMode;\n\t\t\t\t\tawait imageSegmenter.setOptions({ runningMode });\n\t\t\t\t}\n\n\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (source.currentTime !== lastVideoTime) {\n\t\t\t\t\t\tlastVideoTime = source.currentTime;\n\t\t\t\t\t\t// TODO: I think segmentForVideo runs its own animation loop maybe? args are (source, startTime, callbackForVideo).\n\t\t\t\t\t\tconst result = imageSegmenter.segmentForVideo(source, performance.now());\n\t\t\t\t\t\tprocessSegments(result);\n\t\t\t\t\t}\n\t\t\t\t} else if (source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {\n\t\t\t\t\tif (source.width === 0 || source.height === 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst result = imageSegmenter.segment(source);\n\t\t\t\t\tprocessSegments(result);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Segmenter Plugin] Segmentation error:', error);\n\t\t\t}\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tif (imageSegmenter) {\n\t\t\t\timageSegmenter.close();\n\t\t\t\timageSegmenter = null;\n\t\t\t}\n\t\t\tif (maskShader) {\n\t\t\t\tmaskShader.destroy();\n\t\t\t\tmaskShader = null;\n\t\t\t}\n\t\t\tvision = null;\n\t\t\ttextureSources.clear();\n\t\t});\n\n\t\tinjectGLSL(`\nuniform sampler2D u_segmentMask;\nuniform int u_numCategories;\n\nvec2 segmentAt(vec2 pos) {\n\tvec4 mask = texture(u_segmentMask, pos);\n\treturn vec2(mask.r, mask.g);\n}`);\n\t};\n}\n\nexport default segmenter;\n"],"mappings":"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","names":["dummyTexture","createMaskShaderSource","numMasks","uniforms","_","i","sampleByIndex","segmenter","config","textureName","options","defaultModelPath","shaderPad","context","injectGLSL","gl","emitHook","imageSegmenter","vision","lastVideoTime","runningMode","textureSources","numCategories","sharedCanvas","maskShader","initializeMediaPipe","FilesetResolver","ImageSegmenter","error","mediaPipeInitPromise","labels","index_default","name","source","detectSegments","updates","updateMaskTexture","confidenceMasks","textures","mask","processSegments","result","nDetectionCalls","callOrder","requiredMode","segmenter_default"]}