var p=33;function S(x){let{textureName:C,options:m}=x,w="https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task";return function(a,L){let{injectGLSL:_}=L,r=null,f=null,h=-1,P=new Map,u=m?.maxPoses??1,y=512,T=512,t=document.createElement("canvas");t.width=y,t.height=T;let s=t.getContext("2d");s.globalCompositeOperation="lighten";let g=[];async function M(){try{let{FilesetResolver:o,PoseLandmarker:i}=await import("@mediapipe/tasks-vision");f=await o.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"),g.push(...i.POSE_CONNECTIONS),r=await i.createFromOptions(f,{baseOptions:{modelAssetPath:m?.modelPath||w},runningMode:"VIDEO",numPoses:m?.maxPoses??1,minPoseDetectionConfidence:m?.minPoseDetectionConfidence??.5,minPosePresenceConfidence:m?.minPosePresenceConfidence??.5,minTrackingConfidence:m?.minTrackingConfidence??.5,outputSegmentationMasks:m?.outputSegmentationMasks??!1})}catch(o){throw console.error("[Pose Plugin] Failed to initialize Pose Landmarker:",o),o}}async function b(o,i){if(!r){console.warn("[Pose Plugin] Cannot update mask: poseLandmarker missing");return}try{if(s.clearRect(0,0,t.width,t.height),i&&i.length>0&&i.forEach(e=>{if(e.width!==t.width||e.height!==t.height){let n=document.createElement("canvas");n.width=e.width,n.height=e.height,n.getContext("2d").putImageData(e,0,0),s.drawImage(n,0,0,t.width,t.height)}else s.putImageData(e,0,0)}),g.length){let e=Math.max(2,t.width/256);s.lineWidth=e,s.lineCap="round",s.strokeStyle="#00f",o.forEach(n=>{g.forEach(({start:c,end:v})=>{let l=n[c],d=n[v];!l||!d||(l.visibility??1)<.3||(d.visibility??1)<.3||(s.beginPath(),s.moveTo(l.x*t.width,l.y*t.height),s.lineTo(d.x*t.width,d.y*t.height),s.stroke())})})}a.updateTextures({u_poseMask:t})}catch(e){console.error("[Pose Plugin] Failed to generate mask texture:",e)}}function k(o){if(!o.landmarks)return;b(o.landmarks,o.segmentationMasks).catch(n=>{console.warn("[Pose Plugin] Mask texture update error:",n)});let i=o.landmarks.length,e={u_nPoses:i};i&&(e.u_poseLandmarks=o.landmarks.flatMap(n=>n.map(c=>[c.x,1-c.y]))),a.updateUniforms(e)}a.registerHook("init",async()=>{a.initializeTexture("u_poseMask",t),a.initializeUniform("u_maxPoses","int",u),a.initializeUniform("u_nPoses","int",0);let o=Array.from({length:u*p},()=>[.5,.5]);a.initializeUniform("u_poseLandmarks","float",o,{arrayLength:u*p}),await M()}),a.registerHook("updateTextures",o=>{Object.entries(o).forEach(([i,e])=>{if(i===C&&(P.set(i,e),!!r))try{if(e instanceof HTMLVideoElement){if(e.currentTime!==h){h=e.currentTime;let n=performance.now(),c=r.detectForVideo(e,n);k(c)}}else if(e instanceof HTMLImageElement){let n=r.detect(e);k(n)}}catch(n){console.error("[Pose Plugin] Pose detection error:",n)}})}),a.registerHook("destroy",()=>{r&&(r.close(),r=null),f=null,P.clear(),t.remove()}),_(`
uniform int u_maxPoses;
uniform int u_nPoses;
uniform vec2 u_poseLandmarks[${u*p}];
uniform sampler2D u_poseMask;
vec2 poseLandmark(int poseIndex, int landmarkIndex) {
	return u_poseLandmarks[poseIndex * ${p} + landmarkIndex];
}
float getBody(vec2 pos) { return texture(u_poseMask, pos).g; }
float getSkeleton(vec2 pos) { return texture(u_poseMask, pos).b; }`)}}export{S as pose};
//# sourceMappingURL=pose.mjs.map