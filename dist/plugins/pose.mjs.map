{"version":3,"sources":["../../src/plugins/pose.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tcalculateBoundingBoxCenter,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { PoseLandmarker, PoseLandmarkerResult, NormalizedLandmark, MPMask } from '@mediapipe/tasks-vision';\n\nexport interface PosePluginOptions {\n\tmodelPath?: string;\n\tmaxPoses?: number;\n\tminPoseDetectionConfidence?: number;\n\tminPosePresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n}\n\nconst STANDARD_LANDMARK_COUNT = 33; // See https://ai.google.dev/edge/mediapipe/solutions/vision/pose_landmarker#pose_landmarker_model.\nconst CUSTOM_LANDMARK_COUNT = 6;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst LANDMARK_INDICES = {\n\t// Standard landmarks.\n\tLEFT_EYE: 2,\n\tRIGHT_EYE: 5,\n\tLEFT_SHOULDER: 11,\n\tRIGHT_SHOULDER: 12,\n\tLEFT_ELBOW: 13,\n\tRIGHT_ELBOW: 14,\n\tLEFT_HIP: 23,\n\tRIGHT_HIP: 24,\n\tLEFT_KNEE: 25,\n\tRIGHT_KNEE: 26,\n\tLEFT_WRIST: 15,\n\tRIGHT_WRIST: 16,\n\tLEFT_PINKY: 17,\n\tRIGHT_PINKY: 18,\n\tLEFT_INDEX: 19,\n\tRIGHT_INDEX: 20,\n\tLEFT_THUMB: 21,\n\tRIGHT_THUMB: 22,\n\tLEFT_ANKLE: 27,\n\tRIGHT_ANKLE: 28,\n\tLEFT_HEEL: 29,\n\tRIGHT_HEEL: 30,\n\tLEFT_FOOT_INDEX: 31,\n\tRIGHT_FOOT_INDEX: 32,\n\t// Custom landmarks.\n\tBODY_CENTER: STANDARD_LANDMARK_COUNT,\n\tLEFT_HAND_CENTER: STANDARD_LANDMARK_COUNT + 1,\n\tRIGHT_HAND_CENTER: STANDARD_LANDMARK_COUNT + 2,\n\tLEFT_FOOT_CENTER: STANDARD_LANDMARK_COUNT + 3,\n\tRIGHT_FOOT_CENTER: STANDARD_LANDMARK_COUNT + 4,\n\tTORSO_CENTER: STANDARD_LANDMARK_COUNT + 5,\n};\nconst ALL_STANDARD_INDICES = Array.from({ length: STANDARD_LANDMARK_COUNT }, (_, i) => i);\nconst LEFT_HAND_INDICES = [\n\tLANDMARK_INDICES.LEFT_WRIST,\n\tLANDMARK_INDICES.LEFT_PINKY,\n\tLANDMARK_INDICES.LEFT_THUMB,\n\tLANDMARK_INDICES.LEFT_INDEX,\n];\nconst RIGHT_HAND_INDICES = [\n\tLANDMARK_INDICES.RIGHT_WRIST,\n\tLANDMARK_INDICES.RIGHT_PINKY,\n\tLANDMARK_INDICES.RIGHT_THUMB,\n\tLANDMARK_INDICES.RIGHT_INDEX,\n];\nconst LEFT_FOOT_INDICES = [LANDMARK_INDICES.LEFT_ANKLE, LANDMARK_INDICES.LEFT_HEEL, LANDMARK_INDICES.LEFT_FOOT_INDEX];\nconst RIGHT_FOOT_INDICES = [\n\tLANDMARK_INDICES.RIGHT_ANKLE,\n\tLANDMARK_INDICES.RIGHT_HEEL,\n\tLANDMARK_INDICES.RIGHT_FOOT_INDEX,\n];\nconst TORSO_INDICES = [\n\tLANDMARK_INDICES.LEFT_SHOULDER,\n\tLANDMARK_INDICES.RIGHT_SHOULDER,\n\tLANDMARK_INDICES.LEFT_HIP,\n\tLANDMARK_INDICES.RIGHT_HIP,\n];\n\nconst LANDMARKS_TEXTURE_WIDTH = 512;\nconst dummyTexture = { data: new Uint8Array(4), width: 1, height: 1 };\n\nconst DEFAULT_POSE_OPTIONS: Required<PosePluginOptions> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',\n\tmaxPoses: 1,\n\tminPoseDetectionConfidence: 0.5,\n\tminPosePresenceConfidence: 0.5,\n\tminTrackingConfidence: 0.5,\n};\n\ninterface Detector {\n\tlandmarker: PoseLandmarker;\n\tcanvas: OffscreenCanvas;\n\tsubscribers: Map<() => void, boolean>;\n\tmaxPoses: number;\n\tstate: {\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: PoseLandmarkerResult | null;\n\t\tpending: Promise<void>;\n\t\tnPoses: number;\n\t};\n\tlandmarks: {\n\t\tdata: Float32Array;\n\t\ttextureHeight: number;\n\t};\n\tmask: {\n\t\tshader: ShaderPad;\n\t};\n}\nconst sharedDetectors = new Map<string, Detector>();\n\nfunction updateLandmarksData(detector: Detector, poses: NormalizedLandmark[][]) {\n\tconst data = detector.landmarks.data;\n\tconst nPoses = poses.length;\n\n\tfor (let poseIdx = 0; poseIdx < nPoses; ++poseIdx) {\n\t\tconst landmarks = poses[poseIdx];\n\t\tfor (let lmIdx = 0; lmIdx < STANDARD_LANDMARK_COUNT; ++lmIdx) {\n\t\t\tconst landmark = landmarks[lmIdx];\n\t\t\tconst dataIdx = (poseIdx * LANDMARK_COUNT + lmIdx) * 4;\n\t\t\tdata[dataIdx] = landmark.x;\n\t\t\tdata[dataIdx + 1] = 1 - landmark.y;\n\t\t\tdata[dataIdx + 2] = landmark.z ?? 0;\n\t\t\tdata[dataIdx + 3] = landmark.visibility ?? 1;\n\t\t}\n\n\t\tconst bodyCenter = calculateBoundingBoxCenter(data, poseIdx, ALL_STANDARD_INDICES, LANDMARK_COUNT);\n\t\tconst bodyCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.BODY_CENTER) * 4;\n\t\tdata[bodyCenterIdx] = bodyCenter[0];\n\t\tdata[bodyCenterIdx + 1] = bodyCenter[1];\n\t\tdata[bodyCenterIdx + 2] = bodyCenter[2];\n\t\tdata[bodyCenterIdx + 3] = bodyCenter[3];\n\n\t\tconst leftHandCenter = calculateBoundingBoxCenter(data, poseIdx, LEFT_HAND_INDICES, LANDMARK_COUNT);\n\t\tconst leftHandCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.LEFT_HAND_CENTER) * 4;\n\t\tdata[leftHandCenterIdx] = leftHandCenter[0];\n\t\tdata[leftHandCenterIdx + 1] = leftHandCenter[1];\n\t\tdata[leftHandCenterIdx + 2] = leftHandCenter[2];\n\t\tdata[leftHandCenterIdx + 3] = leftHandCenter[3];\n\n\t\tconst rightHandCenter = calculateBoundingBoxCenter(data, poseIdx, RIGHT_HAND_INDICES, LANDMARK_COUNT);\n\t\tconst rightHandCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.RIGHT_HAND_CENTER) * 4;\n\t\tdata[rightHandCenterIdx] = rightHandCenter[0];\n\t\tdata[rightHandCenterIdx + 1] = rightHandCenter[1];\n\t\tdata[rightHandCenterIdx + 2] = rightHandCenter[2];\n\t\tdata[rightHandCenterIdx + 3] = rightHandCenter[3];\n\n\t\tconst leftFootCenter = calculateBoundingBoxCenter(data, poseIdx, LEFT_FOOT_INDICES, LANDMARK_COUNT);\n\t\tconst leftFootCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.LEFT_FOOT_CENTER) * 4;\n\t\tdata[leftFootCenterIdx] = leftFootCenter[0];\n\t\tdata[leftFootCenterIdx + 1] = leftFootCenter[1];\n\t\tdata[leftFootCenterIdx + 2] = leftFootCenter[2];\n\t\tdata[leftFootCenterIdx + 3] = leftFootCenter[3];\n\n\t\tconst rightFootCenter = calculateBoundingBoxCenter(data, poseIdx, RIGHT_FOOT_INDICES, LANDMARK_COUNT);\n\t\tconst rightFootCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.RIGHT_FOOT_CENTER) * 4;\n\t\tdata[rightFootCenterIdx] = rightFootCenter[0];\n\t\tdata[rightFootCenterIdx + 1] = rightFootCenter[1];\n\t\tdata[rightFootCenterIdx + 2] = rightFootCenter[2];\n\t\tdata[rightFootCenterIdx + 3] = rightFootCenter[3];\n\n\t\tconst torsoCenter = calculateBoundingBoxCenter(data, poseIdx, TORSO_INDICES, LANDMARK_COUNT);\n\t\tconst torsoCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.TORSO_CENTER) * 4;\n\t\tdata[torsoCenterIdx] = torsoCenter[0];\n\t\tdata[torsoCenterIdx + 1] = torsoCenter[1];\n\t\tdata[torsoCenterIdx + 2] = torsoCenter[2];\n\t\tdata[torsoCenterIdx + 3] = torsoCenter[3];\n\t}\n\n\tdetector.state.nPoses = nPoses;\n}\n\nfunction updateMaskCanvas(detector: Detector, segmentationMasks?: MPMask[]) {\n\tif (!segmentationMasks || segmentationMasks.length === 0) return;\n\tconst {\n\t\tmask: { shader },\n\t\tmaxPoses,\n\t} = detector;\n\n\tfor (let i = 0; i < segmentationMasks.length; ++i) {\n\t\tconst segMask = segmentationMasks[i];\n\t\tshader.updateTextures({ u_mask: segMask.getAsWebGLTexture() });\n\t\tshader.updateUniforms({ u_poseIndex: (i + 1) / maxPoses });\n\t\tshader.draw({ skipClear: i > 0 });\n\t\tsegMask.close();\n\t}\n}\n\nfunction pose(config: { textureName: string; options?: PosePluginOptions }) {\n\tconst { textureName, options: configOptions = {} } = config;\n\tconst options = { ...DEFAULT_POSE_OPTIONS, ...configOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\tconst nLandmarksMax = options.maxPoses * LANDMARK_COUNT;\n\tconst textureHeight = Math.ceil(nLandmarksMax / LANDMARKS_TEXTURE_WIDTH);\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, gl, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst landmarksData =\n\t\t\texistingDetector?.landmarks.data ?? new Float32Array(LANDMARKS_TEXTURE_WIDTH * textureHeight * 4);\n\t\tconst sharedCanvas = existingDetector?.canvas ?? new OffscreenCanvas(1, 1);\n\t\tlet detector: Detector | null = null;\n\n\t\tfunction onResult() {\n\t\t\tif (!detector) return;\n\t\t\tconst { nPoses } = detector.state;\n\t\t\tconst nLandmarks = nPoses * LANDMARK_COUNT;\n\t\t\tconst rowsToUpdate = Math.ceil(nLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures({\n\t\t\t\tu_poseLandmarksTex: {\n\t\t\t\t\tdata: detector.landmarks.data,\n\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t\tisPartial: true,\n\t\t\t\t},\n\t\t\t\tu_poseMask: detector.canvas,\n\t\t\t});\n\t\t\tshaderPad.updateUniforms({ u_nPoses: nPoses });\n\t\t\temitHook('pose:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { PoseLandmarker }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\tconst poseLandmarker = await PoseLandmarker.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: sharedCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\tnumPoses: options.maxPoses,\n\t\t\t\t\tminPoseDetectionConfidence: options.minPoseDetectionConfidence,\n\t\t\t\t\tminPosePresenceConfidence: options.minPosePresenceConfidence,\n\t\t\t\t\tminTrackingConfidence: options.minTrackingConfidence,\n\t\t\t\t\toutputSegmentationMasks: true,\n\t\t\t\t});\n\n\t\t\t\tconst maskShader = new ShaderPad(\n\t\t\t\t\t`#version 300 es\n\tprecision mediump float;\n\tin vec2 v_uv;\n\tout vec4 outColor;\n\tuniform sampler2D u_mask;\n\tuniform float u_poseIndex;\n\tvoid main() {\n\t\tivec2 texCoord = ivec2(v_uv * vec2(textureSize(u_mask, 0)));\n\t\tfloat confidence = texelFetch(u_mask, texCoord, 0).r;\n\t\tif (confidence < 0.01) discard;\n\t\toutColor = vec4(1.0, confidence, u_poseIndex, 1.0);\n\t}`,\n\t\t\t\t\t{ canvas: sharedCanvas }\n\t\t\t\t);\n\t\t\t\tmaskShader.initializeTexture('u_mask', dummyTexture);\n\t\t\t\tmaskShader.initializeUniform('u_poseIndex', 'float', 0);\n\n\t\t\t\tdetector = {\n\t\t\t\t\tlandmarker: poseLandmarker,\n\t\t\t\t\tcanvas: sharedCanvas,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tmaxPoses: options.maxPoses,\n\t\t\t\t\tstate: {\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t\tnPoses: 0,\n\t\t\t\t\t},\n\t\t\t\t\tlandmarks: {\n\t\t\t\t\t\tdata: landmarksData,\n\t\t\t\t\t\ttextureHeight,\n\t\t\t\t\t},\n\t\t\t\t\tmask: {\n\t\t\t\t\t\tshader: maskShader,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_maxPoses', 'int', options.maxPoses);\n\t\t\tshaderPad.initializeUniform('u_nPoses', 'int', 0);\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_poseLandmarksTex',\n\t\t\t\t{ data: landmarksData, width: LANDMARKS_TEXTURE_WIDTH, height: textureHeight },\n\t\t\t\t{ internalFormat: gl.RGBA32F, type: gl.FLOAT, minFilter: gl.NEAREST, magFilter: gl.NEAREST }\n\t\t\t);\n\t\t\tshaderPad.initializeTexture('u_poseMask', sharedCanvas, {\n\t\t\t\tpreserveY: true,\n\t\t\t\tminFilter: gl.NEAREST,\n\t\t\t\tmagFilter: gl.NEAREST,\n\t\t\t});\n\t\t\tinitPromise.then(() => emitHook('pose:ready'));\n\t\t});\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) detectPoses(source);\n\t\t});\n\n\t\tshaderPad.on('updateTextures', (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (isMediaPipeSource(source)) detectPoses(source);\n\t\t});\n\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectPoses(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tconst callOrder = ++nDetectionCalls;\n\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (callOrder !== nDetectionCalls || !detector) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.landmarker.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: PoseLandmarkerResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.landmarker.detectForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.landmarker.detect(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tupdateLandmarksData(detector, result.landmarks);\n\t\t\t\t\t\tupdateMaskCanvas(detector, result.segmentationMasks);\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result && !detector.subscribers.get(onResult)) {\n\t\t\t\t\tonResult();\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.landmarker.close();\n\t\t\t\t\tdetector.mask.shader?.destroy();\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tinjectGLSL(`\nuniform int u_maxPoses;\nuniform int u_nPoses;\nuniform sampler2D u_poseLandmarksTex;\nuniform sampler2D u_poseMask;\n\n#define POSE_LANDMARK_LEFT_EYE ${LANDMARK_INDICES.LEFT_EYE}\n#define POSE_LANDMARK_RIGHT_EYE ${LANDMARK_INDICES.RIGHT_EYE}\n#define POSE_LANDMARK_LEFT_SHOULDER ${LANDMARK_INDICES.LEFT_SHOULDER}\n#define POSE_LANDMARK_RIGHT_SHOULDER ${LANDMARK_INDICES.RIGHT_SHOULDER}\n#define POSE_LANDMARK_LEFT_ELBOW ${LANDMARK_INDICES.LEFT_ELBOW}\n#define POSE_LANDMARK_RIGHT_ELBOW ${LANDMARK_INDICES.RIGHT_ELBOW}\n#define POSE_LANDMARK_LEFT_HIP ${LANDMARK_INDICES.LEFT_HIP}\n#define POSE_LANDMARK_RIGHT_HIP ${LANDMARK_INDICES.RIGHT_HIP}\n#define POSE_LANDMARK_LEFT_KNEE ${LANDMARK_INDICES.LEFT_KNEE}\n#define POSE_LANDMARK_RIGHT_KNEE ${LANDMARK_INDICES.RIGHT_KNEE}\n#define POSE_LANDMARK_BODY_CENTER ${LANDMARK_INDICES.BODY_CENTER}\n#define POSE_LANDMARK_LEFT_HAND_CENTER ${LANDMARK_INDICES.LEFT_HAND_CENTER}\n#define POSE_LANDMARK_RIGHT_HAND_CENTER ${LANDMARK_INDICES.RIGHT_HAND_CENTER}\n#define POSE_LANDMARK_LEFT_FOOT_CENTER ${LANDMARK_INDICES.LEFT_FOOT_CENTER}\n#define POSE_LANDMARK_RIGHT_FOOT_CENTER ${LANDMARK_INDICES.RIGHT_FOOT_CENTER}\n#define POSE_LANDMARK_TORSO_CENTER ${LANDMARK_INDICES.TORSO_CENTER}\n\nvec4 poseLandmark(int poseIndex, int landmarkIndex) {\n\tint i = poseIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};\n\treturn texelFetch(u_poseLandmarksTex, ivec2(x, y), 0);\n}\n\nvec2 poseAt(vec2 pos) {\n\tvec4 mask = texture(u_poseMask, pos);\n\tfloat poseIndex = floor(mask.b * float(u_maxPoses) + 0.5) - 1.0;\n\treturn vec2(mask.g, poseIndex);\n}\n\t\nfloat inPose(vec2 pos) {\n\tfloat pose = poseAt(pos).x;\n\treturn step(0.0, pose);\n}`);\n\t};\n}\n\nexport default pose;\n"],"mappings":"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","names":["STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","LANDMARK_INDICES","ALL_STANDARD_INDICES","_","i","LEFT_HAND_INDICES","RIGHT_HAND_INDICES","LEFT_FOOT_INDICES","RIGHT_FOOT_INDICES","TORSO_INDICES","LANDMARKS_TEXTURE_WIDTH","dummyTexture","DEFAULT_POSE_OPTIONS","sharedDetectors","updateLandmarksData","detector","poses","data","nPoses","poseIdx","landmarks","lmIdx","landmark","dataIdx","bodyCenter","calculateBoundingBoxCenter","bodyCenterIdx","leftHandCenter","leftHandCenterIdx","rightHandCenter","rightHandCenterIdx","leftFootCenter","leftFootCenterIdx","rightFootCenter","rightFootCenterIdx","torsoCenter","torsoCenterIdx","updateMaskCanvas","segmentationMasks","shader","maxPoses","segMask","pose","config","textureName","configOptions","options","optionsKey","hashOptions","nLandmarksMax","textureHeight","shaderPad","context","injectGLSL","gl","emitHook","existingDetector","landmarksData","sharedCanvas","onResult","nLandmarks","rowsToUpdate","initializeDetector","mediaPipe","PoseLandmarker","getSharedFileset","poseLandmarker","maskShader","index_default","initPromise","name","source","isMediaPipeSource","detectPoses","updates","nDetectionCalls","now","callOrder","requiredMode","shouldDetect","result","cb","pose_default"]}