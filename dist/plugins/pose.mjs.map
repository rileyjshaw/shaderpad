{"version":3,"sources":["../../src/plugins/pose.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tcalculateBoundingBoxCenter,\n\tgenerateGLSLFn,\n\tdummyTexture,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { PoseLandmarker, PoseLandmarkerResult, NormalizedLandmark, MPMask } from '@mediapipe/tasks-vision';\n\nexport interface PosePluginOptions {\n\tmodelPath?: string;\n\tmaxPoses?: number;\n\tminPoseDetectionConfidence?: number;\n\tminPosePresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\thistory?: number;\n}\n\nconst STANDARD_LANDMARK_COUNT = 33; // See https://ai.google.dev/edge/mediapipe/solutions/vision/pose_landmarker#pose_landmarker_model.\nconst CUSTOM_LANDMARK_COUNT = 6;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst LANDMARK_INDICES = {\n\t// Standard landmarks.\n\tLEFT_EYE: 2,\n\tRIGHT_EYE: 5,\n\tLEFT_SHOULDER: 11,\n\tRIGHT_SHOULDER: 12,\n\tLEFT_ELBOW: 13,\n\tRIGHT_ELBOW: 14,\n\tLEFT_HIP: 23,\n\tRIGHT_HIP: 24,\n\tLEFT_KNEE: 25,\n\tRIGHT_KNEE: 26,\n\tLEFT_WRIST: 15,\n\tRIGHT_WRIST: 16,\n\tLEFT_PINKY: 17,\n\tRIGHT_PINKY: 18,\n\tLEFT_INDEX: 19,\n\tRIGHT_INDEX: 20,\n\tLEFT_THUMB: 21,\n\tRIGHT_THUMB: 22,\n\tLEFT_ANKLE: 27,\n\tRIGHT_ANKLE: 28,\n\tLEFT_HEEL: 29,\n\tRIGHT_HEEL: 30,\n\tLEFT_FOOT_INDEX: 31,\n\tRIGHT_FOOT_INDEX: 32,\n\t// Custom landmarks.\n\tBODY_CENTER: STANDARD_LANDMARK_COUNT,\n\tLEFT_HAND_CENTER: STANDARD_LANDMARK_COUNT + 1,\n\tRIGHT_HAND_CENTER: STANDARD_LANDMARK_COUNT + 2,\n\tLEFT_FOOT_CENTER: STANDARD_LANDMARK_COUNT + 3,\n\tRIGHT_FOOT_CENTER: STANDARD_LANDMARK_COUNT + 4,\n\tTORSO_CENTER: STANDARD_LANDMARK_COUNT + 5,\n};\nconst ALL_STANDARD_INDICES = Array.from({ length: STANDARD_LANDMARK_COUNT }, (_, i) => i);\nconst LEFT_HAND_INDICES = [\n\tLANDMARK_INDICES.LEFT_WRIST,\n\tLANDMARK_INDICES.LEFT_PINKY,\n\tLANDMARK_INDICES.LEFT_THUMB,\n\tLANDMARK_INDICES.LEFT_INDEX,\n];\nconst RIGHT_HAND_INDICES = [\n\tLANDMARK_INDICES.RIGHT_WRIST,\n\tLANDMARK_INDICES.RIGHT_PINKY,\n\tLANDMARK_INDICES.RIGHT_THUMB,\n\tLANDMARK_INDICES.RIGHT_INDEX,\n];\nconst LEFT_FOOT_INDICES = [LANDMARK_INDICES.LEFT_ANKLE, LANDMARK_INDICES.LEFT_HEEL, LANDMARK_INDICES.LEFT_FOOT_INDEX];\nconst RIGHT_FOOT_INDICES = [\n\tLANDMARK_INDICES.RIGHT_ANKLE,\n\tLANDMARK_INDICES.RIGHT_HEEL,\n\tLANDMARK_INDICES.RIGHT_FOOT_INDEX,\n];\nconst TORSO_INDICES = [\n\tLANDMARK_INDICES.LEFT_SHOULDER,\n\tLANDMARK_INDICES.RIGHT_SHOULDER,\n\tLANDMARK_INDICES.LEFT_HIP,\n\tLANDMARK_INDICES.RIGHT_HIP,\n];\n\nconst LANDMARKS_TEXTURE_WIDTH = 512;\nconst N_LANDMARK_METADATA_SLOTS = 1;\n\nconst DEFAULT_POSE_OPTIONS: Required<Omit<PosePluginOptions, 'history'>> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',\n\tmaxPoses: 1,\n\tminPoseDetectionConfidence: 0.5,\n\tminPosePresenceConfidence: 0.5,\n\tminTrackingConfidence: 0.5,\n};\n\ninterface Detector {\n\tlandmarker: PoseLandmarker;\n\tcanvas: OffscreenCanvas;\n\tsubscribers: Map<() => void, boolean>;\n\tmaxPoses: number;\n\tstate: {\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: PoseLandmarkerResult | null;\n\t\tpending: Promise<void>;\n\t\tnPoses: number;\n\t};\n\tlandmarks: {\n\t\tdata: Float32Array;\n\t\ttextureHeight: number;\n\t};\n\tmask: {\n\t\tshader: ShaderPad;\n\t};\n}\nconst sharedDetectors = new Map<string, Detector>();\n\nfunction updateLandmarksData(detector: Detector, poses: NormalizedLandmark[][]) {\n\tconst data = detector.landmarks.data;\n\tconst nPoses = poses.length;\n\n\tdata[0] = nPoses;\n\n\tfor (let poseIdx = 0; poseIdx < nPoses; ++poseIdx) {\n\t\tconst landmarks = poses[poseIdx];\n\t\tfor (let lmIdx = 0; lmIdx < STANDARD_LANDMARK_COUNT; ++lmIdx) {\n\t\t\tconst landmark = landmarks[lmIdx];\n\t\t\tconst dataIdx = (N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + lmIdx) * 4;\n\t\t\tdata[dataIdx] = landmark.x;\n\t\t\tdata[dataIdx + 1] = 1 - landmark.y;\n\t\t\tdata[dataIdx + 2] = landmark.z ?? 0;\n\t\t\tdata[dataIdx + 3] = landmark.visibility ?? 1;\n\t\t}\n\n\t\tconst bodyCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tALL_STANDARD_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst bodyCenterIdx = (N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.BODY_CENTER) * 4;\n\t\tdata[bodyCenterIdx] = bodyCenter[0];\n\t\tdata[bodyCenterIdx + 1] = bodyCenter[1];\n\t\tdata[bodyCenterIdx + 2] = bodyCenter[2];\n\t\tdata[bodyCenterIdx + 3] = bodyCenter[3];\n\n\t\tconst leftHandCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tLEFT_HAND_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst leftHandCenterIdx =\n\t\t\t(N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.LEFT_HAND_CENTER) * 4;\n\t\tdata[leftHandCenterIdx] = leftHandCenter[0];\n\t\tdata[leftHandCenterIdx + 1] = leftHandCenter[1];\n\t\tdata[leftHandCenterIdx + 2] = leftHandCenter[2];\n\t\tdata[leftHandCenterIdx + 3] = leftHandCenter[3];\n\n\t\tconst rightHandCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tRIGHT_HAND_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst rightHandCenterIdx =\n\t\t\t(N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.RIGHT_HAND_CENTER) * 4;\n\t\tdata[rightHandCenterIdx] = rightHandCenter[0];\n\t\tdata[rightHandCenterIdx + 1] = rightHandCenter[1];\n\t\tdata[rightHandCenterIdx + 2] = rightHandCenter[2];\n\t\tdata[rightHandCenterIdx + 3] = rightHandCenter[3];\n\n\t\tconst leftFootCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tLEFT_FOOT_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst leftFootCenterIdx =\n\t\t\t(N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.LEFT_FOOT_CENTER) * 4;\n\t\tdata[leftFootCenterIdx] = leftFootCenter[0];\n\t\tdata[leftFootCenterIdx + 1] = leftFootCenter[1];\n\t\tdata[leftFootCenterIdx + 2] = leftFootCenter[2];\n\t\tdata[leftFootCenterIdx + 3] = leftFootCenter[3];\n\n\t\tconst rightFootCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tRIGHT_FOOT_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst rightFootCenterIdx =\n\t\t\t(N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.RIGHT_FOOT_CENTER) * 4;\n\t\tdata[rightFootCenterIdx] = rightFootCenter[0];\n\t\tdata[rightFootCenterIdx + 1] = rightFootCenter[1];\n\t\tdata[rightFootCenterIdx + 2] = rightFootCenter[2];\n\t\tdata[rightFootCenterIdx + 3] = rightFootCenter[3];\n\n\t\tconst torsoCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tTORSO_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst torsoCenterIdx =\n\t\t\t(N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.TORSO_CENTER) * 4;\n\t\tdata[torsoCenterIdx] = torsoCenter[0];\n\t\tdata[torsoCenterIdx + 1] = torsoCenter[1];\n\t\tdata[torsoCenterIdx + 2] = torsoCenter[2];\n\t\tdata[torsoCenterIdx + 3] = torsoCenter[3];\n\t}\n\n\tdetector.state.nPoses = nPoses;\n}\n\nfunction updateMaskCanvas(detector: Detector, segmentationMasks?: MPMask[]) {\n\tif (!segmentationMasks || segmentationMasks.length === 0) return;\n\tconst {\n\t\tmask: { shader },\n\t\tmaxPoses,\n\t} = detector;\n\n\tfor (let i = 0; i < segmentationMasks.length; ++i) {\n\t\tconst segMask = segmentationMasks[i];\n\t\tshader.updateTextures({ u_mask: segMask.getAsWebGLTexture() });\n\t\tshader.updateUniforms({ u_poseIndex: (i + 1) / maxPoses });\n\t\tshader.draw({ skipClear: i > 0 });\n\t\tsegMask.close();\n\t}\n}\n\nfunction pose(config: { textureName: string; options?: PosePluginOptions }) {\n\tconst { textureName, options: { history, ...mediapipeOptions } = {} } = config;\n\tconst options = { ...DEFAULT_POSE_OPTIONS, ...mediapipeOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\tconst nLandmarksMax = options.maxPoses * LANDMARK_COUNT + N_LANDMARK_METADATA_SLOTS;\n\tconst textureHeight = Math.ceil(nLandmarksMax / LANDMARKS_TEXTURE_WIDTH);\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst landmarksData =\n\t\t\texistingDetector?.landmarks.data ?? new Float32Array(LANDMARKS_TEXTURE_WIDTH * textureHeight * 4);\n\t\tconst sharedCanvas = existingDetector?.canvas ?? new OffscreenCanvas(1, 1);\n\t\tlet detector: Detector | null = null;\n\t\tlet skipHistoryWrite = false;\n\n\t\tfunction onResult() {\n\t\t\tif (!detector) return;\n\t\t\tconst { nPoses } = detector.state;\n\t\t\tconst nSlots = nPoses * LANDMARK_COUNT + N_LANDMARK_METADATA_SLOTS;\n\t\t\tconst rowsToUpdate = Math.ceil(nSlots / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures(\n\t\t\t\t{\n\t\t\t\t\tu_poseLandmarksTex: {\n\t\t\t\t\t\tdata: detector.landmarks.data,\n\t\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t\t\tisPartial: true,\n\t\t\t\t\t},\n\t\t\t\t\tu_poseMask: detector.canvas,\n\t\t\t\t},\n\t\t\t\t{ skipHistoryWrite }\n\t\t\t);\n\t\t\tshaderPad.updateUniforms({ u_nPoses: nPoses });\n\t\t\temitHook('pose:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { PoseLandmarker }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\tconst poseLandmarker = await PoseLandmarker.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: sharedCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\tnumPoses: options.maxPoses,\n\t\t\t\t\tminPoseDetectionConfidence: options.minPoseDetectionConfidence,\n\t\t\t\t\tminPosePresenceConfidence: options.minPosePresenceConfidence,\n\t\t\t\t\tminTrackingConfidence: options.minTrackingConfidence,\n\t\t\t\t\toutputSegmentationMasks: true,\n\t\t\t\t});\n\n\t\t\t\tconst maskShader = new ShaderPad(\n\t\t\t\t\t`#version 300 es\n\tprecision mediump float;\n\tin vec2 v_uv;\n\tout vec4 outColor;\n\tuniform sampler2D u_mask;\n\tuniform float u_poseIndex;\n\tvoid main() {\n\t\tivec2 texCoord = ivec2(v_uv * vec2(textureSize(u_mask, 0)));\n\t\tfloat confidence = texelFetch(u_mask, texCoord, 0).r;\n\t\tif (confidence < 0.01) discard;\n\t\toutColor = vec4(1.0, confidence, u_poseIndex, 1.0);\n\t}`,\n\t\t\t\t\t{ canvas: sharedCanvas }\n\t\t\t\t);\n\t\t\t\tmaskShader.initializeTexture('u_mask', dummyTexture);\n\t\t\t\tmaskShader.initializeUniform('u_poseIndex', 'float', 0);\n\n\t\t\t\tdetector = {\n\t\t\t\t\tlandmarker: poseLandmarker,\n\t\t\t\t\tcanvas: sharedCanvas,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tmaxPoses: options.maxPoses,\n\t\t\t\t\tstate: {\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t\tnPoses: 0,\n\t\t\t\t\t},\n\t\t\t\t\tlandmarks: {\n\t\t\t\t\t\tdata: landmarksData,\n\t\t\t\t\t\ttextureHeight,\n\t\t\t\t\t},\n\t\t\t\t\tmask: {\n\t\t\t\t\t\tshader: maskShader,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_maxPoses', 'int', options.maxPoses);\n\t\t\tshaderPad.initializeUniform('u_nPoses', 'int', 0);\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_poseLandmarksTex',\n\t\t\t\t{ data: landmarksData, width: LANDMARKS_TEXTURE_WIDTH, height: textureHeight },\n\t\t\t\t{ internalFormat: 'RGBA32F', type: 'FLOAT', minFilter: 'NEAREST', magFilter: 'NEAREST', history }\n\t\t\t);\n\t\t\tshaderPad.initializeTexture('u_poseMask', sharedCanvas, {\n\t\t\t\tpreserveY: true,\n\t\t\t\tminFilter: 'NEAREST',\n\t\t\t\tmagFilter: 'NEAREST',\n\t\t\t\thistory,\n\t\t\t});\n\t\t\tinitPromise.then(() => emitHook('pose:ready'));\n\t\t});\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) detectPoses(source);\n\t\t});\n\n\t\tshaderPad.on(\n\t\t\t'updateTextures',\n\t\t\t(updates: Record<string, TextureSource>, options?: { skipHistoryWrite?: boolean }) => {\n\t\t\t\tconst source = updates[textureName];\n\t\t\t\tif (isMediaPipeSource(source)) {\n\t\t\t\t\tskipHistoryWrite = options?.skipHistoryWrite ?? false;\n\t\t\t\t\tdetectPoses(source);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectPoses(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tconst callOrder = ++nDetectionCalls;\n\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (callOrder !== nDetectionCalls || !detector) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.landmarker.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: PoseLandmarkerResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.landmarker.detectForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.landmarker.detect(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tupdateLandmarksData(detector, result.landmarks);\n\t\t\t\t\t\tupdateMaskCanvas(detector, result.segmentationMasks);\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result && !detector.subscribers.get(onResult)) {\n\t\t\t\t\tonResult();\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.landmarker.close();\n\t\t\t\t\tdetector.mask.shader?.destroy();\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tconst { fn, historyParams } = generateGLSLFn(history);\n\t\tconst sampleMask = history\n\t\t\t? `int layer = (u_poseMaskFrameOffset - framesAgo + ${history}) % ${history};\n\tvec4 mask = texture(u_poseMask, vec3(pos, float(layer)));`\n\t\t\t: `vec4 mask = texture(u_poseMask, pos);`;\n\n\t\tinjectGLSL(`\nuniform int u_maxPoses;\nuniform int u_nPoses;\nuniform highp sampler2D${history ? 'Array' : ''} u_poseLandmarksTex;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_poseLandmarksTexFrameOffset;`\n\t\t\t\t: ''\n\t\t}\nuniform sampler2D${history ? 'Array' : ''} u_poseMask;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_poseMaskFrameOffset;`\n\t\t\t\t: ''\n\t\t}\n\n#define POSE_LANDMARK_LEFT_EYE ${LANDMARK_INDICES.LEFT_EYE}\n#define POSE_LANDMARK_RIGHT_EYE ${LANDMARK_INDICES.RIGHT_EYE}\n#define POSE_LANDMARK_LEFT_SHOULDER ${LANDMARK_INDICES.LEFT_SHOULDER}\n#define POSE_LANDMARK_RIGHT_SHOULDER ${LANDMARK_INDICES.RIGHT_SHOULDER}\n#define POSE_LANDMARK_LEFT_ELBOW ${LANDMARK_INDICES.LEFT_ELBOW}\n#define POSE_LANDMARK_RIGHT_ELBOW ${LANDMARK_INDICES.RIGHT_ELBOW}\n#define POSE_LANDMARK_LEFT_HIP ${LANDMARK_INDICES.LEFT_HIP}\n#define POSE_LANDMARK_RIGHT_HIP ${LANDMARK_INDICES.RIGHT_HIP}\n#define POSE_LANDMARK_LEFT_KNEE ${LANDMARK_INDICES.LEFT_KNEE}\n#define POSE_LANDMARK_RIGHT_KNEE ${LANDMARK_INDICES.RIGHT_KNEE}\n#define POSE_LANDMARK_BODY_CENTER ${LANDMARK_INDICES.BODY_CENTER}\n#define POSE_LANDMARK_LEFT_HAND_CENTER ${LANDMARK_INDICES.LEFT_HAND_CENTER}\n#define POSE_LANDMARK_RIGHT_HAND_CENTER ${LANDMARK_INDICES.RIGHT_HAND_CENTER}\n#define POSE_LANDMARK_LEFT_FOOT_CENTER ${LANDMARK_INDICES.LEFT_FOOT_CENTER}\n#define POSE_LANDMARK_RIGHT_FOOT_CENTER ${LANDMARK_INDICES.RIGHT_FOOT_CENTER}\n#define POSE_LANDMARK_TORSO_CENTER ${LANDMARK_INDICES.TORSO_CENTER}\n\n${fn(\n\t'int',\n\t'nPosesAt',\n\t'',\n\thistory\n\t\t? `\n\tint layer = (u_poseLandmarksTexFrameOffset - framesAgo + ${history}) % ${history};\n\treturn int(texelFetch(u_poseLandmarksTex, ivec3(0, 0, layer), 0).r + 0.5);`\n\t\t: `\n\treturn int(texelFetch(u_poseLandmarksTex, ivec2(0, 0), 0).r + 0.5);`\n)}\n${fn(\n\t'vec4',\n\t'poseLandmark',\n\t'int poseIndex, int landmarkIndex',\n\t`int i = ${N_LANDMARK_METADATA_SLOTS} + poseIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};${\n\t\thistory\n\t\t\t? `\n\tint layer = (u_poseLandmarksTexFrameOffset - framesAgo + ${history}) % ${history};\n\treturn texelFetch(u_poseLandmarksTex, ivec3(x, y, layer), 0);`\n\t\t\t: `\n\treturn texelFetch(u_poseLandmarksTex, ivec2(x, y), 0);`\n\t}`\n)}\n${fn(\n\t'vec2',\n\t'poseAt',\n\t'vec2 pos',\n\t`${sampleMask}\n\tfloat poseIndex = floor(mask.b * float(u_maxPoses) + 0.5) - 1.0;\n\treturn vec2(mask.g, poseIndex);`\n)}\n${fn('float', 'inPose', 'vec2 pos', `return step(0.0, poseAt(pos${historyParams}).x);`)}`);\n\t};\n}\n\nexport default pose;\n"],"mappings":"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","names":["STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","LANDMARK_INDICES","ALL_STANDARD_INDICES","_","i","LEFT_HAND_INDICES","RIGHT_HAND_INDICES","LEFT_FOOT_INDICES","RIGHT_FOOT_INDICES","TORSO_INDICES","LANDMARKS_TEXTURE_WIDTH","N_LANDMARK_METADATA_SLOTS","DEFAULT_POSE_OPTIONS","sharedDetectors","updateLandmarksData","detector","poses","data","nPoses","poseIdx","landmarks","lmIdx","landmark","dataIdx","bodyCenter","calculateBoundingBoxCenter","bodyCenterIdx","leftHandCenter","leftHandCenterIdx","rightHandCenter","rightHandCenterIdx","leftFootCenter","leftFootCenterIdx","rightFootCenter","rightFootCenterIdx","torsoCenter","torsoCenterIdx","updateMaskCanvas","segmentationMasks","shader","maxPoses","segMask","pose","config","textureName","history","mediapipeOptions","options","optionsKey","hashOptions","nLandmarksMax","textureHeight","shaderPad","context","injectGLSL","emitHook","existingDetector","landmarksData","sharedCanvas","skipHistoryWrite","onResult","nSlots","rowsToUpdate","initializeDetector","mediaPipe","PoseLandmarker","getSharedFileset","poseLandmarker","maskShader","index_default","dummyTexture","initPromise","name","source","isMediaPipeSource","detectPoses","updates","nDetectionCalls","now","callOrder","requiredMode","shouldDetect","result","cb","fn","historyParams","generateGLSLFn","sampleMask","pose_default"]}