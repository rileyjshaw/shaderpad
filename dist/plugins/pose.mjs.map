{"version":3,"sources":["../../src/plugins/pose.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tcalculateBoundingBoxCenter,\n\tgenerateGLSLFn,\n\tdummyTexture,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { PoseLandmarker, PoseLandmarkerResult, NormalizedLandmark, MPMask } from '@mediapipe/tasks-vision';\n\nexport interface PosePluginOptions {\n\tmodelPath?: string;\n\tmaxPoses?: number;\n\tminPoseDetectionConfidence?: number;\n\tminPosePresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\thistory?: number;\n}\n\nconst STANDARD_LANDMARK_COUNT = 33; // See https://ai.google.dev/edge/mediapipe/solutions/vision/pose_landmarker#pose_landmarker_model.\nconst CUSTOM_LANDMARK_COUNT = 6;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst LANDMARK_INDICES = {\n\t// Standard landmarks.\n\tLEFT_EYE: 2,\n\tRIGHT_EYE: 5,\n\tLEFT_SHOULDER: 11,\n\tRIGHT_SHOULDER: 12,\n\tLEFT_ELBOW: 13,\n\tRIGHT_ELBOW: 14,\n\tLEFT_HIP: 23,\n\tRIGHT_HIP: 24,\n\tLEFT_KNEE: 25,\n\tRIGHT_KNEE: 26,\n\tLEFT_WRIST: 15,\n\tRIGHT_WRIST: 16,\n\tLEFT_PINKY: 17,\n\tRIGHT_PINKY: 18,\n\tLEFT_INDEX: 19,\n\tRIGHT_INDEX: 20,\n\tLEFT_THUMB: 21,\n\tRIGHT_THUMB: 22,\n\tLEFT_ANKLE: 27,\n\tRIGHT_ANKLE: 28,\n\tLEFT_HEEL: 29,\n\tRIGHT_HEEL: 30,\n\tLEFT_FOOT_INDEX: 31,\n\tRIGHT_FOOT_INDEX: 32,\n\t// Custom landmarks.\n\tBODY_CENTER: STANDARD_LANDMARK_COUNT,\n\tLEFT_HAND_CENTER: STANDARD_LANDMARK_COUNT + 1,\n\tRIGHT_HAND_CENTER: STANDARD_LANDMARK_COUNT + 2,\n\tLEFT_FOOT_CENTER: STANDARD_LANDMARK_COUNT + 3,\n\tRIGHT_FOOT_CENTER: STANDARD_LANDMARK_COUNT + 4,\n\tTORSO_CENTER: STANDARD_LANDMARK_COUNT + 5,\n};\nconst ALL_STANDARD_INDICES = Array.from({ length: STANDARD_LANDMARK_COUNT }, (_, i) => i);\nconst LEFT_HAND_INDICES = [\n\tLANDMARK_INDICES.LEFT_WRIST,\n\tLANDMARK_INDICES.LEFT_PINKY,\n\tLANDMARK_INDICES.LEFT_THUMB,\n\tLANDMARK_INDICES.LEFT_INDEX,\n];\nconst RIGHT_HAND_INDICES = [\n\tLANDMARK_INDICES.RIGHT_WRIST,\n\tLANDMARK_INDICES.RIGHT_PINKY,\n\tLANDMARK_INDICES.RIGHT_THUMB,\n\tLANDMARK_INDICES.RIGHT_INDEX,\n];\nconst LEFT_FOOT_INDICES = [LANDMARK_INDICES.LEFT_ANKLE, LANDMARK_INDICES.LEFT_HEEL, LANDMARK_INDICES.LEFT_FOOT_INDEX];\nconst RIGHT_FOOT_INDICES = [\n\tLANDMARK_INDICES.RIGHT_ANKLE,\n\tLANDMARK_INDICES.RIGHT_HEEL,\n\tLANDMARK_INDICES.RIGHT_FOOT_INDEX,\n];\nconst TORSO_INDICES = [\n\tLANDMARK_INDICES.LEFT_SHOULDER,\n\tLANDMARK_INDICES.RIGHT_SHOULDER,\n\tLANDMARK_INDICES.LEFT_HIP,\n\tLANDMARK_INDICES.RIGHT_HIP,\n];\n\nconst LANDMARKS_TEXTURE_WIDTH = 512;\nconst N_LANDMARK_METADATA_SLOTS = 1;\n\nconst DEFAULT_POSE_OPTIONS: Required<Omit<PosePluginOptions, 'history'>> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',\n\tmaxPoses: 1,\n\tminPoseDetectionConfidence: 0.5,\n\tminPosePresenceConfidence: 0.5,\n\tminTrackingConfidence: 0.5,\n};\n\nconst MASK_SHADER_SRC = `#version 300 es\nprecision mediump float;\nin vec2 v_uv;\nout vec4 outColor;\nuniform mediump sampler2D u_mask;\nuniform float u_poseIndex;\nvoid main() {\n\tivec2 texCoord = ivec2(vec2(v_uv.x, 1.0 - v_uv.y) * vec2(textureSize(u_mask, 0)));\n\tfloat confidence = texelFetch(u_mask, texCoord, 0).r;\n\tif (confidence < 0.01) discard;\n\toutColor = vec4(1.0, confidence, u_poseIndex, 1.0);\n}`;\n\ninterface Detector {\n\tlandmarker: PoseLandmarker;\n\tmediapipeCanvas: OffscreenCanvas;\n\tmaskShader: ShaderPad;\n\tsubscribers: Map<() => void, boolean>;\n\tmaxPoses: number;\n\tstate: {\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: PoseLandmarkerResult | null;\n\t\tpending: Promise<void>;\n\t\tnPoses: number;\n\t};\n\tlandmarks: {\n\t\tdata: Float32Array;\n\t\ttextureHeight: number;\n\t};\n}\nconst sharedDetectors = new Map<string, Detector>();\n\nfunction updateLandmarksData(detector: Detector, poses: NormalizedLandmark[][]) {\n\tconst data = detector.landmarks.data;\n\tconst nPoses = poses.length;\n\n\tdata[0] = nPoses;\n\n\tfor (let poseIdx = 0; poseIdx < nPoses; ++poseIdx) {\n\t\tconst landmarks = poses[poseIdx];\n\t\tfor (let lmIdx = 0; lmIdx < STANDARD_LANDMARK_COUNT; ++lmIdx) {\n\t\t\tconst landmark = landmarks[lmIdx];\n\t\t\tconst dataIdx = (N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + lmIdx) * 4;\n\t\t\tdata[dataIdx] = landmark.x;\n\t\t\tdata[dataIdx + 1] = 1 - landmark.y;\n\t\t\tdata[dataIdx + 2] = landmark.z ?? 0;\n\t\t\tdata[dataIdx + 3] = landmark.visibility ?? 1;\n\t\t}\n\n\t\tconst bodyCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tALL_STANDARD_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst bodyCenterIdx = (N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.BODY_CENTER) * 4;\n\t\tdata[bodyCenterIdx] = bodyCenter[0];\n\t\tdata[bodyCenterIdx + 1] = bodyCenter[1];\n\t\tdata[bodyCenterIdx + 2] = bodyCenter[2];\n\t\tdata[bodyCenterIdx + 3] = bodyCenter[3];\n\n\t\tconst leftHandCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tLEFT_HAND_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst leftHandCenterIdx =\n\t\t\t(N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.LEFT_HAND_CENTER) * 4;\n\t\tdata[leftHandCenterIdx] = leftHandCenter[0];\n\t\tdata[leftHandCenterIdx + 1] = leftHandCenter[1];\n\t\tdata[leftHandCenterIdx + 2] = leftHandCenter[2];\n\t\tdata[leftHandCenterIdx + 3] = leftHandCenter[3];\n\n\t\tconst rightHandCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tRIGHT_HAND_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst rightHandCenterIdx =\n\t\t\t(N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.RIGHT_HAND_CENTER) * 4;\n\t\tdata[rightHandCenterIdx] = rightHandCenter[0];\n\t\tdata[rightHandCenterIdx + 1] = rightHandCenter[1];\n\t\tdata[rightHandCenterIdx + 2] = rightHandCenter[2];\n\t\tdata[rightHandCenterIdx + 3] = rightHandCenter[3];\n\n\t\tconst leftFootCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tLEFT_FOOT_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst leftFootCenterIdx =\n\t\t\t(N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.LEFT_FOOT_CENTER) * 4;\n\t\tdata[leftFootCenterIdx] = leftFootCenter[0];\n\t\tdata[leftFootCenterIdx + 1] = leftFootCenter[1];\n\t\tdata[leftFootCenterIdx + 2] = leftFootCenter[2];\n\t\tdata[leftFootCenterIdx + 3] = leftFootCenter[3];\n\n\t\tconst rightFootCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tRIGHT_FOOT_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst rightFootCenterIdx =\n\t\t\t(N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.RIGHT_FOOT_CENTER) * 4;\n\t\tdata[rightFootCenterIdx] = rightFootCenter[0];\n\t\tdata[rightFootCenterIdx + 1] = rightFootCenter[1];\n\t\tdata[rightFootCenterIdx + 2] = rightFootCenter[2];\n\t\tdata[rightFootCenterIdx + 3] = rightFootCenter[3];\n\n\t\tconst torsoCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tposeIdx,\n\t\t\tTORSO_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tconst torsoCenterIdx =\n\t\t\t(N_LANDMARK_METADATA_SLOTS + poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.TORSO_CENTER) * 4;\n\t\tdata[torsoCenterIdx] = torsoCenter[0];\n\t\tdata[torsoCenterIdx + 1] = torsoCenter[1];\n\t\tdata[torsoCenterIdx + 2] = torsoCenter[2];\n\t\tdata[torsoCenterIdx + 3] = torsoCenter[3];\n\t}\n\n\tdetector.state.nPoses = nPoses;\n}\n\nfunction updateMask(detector: Detector, segmentationMasks?: MPMask[]) {\n\tconst { maskShader, maxPoses } = detector;\n\n\tif (!segmentationMasks || segmentationMasks.length === 0) {\n\t\treturn maskShader.clear();\n\t}\n\n\tfor (let i = 0; i < segmentationMasks.length; ++i) {\n\t\tconst segMask = segmentationMasks[i];\n\t\tmaskShader.updateTextures({ u_mask: segMask.getAsWebGLTexture() });\n\t\tmaskShader.updateUniforms({ u_poseIndex: (i + 1) / maxPoses });\n\t\tmaskShader.draw({ skipClear: i > 0 });\n\t\tsegMask.close();\n\t}\n}\n\nfunction pose(config: { textureName: string; options?: PosePluginOptions }) {\n\tconst { textureName, options: { history, ...mediapipeOptions } = {} } = config;\n\tconst options = { ...DEFAULT_POSE_OPTIONS, ...mediapipeOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\tconst nLandmarksMax = options.maxPoses * LANDMARK_COUNT + N_LANDMARK_METADATA_SLOTS;\n\tconst textureHeight = Math.ceil(nLandmarksMax / LANDMARKS_TEXTURE_WIDTH);\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst landmarksData =\n\t\t\texistingDetector?.landmarks.data ?? new Float32Array(LANDMARKS_TEXTURE_WIDTH * textureHeight * 4);\n\t\tconst mediapipeCanvas = existingDetector?.mediapipeCanvas ?? new OffscreenCanvas(1, 1);\n\t\tconst maskShader =\n\t\t\texistingDetector?.maskShader ??\n\t\t\t(() => {\n\t\t\t\tconst shader = new ShaderPad(MASK_SHADER_SRC, { canvas: mediapipeCanvas });\n\t\t\t\tshader.initializeTexture('u_mask', dummyTexture);\n\t\t\t\tshader.initializeUniform('u_poseIndex', 'float', 0);\n\t\t\t\treturn shader;\n\t\t\t})();\n\n\t\tlet detector: Detector | null = null;\n\t\tlet destroyed = false;\n\t\tlet skipHistoryWrite = false;\n\n\t\tfunction onResult() {\n\t\t\tif (!detector) return;\n\t\t\tconst { nPoses } = detector.state;\n\t\t\tconst nSlots = nPoses * LANDMARK_COUNT + N_LANDMARK_METADATA_SLOTS;\n\t\t\tconst rowsToUpdate = Math.ceil(nSlots / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures(\n\t\t\t\t{\n\t\t\t\t\tu_poseLandmarksTex: {\n\t\t\t\t\t\tdata: detector.landmarks.data,\n\t\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t\t\tisPartial: true,\n\t\t\t\t\t},\n\t\t\t\t\tu_poseMask: maskShader,\n\t\t\t\t},\n\t\t\t\t{ skipHistoryWrite }\n\t\t\t);\n\t\t\tshaderPad.updateUniforms({ u_nPoses: nPoses });\n\t\t\temitHook('pose:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { PoseLandmarker }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\tif (destroyed) return;\n\t\t\t\tconst poseLandmarker = await PoseLandmarker.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\tnumPoses: options.maxPoses,\n\t\t\t\t\tminPoseDetectionConfidence: options.minPoseDetectionConfidence,\n\t\t\t\t\tminPosePresenceConfidence: options.minPosePresenceConfidence,\n\t\t\t\t\tminTrackingConfidence: options.minTrackingConfidence,\n\t\t\t\t\toutputSegmentationMasks: true,\n\t\t\t\t});\n\t\t\t\tif (destroyed) {\n\t\t\t\t\tposeLandmarker.close();\n\t\t\t\t\tmaskShader.destroy();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdetector = {\n\t\t\t\t\tlandmarker: poseLandmarker,\n\t\t\t\t\tmediapipeCanvas,\n\t\t\t\t\tmaskShader,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tmaxPoses: options.maxPoses,\n\t\t\t\t\tstate: {\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t\tnPoses: 0,\n\t\t\t\t\t},\n\t\t\t\t\tlandmarks: {\n\t\t\t\t\t\tdata: landmarksData,\n\t\t\t\t\t\ttextureHeight,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_maxPoses', 'int', options.maxPoses);\n\t\t\tshaderPad.initializeUniform('u_nPoses', 'int', 0);\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_poseLandmarksTex',\n\t\t\t\t{ data: landmarksData, width: LANDMARKS_TEXTURE_WIDTH, height: textureHeight },\n\t\t\t\t{ internalFormat: 'RGBA32F', type: 'FLOAT', minFilter: 'NEAREST', magFilter: 'NEAREST', history }\n\t\t\t);\n\t\t\tshaderPad.initializeTexture('u_poseMask', maskShader, {\n\t\t\t\tminFilter: 'NEAREST',\n\t\t\t\tmagFilter: 'NEAREST',\n\t\t\t\thistory,\n\t\t\t});\n\t\t\tinitPromise.then(() => {\n\t\t\t\tif (destroyed || !detector) return;\n\t\t\t\temitHook('pose:ready');\n\t\t\t});\n\t\t});\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) detectPoses(source);\n\t\t});\n\n\t\tshaderPad.on(\n\t\t\t'updateTextures',\n\t\t\t(updates: Record<string, TextureSource>, options?: { skipHistoryWrite?: boolean }) => {\n\t\t\t\tconst source = updates[textureName];\n\t\t\t\tif (isMediaPipeSource(source)) {\n\t\t\t\t\tskipHistoryWrite = options?.skipHistoryWrite ?? false;\n\t\t\t\t\tdetectPoses(source);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectPoses(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tconst callOrder = ++nDetectionCalls;\n\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (callOrder !== nDetectionCalls || !detector) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.landmarker.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: PoseLandmarkerResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.landmarker.detectForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.landmarker.detect(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tupdateLandmarksData(detector, result.landmarks);\n\t\t\t\t\t\tupdateMask(detector, result.segmentationMasks);\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result && !detector.subscribers.get(onResult)) {\n\t\t\t\t\tonResult();\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tdestroyed = true;\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.landmarker.close();\n\t\t\t\t\tdetector.maskShader.destroy();\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tconst { fn, historyParams } = generateGLSLFn(history);\n\t\tconst sampleMask = history\n\t\t\t? `int layer = (u_poseMaskFrameOffset - framesAgo + ${history}) % ${history};\n\tvec4 mask = texture(u_poseMask, vec3(pos, float(layer)));`\n\t\t\t: `vec4 mask = texture(u_poseMask, pos);`;\n\n\t\tinjectGLSL(`\nuniform int u_maxPoses;\nuniform int u_nPoses;\nuniform highp sampler2D${history ? 'Array' : ''} u_poseLandmarksTex;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_poseLandmarksTexFrameOffset;`\n\t\t\t\t: ''\n\t\t}\nuniform ${history ? 'highp' : 'mediump'} sampler2D${history ? 'Array' : ''} u_poseMask;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_poseMaskFrameOffset;`\n\t\t\t\t: ''\n\t\t}\n\n#define POSE_LANDMARK_LEFT_EYE ${LANDMARK_INDICES.LEFT_EYE}\n#define POSE_LANDMARK_RIGHT_EYE ${LANDMARK_INDICES.RIGHT_EYE}\n#define POSE_LANDMARK_LEFT_SHOULDER ${LANDMARK_INDICES.LEFT_SHOULDER}\n#define POSE_LANDMARK_RIGHT_SHOULDER ${LANDMARK_INDICES.RIGHT_SHOULDER}\n#define POSE_LANDMARK_LEFT_ELBOW ${LANDMARK_INDICES.LEFT_ELBOW}\n#define POSE_LANDMARK_RIGHT_ELBOW ${LANDMARK_INDICES.RIGHT_ELBOW}\n#define POSE_LANDMARK_LEFT_HIP ${LANDMARK_INDICES.LEFT_HIP}\n#define POSE_LANDMARK_RIGHT_HIP ${LANDMARK_INDICES.RIGHT_HIP}\n#define POSE_LANDMARK_LEFT_KNEE ${LANDMARK_INDICES.LEFT_KNEE}\n#define POSE_LANDMARK_RIGHT_KNEE ${LANDMARK_INDICES.RIGHT_KNEE}\n#define POSE_LANDMARK_BODY_CENTER ${LANDMARK_INDICES.BODY_CENTER}\n#define POSE_LANDMARK_LEFT_HAND_CENTER ${LANDMARK_INDICES.LEFT_HAND_CENTER}\n#define POSE_LANDMARK_RIGHT_HAND_CENTER ${LANDMARK_INDICES.RIGHT_HAND_CENTER}\n#define POSE_LANDMARK_LEFT_FOOT_CENTER ${LANDMARK_INDICES.LEFT_FOOT_CENTER}\n#define POSE_LANDMARK_RIGHT_FOOT_CENTER ${LANDMARK_INDICES.RIGHT_FOOT_CENTER}\n#define POSE_LANDMARK_TORSO_CENTER ${LANDMARK_INDICES.TORSO_CENTER}\n\n${fn(\n\t'int',\n\t'nPosesAt',\n\t'',\n\thistory\n\t\t? `\n\tint layer = (u_poseLandmarksTexFrameOffset - framesAgo + ${history}) % ${history};\n\treturn int(texelFetch(u_poseLandmarksTex, ivec3(0, 0, layer), 0).r + 0.5);`\n\t\t: `\n\treturn int(texelFetch(u_poseLandmarksTex, ivec2(0, 0), 0).r + 0.5);`\n)}\n${fn(\n\t'vec4',\n\t'poseLandmark',\n\t'int poseIndex, int landmarkIndex',\n\t`int i = ${N_LANDMARK_METADATA_SLOTS} + poseIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};${\n\t\thistory\n\t\t\t? `\n\tint layer = (u_poseLandmarksTexFrameOffset - framesAgo + ${history}) % ${history};\n\treturn texelFetch(u_poseLandmarksTex, ivec3(x, y, layer), 0);`\n\t\t\t: `\n\treturn texelFetch(u_poseLandmarksTex, ivec2(x, y), 0);`\n\t}`\n)}\n${fn(\n\t'vec2',\n\t'poseAt',\n\t'vec2 pos',\n\t`${sampleMask}\n\tfloat poseIndex = floor(mask.b * float(u_maxPoses) + 0.5) - 1.0;\n\treturn vec2(mask.g, poseIndex);`\n)}\n${fn('float', 'inPose', 'vec2 pos', `vec2 pose = poseAt(pos${historyParams}); return step(0.0, pose.y) * pose.x;`)}`);\n\t};\n}\n\nexport default pose;\n"],"mappings":"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","names":["STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","LANDMARK_INDICES","ALL_STANDARD_INDICES","_","i","LEFT_HAND_INDICES","RIGHT_HAND_INDICES","LEFT_FOOT_INDICES","RIGHT_FOOT_INDICES","TORSO_INDICES","LANDMARKS_TEXTURE_WIDTH","N_LANDMARK_METADATA_SLOTS","DEFAULT_POSE_OPTIONS","MASK_SHADER_SRC","sharedDetectors","updateLandmarksData","detector","poses","data","nPoses","poseIdx","landmarks","lmIdx","landmark","dataIdx","bodyCenter","calculateBoundingBoxCenter","bodyCenterIdx","leftHandCenter","leftHandCenterIdx","rightHandCenter","rightHandCenterIdx","leftFootCenter","leftFootCenterIdx","rightFootCenter","rightFootCenterIdx","torsoCenter","torsoCenterIdx","updateMask","segmentationMasks","maskShader","maxPoses","segMask","pose","config","textureName","history","mediapipeOptions","options","optionsKey","hashOptions","nLandmarksMax","textureHeight","shaderPad","context","injectGLSL","emitHook","existingDetector","landmarksData","mediapipeCanvas","shader","index_default","dummyTexture","destroyed","skipHistoryWrite","onResult","nSlots","rowsToUpdate","initializeDetector","mediaPipe","PoseLandmarker","getSharedFileset","poseLandmarker","initPromise","name","source","isMediaPipeSource","detectPoses","updates","nDetectionCalls","now","callOrder","requiredMode","shouldDetect","result","cb","fn","historyParams","generateGLSLFn","sampleMask","pose_default"]}