{"version":3,"sources":["../../src/plugins/pose.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '../index';\nimport type { PoseLandmarker, NormalizedLandmark } from '@mediapipe/tasks-vision';\n\nexport interface PosePluginOptions {\n\tmodelPath?: string;\n\tmaxPoses?: number;\n\tminPoseDetectionConfidence?: number;\n\tminPosePresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\toutputSegmentationMasks?: boolean;\n}\n\nconst STANDARD_LANDMARK_COUNT = 33; // See https://ai.google.dev/edge/mediapipe/solutions/vision/pose_landmarker#pose_landmarker_model.\nconst CUSTOM_LANDMARK_COUNT = 6;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst LANDMARK_INDICES = {\n\t// Standard landmarks.\n\tLEFT_EYE: 2,\n\tRIGHT_EYE: 5,\n\tLEFT_SHOULDER: 11,\n\tRIGHT_SHOULDER: 12,\n\tLEFT_ELBOW: 13,\n\tRIGHT_ELBOW: 14,\n\tLEFT_HIP: 23,\n\tRIGHT_HIP: 24,\n\tLEFT_KNEE: 25,\n\tRIGHT_KNEE: 26,\n\tLEFT_WRIST: 15,\n\tRIGHT_WRIST: 16,\n\tLEFT_PINKY: 17,\n\tRIGHT_PINKY: 18,\n\tLEFT_INDEX: 19,\n\tRIGHT_INDEX: 20,\n\tLEFT_THUMB: 21,\n\tRIGHT_THUMB: 22,\n\tLEFT_ANKLE: 27,\n\tRIGHT_ANKLE: 28,\n\tLEFT_HEEL: 29,\n\tRIGHT_HEEL: 30,\n\tLEFT_FOOT_INDEX: 31,\n\tRIGHT_FOOT_INDEX: 32,\n\t// Custom landmarks.\n\tBODY_CENTER: STANDARD_LANDMARK_COUNT,\n\tLEFT_HAND_CENTER: STANDARD_LANDMARK_COUNT + 1,\n\tRIGHT_HAND_CENTER: STANDARD_LANDMARK_COUNT + 2,\n\tLEFT_FOOT_CENTER: STANDARD_LANDMARK_COUNT + 3,\n\tRIGHT_FOOT_CENTER: STANDARD_LANDMARK_COUNT + 4,\n\tTORSO_CENTER: STANDARD_LANDMARK_COUNT + 5,\n};\n\nfunction pose(config: { textureName: string; options?: PosePluginOptions }) {\n\tconst { textureName, options } = config;\n\tconst defaultModelPath =\n\t\t'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task';\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, gl } = context;\n\n\t\tlet poseLandmarker: PoseLandmarker | null = null;\n\t\tlet vision: any = null;\n\t\tlet lastVideoTime = -1;\n\t\tconst textureSources = new Map<string, TextureSource>();\n\t\tconst maxPoses = options?.maxPoses ?? 1;\n\n\t\tconst LANDMARKS_TEXTURE_WIDTH = 512;\n\t\tlet landmarksTextureHeight = 0;\n\t\tlet landmarksDataArray: Float32Array | null = null;\n\n\t\tconst maskWidth = 512;\n\t\tconst maskHeight = 512;\n\t\tconst poseMaskCanvas = document.createElement('canvas');\n\t\tposeMaskCanvas.width = maskWidth;\n\t\tposeMaskCanvas.height = maskHeight;\n\t\tconst poseMaskCtx = poseMaskCanvas.getContext('2d')!;\n\t\tconst segmentationCanvas = document.createElement('canvas');\n\t\tconst segmentationCtx = segmentationCanvas.getContext('2d')!;\n\t\tposeMaskCtx.globalCompositeOperation = segmentationCtx.globalCompositeOperation = 'lighten'; // Keep the highest value of each channel.\n\n\t\tasync function initializePoseLandmarker() {\n\t\t\ttry {\n\t\t\t\tconst { FilesetResolver, PoseLandmarker } = await import('@mediapipe/tasks-vision');\n\t\t\t\tvision = await FilesetResolver.forVisionTasks(\n\t\t\t\t\t'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'\n\t\t\t\t);\n\t\t\t\tposeLandmarker = await PoseLandmarker.createFromOptions(vision, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options?.modelPath || defaultModelPath,\n\t\t\t\t\t},\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\tnumPoses: options?.maxPoses ?? 1,\n\t\t\t\t\tminPoseDetectionConfidence: options?.minPoseDetectionConfidence ?? 0.5,\n\t\t\t\t\tminPosePresenceConfidence: options?.minPosePresenceConfidence ?? 0.5,\n\t\t\t\t\tminTrackingConfidence: options?.minTrackingConfidence ?? 0.5,\n\t\t\t\t\toutputSegmentationMasks: options?.outputSegmentationMasks ?? true,\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Pose Plugin] Failed to initialize Pose Landmarker:', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tfunction calculateBoundingBoxCenter(\n\t\t\tlandmarksDataArray: Float32Array,\n\t\t\tposeIdx: number,\n\t\t\tlandmarkIndices: number[]\n\t\t): [number, number, number, number] {\n\t\t\tlet minX = Infinity,\n\t\t\t\tmaxX = -Infinity,\n\t\t\t\tminY = Infinity,\n\t\t\t\tmaxY = -Infinity,\n\t\t\t\tavgZ = 0,\n\t\t\t\tavgVisibility = 0;\n\n\t\t\tfor (const idx of landmarkIndices) {\n\t\t\t\tconst dataIdx = (poseIdx * LANDMARK_COUNT + idx) * 4;\n\t\t\t\tconst x = landmarksDataArray[dataIdx];\n\t\t\t\tconst y = landmarksDataArray[dataIdx + 1];\n\t\t\t\tminX = Math.min(minX, x);\n\t\t\t\tmaxX = Math.max(maxX, x);\n\t\t\t\tminY = Math.min(minY, y);\n\t\t\t\tmaxY = Math.max(maxY, y);\n\t\t\t\tavgZ += landmarksDataArray[dataIdx + 2];\n\t\t\t\tavgVisibility += landmarksDataArray[dataIdx + 3];\n\t\t\t}\n\n\t\t\tconst centerX = (minX + maxX) / 2;\n\t\t\tconst centerY = (minY + maxY) / 2;\n\t\t\tconst centerZ = avgZ / landmarkIndices.length;\n\t\t\tconst centerVisibility = avgVisibility / landmarkIndices.length;\n\t\t\treturn [centerX, centerY, centerZ, centerVisibility];\n\t\t}\n\n\t\tasync function updateMaskTexture(segmentationMasks?: any[]) {\n\t\t\tif (!poseLandmarker || !landmarksDataArray) {\n\t\t\t\tconsole.warn('[Pose Plugin] Cannot update mask: poseLandmarker or landmarksDataArray missing');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tposeMaskCtx.clearRect(0, 0, poseMaskCanvas.width, poseMaskCanvas.height);\n\n\t\t\t\t// Draw the segmentation masks.\n\t\t\t\tif (segmentationMasks && segmentationMasks.length > 0) {\n\t\t\t\t\tsegmentationMasks.forEach(mask => {\n\t\t\t\t\t\tif (!mask) return;\n\n\t\t\t\t\t\tconst { width, height } = mask;\n\t\t\t\t\t\tconst maskData = mask.getAsUint8Array();\n\t\t\t\t\t\tconst pixelCount = width * height;\n\t\t\t\t\t\tconst outputData = new Uint8ClampedArray(pixelCount * 4);\n\n\t\t\t\t\t\tfor (let i = 0; i < pixelCount; i++) {\n\t\t\t\t\t\t\toutputData[i * 4 + 1] = maskData[i]; // G (body mask)\n\t\t\t\t\t\t\toutputData[i * 4 + 3] = 255; // A (required for compositing)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rgbaMask = new ImageData(outputData, width, height);\n\n\t\t\t\t\t\t// Resize mask to canvas size if needed.\n\t\t\t\t\t\tif (width === poseMaskCanvas.width && height === poseMaskCanvas.height) {\n\t\t\t\t\t\t\tposeMaskCtx.putImageData(rgbaMask, 0, 0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (segmentationCanvas.width !== width) segmentationCanvas.width = width;\n\t\t\t\t\t\t\tif (segmentationCanvas.height !== height) segmentationCanvas.height = height;\n\t\t\t\t\t\t\tsegmentationCtx.putImageData(rgbaMask, 0, 0);\n\t\t\t\t\t\t\tposeMaskCtx.drawImage(\n\t\t\t\t\t\t\t\tsegmentationCanvas,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tposeMaskCanvas.width,\n\t\t\t\t\t\t\t\tposeMaskCanvas.height\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tshaderPad.updateTextures({ u_poseMask: poseMaskCanvas });\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Pose Plugin] Failed to generate mask texture:', error);\n\t\t\t}\n\t\t}\n\n\t\tfunction updateLandmarksTexture(poses: NormalizedLandmark[][]) {\n\t\t\tif (!landmarksDataArray) return;\n\n\t\t\tconst nPoses = poses.length;\n\t\t\tconst totalLandmarks = nPoses * LANDMARK_COUNT;\n\n\t\t\tfor (let poseIdx = 0; poseIdx < nPoses; ++poseIdx) {\n\t\t\t\tconst landmarks = poses[poseIdx];\n\t\t\t\tfor (let lmIdx = 0; lmIdx < STANDARD_LANDMARK_COUNT; ++lmIdx) {\n\t\t\t\t\tconst landmark = landmarks[lmIdx];\n\t\t\t\t\tconst dataIdx = (poseIdx * LANDMARK_COUNT + lmIdx) * 4;\n\t\t\t\t\tlandmarksDataArray[dataIdx] = landmark.x; // R (X)\n\t\t\t\t\tlandmarksDataArray[dataIdx + 1] = 1 - landmark.y; // G (Inverted Y)\n\t\t\t\t\tlandmarksDataArray[dataIdx + 2] = landmark.z ?? 0; // B (Z)\n\t\t\t\t\tlandmarksDataArray[dataIdx + 3] = landmark.visibility ?? 1; // A (Visibility)\n\t\t\t\t}\n\n\t\t\t\t// Body center (landmark 33) - calculated from all standard landmarks\n\t\t\t\tconst bodyCenter = calculateBoundingBoxCenter(\n\t\t\t\t\tlandmarksDataArray,\n\t\t\t\t\tposeIdx,\n\t\t\t\t\tArray.from({ length: STANDARD_LANDMARK_COUNT }, (_, i) => i)\n\t\t\t\t);\n\t\t\t\tconst bodyCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.BODY_CENTER) * 4;\n\t\t\t\tlandmarksDataArray[bodyCenterIdx] = bodyCenter[0];\n\t\t\t\tlandmarksDataArray[bodyCenterIdx + 1] = bodyCenter[1];\n\t\t\t\tlandmarksDataArray[bodyCenterIdx + 2] = bodyCenter[2];\n\t\t\t\tlandmarksDataArray[bodyCenterIdx + 3] = bodyCenter[3];\n\n\t\t\t\t// Left hand center (landmark 34) - center of pinky, thumb, wrist, index.\n\t\t\t\tconst leftHandCenter = calculateBoundingBoxCenter(landmarksDataArray, poseIdx, [\n\t\t\t\t\tLANDMARK_INDICES.LEFT_WRIST,\n\t\t\t\t\tLANDMARK_INDICES.LEFT_PINKY,\n\t\t\t\t\tLANDMARK_INDICES.LEFT_THUMB,\n\t\t\t\t\tLANDMARK_INDICES.LEFT_INDEX,\n\t\t\t\t]);\n\t\t\t\tconst leftHandCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.LEFT_HAND_CENTER) * 4;\n\t\t\t\tlandmarksDataArray[leftHandCenterIdx] = leftHandCenter[0];\n\t\t\t\tlandmarksDataArray[leftHandCenterIdx + 1] = leftHandCenter[1];\n\t\t\t\tlandmarksDataArray[leftHandCenterIdx + 2] = leftHandCenter[2];\n\t\t\t\tlandmarksDataArray[leftHandCenterIdx + 3] = leftHandCenter[3];\n\n\t\t\t\t// Right hand center (landmark 35) - center of pinky, thumb, wrist, index.\n\t\t\t\tconst rightHandCenter = calculateBoundingBoxCenter(landmarksDataArray, poseIdx, [\n\t\t\t\t\tLANDMARK_INDICES.RIGHT_WRIST,\n\t\t\t\t\tLANDMARK_INDICES.RIGHT_PINKY,\n\t\t\t\t\tLANDMARK_INDICES.RIGHT_THUMB,\n\t\t\t\t\tLANDMARK_INDICES.RIGHT_INDEX,\n\t\t\t\t]);\n\t\t\t\tconst rightHandCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.RIGHT_HAND_CENTER) * 4;\n\t\t\t\tlandmarksDataArray[rightHandCenterIdx] = rightHandCenter[0];\n\t\t\t\tlandmarksDataArray[rightHandCenterIdx + 1] = rightHandCenter[1];\n\t\t\t\tlandmarksDataArray[rightHandCenterIdx + 2] = rightHandCenter[2];\n\t\t\t\tlandmarksDataArray[rightHandCenterIdx + 3] = rightHandCenter[3];\n\n\t\t\t\t// Left foot center (landmark 36) - center of ankle, heel, foot index\n\t\t\t\tconst leftFootCenter = calculateBoundingBoxCenter(landmarksDataArray, poseIdx, [\n\t\t\t\t\tLANDMARK_INDICES.LEFT_ANKLE,\n\t\t\t\t\tLANDMARK_INDICES.LEFT_HEEL,\n\t\t\t\t\tLANDMARK_INDICES.LEFT_FOOT_INDEX,\n\t\t\t\t]);\n\t\t\t\tconst leftFootCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.LEFT_FOOT_CENTER) * 4;\n\t\t\t\tlandmarksDataArray[leftFootCenterIdx] = leftFootCenter[0];\n\t\t\t\tlandmarksDataArray[leftFootCenterIdx + 1] = leftFootCenter[1];\n\t\t\t\tlandmarksDataArray[leftFootCenterIdx + 2] = leftFootCenter[2];\n\t\t\t\tlandmarksDataArray[leftFootCenterIdx + 3] = leftFootCenter[3];\n\n\t\t\t\t// Right foot center (landmark 37) - center of ankle, heel, foot index\n\t\t\t\tconst rightFootCenter = calculateBoundingBoxCenter(landmarksDataArray, poseIdx, [\n\t\t\t\t\tLANDMARK_INDICES.RIGHT_ANKLE,\n\t\t\t\t\tLANDMARK_INDICES.RIGHT_HEEL,\n\t\t\t\t\tLANDMARK_INDICES.RIGHT_FOOT_INDEX,\n\t\t\t\t]);\n\t\t\t\tconst rightFootCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.RIGHT_FOOT_CENTER) * 4;\n\t\t\t\tlandmarksDataArray[rightFootCenterIdx] = rightFootCenter[0];\n\t\t\t\tlandmarksDataArray[rightFootCenterIdx + 1] = rightFootCenter[1];\n\t\t\t\tlandmarksDataArray[rightFootCenterIdx + 2] = rightFootCenter[2];\n\t\t\t\tlandmarksDataArray[rightFootCenterIdx + 3] = rightFootCenter[3];\n\n\t\t\t\t// Torso center (landmark 38) - center of shoulders and hips\n\t\t\t\tconst torsoCenter = calculateBoundingBoxCenter(landmarksDataArray, poseIdx, [\n\t\t\t\t\tLANDMARK_INDICES.LEFT_SHOULDER,\n\t\t\t\t\tLANDMARK_INDICES.RIGHT_SHOULDER,\n\t\t\t\t\tLANDMARK_INDICES.LEFT_HIP,\n\t\t\t\t\tLANDMARK_INDICES.RIGHT_HIP,\n\t\t\t\t]);\n\t\t\t\tconst torsoCenterIdx = (poseIdx * LANDMARK_COUNT + LANDMARK_INDICES.TORSO_CENTER) * 4;\n\t\t\t\tlandmarksDataArray[torsoCenterIdx] = torsoCenter[0];\n\t\t\t\tlandmarksDataArray[torsoCenterIdx + 1] = torsoCenter[1];\n\t\t\t\tlandmarksDataArray[torsoCenterIdx + 2] = torsoCenter[2];\n\t\t\t\tlandmarksDataArray[torsoCenterIdx + 3] = torsoCenter[3];\n\t\t\t}\n\n\t\t\tconst rowsToUpdate = Math.ceil(totalLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures({\n\t\t\t\tu_poseLandmarksTex: {\n\t\t\t\t\tdata: landmarksDataArray,\n\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tfunction processPoseResults(result: any) {\n\t\t\tif (!result.landmarks || !landmarksDataArray) return;\n\n\t\t\tconst nPoses = result.landmarks.length;\n\t\t\tupdateLandmarksTexture(result.landmarks);\n\t\t\tupdateMaskTexture(result.segmentationMasks).catch(error => {\n\t\t\t\tconsole.warn('[Pose Plugin] Mask texture update error:', error);\n\t\t\t});\n\n\t\t\tshaderPad.updateUniforms({ u_nPoses: nPoses });\n\t\t}\n\n\t\tshaderPad.registerHook('init', async () => {\n\t\t\tshaderPad.initializeTexture('u_poseMask', poseMaskCanvas);\n\t\t\tshaderPad.initializeUniform('u_maxPoses', 'int', maxPoses);\n\t\t\tshaderPad.initializeUniform('u_nPoses', 'int', 0);\n\n\t\t\tconst totalLandmarks = maxPoses * LANDMARK_COUNT;\n\t\t\tlandmarksTextureHeight = Math.ceil(totalLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tconst textureSize = LANDMARKS_TEXTURE_WIDTH * landmarksTextureHeight * 4;\n\t\t\tlandmarksDataArray = new Float32Array(textureSize);\n\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_poseLandmarksTex',\n\t\t\t\t{\n\t\t\t\t\tdata: landmarksDataArray,\n\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\theight: landmarksTextureHeight,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tinternalFormat: gl.RGBA32F,\n\t\t\t\t\ttype: gl.FLOAT,\n\t\t\t\t\tminFilter: gl.NEAREST,\n\t\t\t\t\tmagFilter: gl.NEAREST,\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tawait initializePoseLandmarker();\n\t\t});\n\n\t\tshaderPad.registerHook('updateTextures', (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (!source) return;\n\n\t\t\tconst previousSource = textureSources.get(textureName);\n\t\t\tif (previousSource !== source) {\n\t\t\t\tlastVideoTime = -1;\n\t\t\t}\n\n\t\t\ttextureSources.set(textureName, source);\n\t\t\tif (!poseLandmarker) return;\n\t\t\ttry {\n\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (source.currentTime !== lastVideoTime) {\n\t\t\t\t\t\tlastVideoTime = source.currentTime;\n\t\t\t\t\t\tconst timestamp = performance.now();\n\t\t\t\t\t\tconst result = poseLandmarker.detectForVideo(source, timestamp);\n\t\t\t\t\t\tprocessPoseResults(result);\n\t\t\t\t\t}\n\t\t\t\t} else if (source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {\n\t\t\t\t\tif (source.width === 0 || source.height === 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst result = poseLandmarker.detect(source);\n\t\t\t\t\tprocessPoseResults(result);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Pose Plugin] Pose detection error:', error);\n\t\t\t}\n\t\t});\n\n\t\tshaderPad.registerHook('destroy', () => {\n\t\t\tif (poseLandmarker) {\n\t\t\t\tposeLandmarker.close();\n\t\t\t\tposeLandmarker = null;\n\t\t\t}\n\t\t\tvision = null;\n\t\t\ttextureSources.clear();\n\t\t\tposeMaskCanvas.remove();\n\t\t\tlandmarksDataArray = null;\n\t\t});\n\t\t// TODO: inBody shouldn't rely on alpha. Does it? Seems so in the example.\n\t\t//       Might be because putImageData ignores alpha compositing.\n\t\tinjectGLSL(`\nuniform int u_maxPoses;\nuniform int u_nPoses;\nuniform sampler2D u_poseLandmarksTex;\nuniform sampler2D u_poseMask;\n\n#define POSE_LANDMARK_LEFT_EYE ${LANDMARK_INDICES.LEFT_EYE}\n#define POSE_LANDMARK_RIGHT_EYE ${LANDMARK_INDICES.RIGHT_EYE}\n#define POSE_LANDMARK_LEFT_SHOULDER ${LANDMARK_INDICES.LEFT_SHOULDER}\n#define POSE_LANDMARK_RIGHT_SHOULDER ${LANDMARK_INDICES.RIGHT_SHOULDER}\n#define POSE_LANDMARK_LEFT_ELBOW ${LANDMARK_INDICES.LEFT_ELBOW}\n#define POSE_LANDMARK_RIGHT_ELBOW ${LANDMARK_INDICES.RIGHT_ELBOW}\n#define POSE_LANDMARK_LEFT_HIP ${LANDMARK_INDICES.LEFT_HIP}\n#define POSE_LANDMARK_RIGHT_HIP ${LANDMARK_INDICES.RIGHT_HIP}\n#define POSE_LANDMARK_LEFT_KNEE ${LANDMARK_INDICES.LEFT_KNEE}\n#define POSE_LANDMARK_RIGHT_KNEE ${LANDMARK_INDICES.RIGHT_KNEE}\n#define POSE_LANDMARK_BODY_CENTER ${LANDMARK_INDICES.BODY_CENTER}\n#define POSE_LANDMARK_LEFT_HAND_CENTER ${LANDMARK_INDICES.LEFT_HAND_CENTER}\n#define POSE_LANDMARK_RIGHT_HAND_CENTER ${LANDMARK_INDICES.RIGHT_HAND_CENTER}\n#define POSE_LANDMARK_LEFT_FOOT_CENTER ${LANDMARK_INDICES.LEFT_FOOT_CENTER}\n#define POSE_LANDMARK_RIGHT_FOOT_CENTER ${LANDMARK_INDICES.RIGHT_FOOT_CENTER}\n#define POSE_LANDMARK_TORSO_CENTER ${LANDMARK_INDICES.TORSO_CENTER}\n\nvec4 poseLandmark(int poseIndex, int landmarkIndex) {\n\tint i = poseIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};\n\treturn texelFetch(u_poseLandmarksTex, ivec2(x, y), 0);\n}\nfloat inBody(vec2 pos) { return texture(u_poseMask, pos).g; }`);\n\t};\n}\n\nexport default pose;\n"],"mappings":"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","names":["STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","LANDMARK_INDICES","pose","config","textureName","options","defaultModelPath","shaderPad","context","injectGLSL","gl","poseLandmarker","vision","lastVideoTime","textureSources","maxPoses","LANDMARKS_TEXTURE_WIDTH","landmarksTextureHeight","landmarksDataArray","maskWidth","maskHeight","poseMaskCanvas","poseMaskCtx","segmentationCanvas","segmentationCtx","initializePoseLandmarker","FilesetResolver","PoseLandmarker","error","calculateBoundingBoxCenter","poseIdx","landmarkIndices","minX","maxX","minY","maxY","avgZ","avgVisibility","idx","dataIdx","x","y","centerX","centerY","centerZ","centerVisibility","updateMaskTexture","segmentationMasks","mask","width","height","maskData","pixelCount","outputData","i","rgbaMask","updateLandmarksTexture","poses","nPoses","totalLandmarks","landmarks","lmIdx","landmark","bodyCenter","_","bodyCenterIdx","leftHandCenter","leftHandCenterIdx","rightHandCenter","rightHandCenterIdx","leftFootCenter","leftFootCenterIdx","rightFootCenter","rightFootCenterIdx","torsoCenter","torsoCenterIdx","rowsToUpdate","processPoseResults","result","textureSize","updates","source","timestamp","pose_default"]}