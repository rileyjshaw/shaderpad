{"version":3,"sources":["../../src/plugins/pose.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '../index';\nimport type { PoseLandmarker, NormalizedLandmark } from '@mediapipe/tasks-vision';\n\nexport interface PosePluginOptions {\n\tmodelPath?: string;\n\tmaxPoses?: number;\n\tminPoseDetectionConfidence?: number;\n\tminPosePresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\toutputSegmentationMasks?: boolean;\n}\n\nconst LANDMARK_COUNT = 33; // See https://ai.google.dev/edge/mediapipe/solutions/vision/pose_landmarker#pose_landmarker_model.\n\nfunction pose(config: { textureName: string; options?: PosePluginOptions }) {\n\tconst { textureName, options } = config;\n\tconst defaultModelPath =\n\t\t'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task';\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL } = context;\n\n\t\tlet poseLandmarker: PoseLandmarker | null = null;\n\t\tlet vision: any = null;\n\t\tlet lastVideoTime = -1;\n\t\tconst textureSources = new Map<string, TextureSource>();\n\t\tconst maxPoses = options?.maxPoses ?? 1;\n\t\tconst maskWidth = 512;\n\t\tconst maskHeight = 512;\n\t\tconst poseMaskCanvas = document.createElement('canvas');\n\t\tposeMaskCanvas.width = maskWidth;\n\t\tposeMaskCanvas.height = maskHeight;\n\t\tconst poseMaskCtx = poseMaskCanvas.getContext('2d')!;\n\t\tconst segmentationCanvas = document.createElement('canvas');\n\t\tconst segmentationCtx = segmentationCanvas.getContext('2d')!;\n\t\tposeMaskCtx.globalCompositeOperation = segmentationCtx.globalCompositeOperation = 'lighten'; // Keep the highest value of each channel.\n\t\tconst poseConnections: { start: number; end: number }[] = [];\n\n\t\tasync function initializePoseLandmarker() {\n\t\t\ttry {\n\t\t\t\tconst { FilesetResolver, PoseLandmarker } = await import('@mediapipe/tasks-vision');\n\t\t\t\tvision = await FilesetResolver.forVisionTasks(\n\t\t\t\t\t'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'\n\t\t\t\t);\n\t\t\t\tposeConnections.push(...PoseLandmarker.POSE_CONNECTIONS);\n\t\t\t\tposeLandmarker = await PoseLandmarker.createFromOptions(vision, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options?.modelPath || defaultModelPath,\n\t\t\t\t\t},\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\tnumPoses: options?.maxPoses ?? 1,\n\t\t\t\t\tminPoseDetectionConfidence: options?.minPoseDetectionConfidence ?? 0.5,\n\t\t\t\t\tminPosePresenceConfidence: options?.minPosePresenceConfidence ?? 0.5,\n\t\t\t\t\tminTrackingConfidence: options?.minTrackingConfidence ?? 0.5,\n\t\t\t\t\toutputSegmentationMasks: options?.outputSegmentationMasks ?? true,\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Pose Plugin] Failed to initialize Pose Landmarker:', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tfunction calculatePoseCenter(landmarks: NormalizedLandmark[]): [number, number] {\n\t\t\tlet minX = Infinity,\n\t\t\t\tmaxX = -Infinity,\n\t\t\t\tminY = Infinity,\n\t\t\t\tmaxY = -Infinity;\n\n\t\t\t// Calculate bounding box center from all landmarks.\n\t\t\tfor (const landmark of landmarks) {\n\t\t\t\tminX = Math.min(minX, landmark.x);\n\t\t\t\tmaxX = Math.max(maxX, landmark.x);\n\t\t\t\tminY = Math.min(minY, landmark.y);\n\t\t\t\tmaxY = Math.max(maxY, landmark.y);\n\t\t\t}\n\n\t\t\tconst centerX = (minX + maxX) / 2;\n\t\t\tconst centerY = (minY + maxY) / 2;\n\t\t\treturn [centerX, centerY];\n\t\t}\n\n\t\tasync function updateMaskTexture(poses: NormalizedLandmark[][], segmentationMasks?: any[]) {\n\t\t\tif (!poseLandmarker) {\n\t\t\t\tconsole.warn('[Pose Plugin] Cannot update mask: poseLandmarker missing');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tposeMaskCtx.clearRect(0, 0, poseMaskCanvas.width, poseMaskCanvas.height);\n\n\t\t\t\t// Draw the segmentation masks.\n\t\t\t\tif (segmentationMasks && segmentationMasks.length > 0) {\n\t\t\t\t\tsegmentationMasks.forEach(mask => {\n\t\t\t\t\t\tif (!mask) return;\n\n\t\t\t\t\t\tconst { width, height } = mask;\n\t\t\t\t\t\tconst maskData = mask.getAsUint8Array();\n\t\t\t\t\t\tconst pixelCount = width * height;\n\t\t\t\t\t\tconst outputData = new Uint8ClampedArray(pixelCount * 4);\n\n\t\t\t\t\t\tfor (let i = 0; i < pixelCount; i++) {\n\t\t\t\t\t\t\toutputData[i * 4 + 1] = maskData[i]; // G (body mask)\n\t\t\t\t\t\t\toutputData[i * 4 + 3] = 255; // A (required for compositing)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rgbaMask = new ImageData(outputData, width, height);\n\n\t\t\t\t\t\t// Resize mask to canvas size if needed.\n\t\t\t\t\t\tif (width === poseMaskCanvas.width && height === poseMaskCanvas.height) {\n\t\t\t\t\t\t\tposeMaskCtx.putImageData(rgbaMask, 0, 0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (segmentationCanvas.width !== width) segmentationCanvas.width = width;\n\t\t\t\t\t\t\tif (segmentationCanvas.height !== height) segmentationCanvas.height = height;\n\t\t\t\t\t\t\tsegmentationCtx.putImageData(rgbaMask, 0, 0);\n\t\t\t\t\t\t\tposeMaskCtx.drawImage(\n\t\t\t\t\t\t\t\tsegmentationCanvas,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tposeMaskCanvas.width,\n\t\t\t\t\t\t\t\tposeMaskCanvas.height\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Draw the skeleton.\n\t\t\t\tif (poseConnections.length) {\n\t\t\t\t\tconst lineWidth = Math.max(2, poseMaskCanvas.width / 256);\n\t\t\t\t\tposeMaskCtx.lineWidth = lineWidth;\n\t\t\t\t\tposeMaskCtx.lineCap = 'round';\n\t\t\t\t\tposeMaskCtx.strokeStyle = '#00f';\n\n\t\t\t\t\tposes.forEach(landmarks => {\n\t\t\t\t\t\tposeConnections.forEach(({ start, end }) => {\n\t\t\t\t\t\t\tconst a = landmarks[start];\n\t\t\t\t\t\t\tconst b = landmarks[end];\n\t\t\t\t\t\t\tif (!a || !b) return;\n\t\t\t\t\t\t\tif ((a.visibility ?? 1) < 0.3 || (b.visibility ?? 1) < 0.3) return;\n\t\t\t\t\t\t\tposeMaskCtx.beginPath();\n\t\t\t\t\t\t\tposeMaskCtx.moveTo(a.x * poseMaskCanvas.width, a.y * poseMaskCanvas.height);\n\t\t\t\t\t\t\tposeMaskCtx.lineTo(b.x * poseMaskCanvas.width, b.y * poseMaskCanvas.height);\n\t\t\t\t\t\t\tposeMaskCtx.stroke();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tshaderPad.updateTextures({ u_poseMask: poseMaskCanvas });\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Pose Plugin] Failed to generate mask texture:', error);\n\t\t\t}\n\t\t}\n\n\t\tfunction processPoseResults(result: any) {\n\t\t\tif (!result.landmarks) return;\n\n\t\t\tupdateMaskTexture(result.landmarks, result.segmentationMasks).catch(error => {\n\t\t\t\tconsole.warn('[Pose Plugin] Mask texture update error:', error);\n\t\t\t});\n\n\t\t\tconst nPoses = result.landmarks.length;\n\t\t\tconst updates: Parameters<typeof shaderPad.updateUniforms>[0] = { u_nPoses: nPoses };\n\t\t\tif (nPoses) {\n\t\t\t\tupdates.u_poseLandmarks = result.landmarks.flatMap((landmarks: NormalizedLandmark[]) =>\n\t\t\t\t\tlandmarks.map(landmark => [landmark.x, 1.0 - landmark.y])\n\t\t\t\t);\n\n\t\t\t\tconst poseCenters: [number, number][] = [];\n\t\t\t\tfor (const landmarks of result.landmarks) {\n\t\t\t\t\tconst poseCenter = calculatePoseCenter(landmarks);\n\t\t\t\t\t// Invert Y-axis to match WebGL coordinate system.\n\t\t\t\t\tposeCenters.push([poseCenter[0], 1.0 - poseCenter[1]]);\n\t\t\t\t}\n\t\t\t\tupdates.u_poseCenter = poseCenters;\n\t\t\t}\n\t\t\tshaderPad.updateUniforms(updates);\n\t\t}\n\n\t\tshaderPad.registerHook('init', async () => {\n\t\t\tshaderPad.initializeTexture('u_poseMask', poseMaskCanvas);\n\t\t\tshaderPad.initializeUniform('u_maxPoses', 'int', maxPoses);\n\t\t\tshaderPad.initializeUniform('u_nPoses', 'int', 0);\n\t\t\tconst defaultPoseData: [number, number][] = Array.from({ length: maxPoses * LANDMARK_COUNT }, () => [\n\t\t\t\t0.5, 0.5,\n\t\t\t]);\n\t\t\tshaderPad.initializeUniform('u_poseLandmarks', 'float', defaultPoseData, {\n\t\t\t\tarrayLength: maxPoses * LANDMARK_COUNT,\n\t\t\t});\n\t\t\tconst defaultPoseCenterData: [number, number][] = Array.from({ length: maxPoses }, () => [0.5, 0.5]);\n\t\t\tshaderPad.initializeUniform('u_poseCenter', 'float', defaultPoseCenterData, {\n\t\t\t\tarrayLength: maxPoses,\n\t\t\t});\n\n\t\t\tawait initializePoseLandmarker();\n\t\t});\n\n\t\tshaderPad.registerHook('updateTextures', (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (!source) return;\n\n\t\t\tconst previousSource = textureSources.get(textureName);\n\t\t\tif (previousSource !== source) {\n\t\t\t\tlastVideoTime = -1;\n\t\t\t}\n\n\t\t\ttextureSources.set(textureName, source);\n\t\t\tif (!poseLandmarker) return;\n\t\t\ttry {\n\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (source.currentTime !== lastVideoTime) {\n\t\t\t\t\t\tlastVideoTime = source.currentTime;\n\t\t\t\t\t\tconst timestamp = performance.now();\n\t\t\t\t\t\tconst result = poseLandmarker.detectForVideo(source, timestamp);\n\t\t\t\t\t\tprocessPoseResults(result);\n\t\t\t\t\t}\n\t\t\t\t} else if (source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {\n\t\t\t\t\tif (source.width === 0 || source.height === 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst result = poseLandmarker.detect(source);\n\t\t\t\t\tprocessPoseResults(result);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Pose Plugin] Pose detection error:', error);\n\t\t\t}\n\t\t});\n\n\t\tshaderPad.registerHook('destroy', () => {\n\t\t\tif (poseLandmarker) {\n\t\t\t\tposeLandmarker.close();\n\t\t\t\tposeLandmarker = null;\n\t\t\t}\n\t\t\tvision = null;\n\t\t\ttextureSources.clear();\n\t\t\tposeMaskCanvas.remove();\n\t\t});\n\t\t// TODO: getBody and getSkeleton shouldn't rely on alpha. Do they? Seems so in the example...\n\t\tinjectGLSL(`\nuniform int u_maxPoses;\nuniform int u_nPoses;\nuniform vec2 u_poseLandmarks[${maxPoses * LANDMARK_COUNT}];\nuniform sampler2D u_poseMask;\nuniform vec2 u_poseCenter[${maxPoses}];\nvec2 poseLandmark(int poseIndex, int landmarkIndex) {\n\treturn u_poseLandmarks[poseIndex * ${LANDMARK_COUNT} + landmarkIndex];\n}\nfloat getBody(vec2 pos) { return texture(u_poseMask, pos).g; }\nfloat getSkeleton(vec2 pos) { return texture(u_poseMask, pos).b; }`);\n\t};\n}\n\nexport default pose;\n"],"mappings":"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","names":["LANDMARK_COUNT","pose","config","textureName","options","defaultModelPath","shaderPad","context","injectGLSL","poseLandmarker","vision","lastVideoTime","textureSources","maxPoses","maskWidth","maskHeight","poseMaskCanvas","poseMaskCtx","segmentationCanvas","segmentationCtx","poseConnections","initializePoseLandmarker","FilesetResolver","PoseLandmarker","error","calculatePoseCenter","landmarks","minX","maxX","minY","maxY","landmark","centerX","centerY","updateMaskTexture","poses","segmentationMasks","mask","width","height","maskData","pixelCount","outputData","i","rgbaMask","lineWidth","start","end","a","b","processPoseResults","result","nPoses","updates","poseCenters","poseCenter","defaultPoseData","defaultPoseCenterData","source","timestamp","pose_default"]}