{"version":3,"sources":["../../src/plugins/segmenter.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '../index';\nimport type { ImageSegmenter } from '@mediapipe/tasks-vision';\n\nexport interface SegmenterPluginOptions {\n\tmodelPath?: string;\n\toutputCategoryMask?: boolean;\n\toutputConfidenceMasks?: boolean;\n}\n\nfunction segmenter(config: { textureName: string; options?: SegmenterPluginOptions }) {\n\tconst { textureName, options } = config;\n\tconst defaultModelPath =\n\t\t'https://storage.googleapis.com/mediapipe-models/image_segmenter/hair_segmenter/float32/latest/hair_segmenter.tflite';\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL } = context;\n\n\t\tlet imageSegmenter: ImageSegmenter | null = null;\n\t\tlet vision: any = null;\n\t\tlet lastVideoTime = -1;\n\t\tlet runningMode: 'IMAGE' | 'VIDEO' = 'VIDEO';\n\t\tconst textureSources = new Map<string, TextureSource>();\n\t\tlet numCategories = 2;\n\n\t\tconst maskWidth = 512;\n\t\tconst maskHeight = 512;\n\t\tconst segmentMaskCanvas = document.createElement('canvas');\n\t\tsegmentMaskCanvas.width = maskWidth;\n\t\tsegmentMaskCanvas.height = maskHeight;\n\t\tconst segmentMaskCtx = segmentMaskCanvas.getContext('2d')!;\n\t\tsegmentMaskCtx.fillStyle = 'black';\n\t\tsegmentMaskCtx.fillRect(0, 0, maskWidth, maskHeight);\n\n\t\tasync function initializeImageSegmenter() {\n\t\t\ttry {\n\t\t\t\tconst { FilesetResolver, ImageSegmenter } = await import('@mediapipe/tasks-vision');\n\t\t\t\tvision = await FilesetResolver.forVisionTasks(\n\t\t\t\t\t'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'\n\t\t\t\t);\n\n\t\t\t\timageSegmenter = await ImageSegmenter.createFromOptions(vision, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options?.modelPath || defaultModelPath,\n\t\t\t\t\t},\n\t\t\t\t\trunningMode: runningMode,\n\t\t\t\t\toutputCategoryMask: options?.outputCategoryMask ?? true,\n\t\t\t\t\toutputConfidenceMasks: options?.outputConfidenceMasks ?? false,\n\t\t\t\t});\n\n\t\t\t\tconst labels = imageSegmenter.getLabels();\n\t\t\t\tnumCategories = labels ? labels.length : 2;\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Segmenter Plugin] Failed to initialize Image Segmenter:', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tasync function updateMaskTexture(segmentationMask: any) {\n\t\t\tif (!imageSegmenter || !segmentationMask) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tsegmentMaskCtx.clearRect(0, 0, segmentMaskCanvas.width, segmentMaskCanvas.height);\n\n\t\t\t\tconst width = segmentationMask.width;\n\t\t\t\tconst height = segmentationMask.height;\n\n\t\t\t\tlet maskData: Uint8Array | Float32Array;\n\t\t\t\tlet dataIsFloat = false;\n\n\t\t\t\tif (typeof segmentationMask.getAsUint8Array === 'function') {\n\t\t\t\t\tmaskData = segmentationMask.getAsUint8Array();\n\t\t\t\t} else if (typeof segmentationMask.getAsFloat32Array === 'function') {\n\t\t\t\t\tmaskData = segmentationMask.getAsFloat32Array();\n\t\t\t\t\tdataIsFloat = true;\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst pixelCount = width * height;\n\t\t\t\tconst outputData = new Uint8ClampedArray(pixelCount * 4);\n\t\t\t\tconst maxCategory = Math.max(1, numCategories - 1);\n\n\t\t\t\tfor (let i = 0; i < pixelCount; i++) {\n\t\t\t\t\tlet categoryValue: number;\n\t\t\t\t\tif (dataIsFloat) {\n\t\t\t\t\t\tcategoryValue = Math.round((maskData as Float32Array)[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcategoryValue = (maskData as Uint8Array)[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst normalizedValue = categoryValue / maxCategory;\n\t\t\t\t\tconst normalizedByte = Math.round(normalizedValue * 255);\n\n\t\t\t\t\toutputData[i * 4] = normalizedByte;\n\t\t\t\t\toutputData[i * 4 + 1] = 0;\n\t\t\t\t\toutputData[i * 4 + 2] = 0;\n\t\t\t\t\toutputData[i * 4 + 3] = 255;\n\t\t\t\t}\n\n\t\t\t\tconst rgbaMask = new ImageData(outputData, width, height);\n\n\t\t\t\tif (width !== segmentMaskCanvas.width || height !== segmentMaskCanvas.height) {\n\t\t\t\t\tconst tempCanvas = document.createElement('canvas');\n\t\t\t\t\ttempCanvas.width = width;\n\t\t\t\t\ttempCanvas.height = height;\n\t\t\t\t\tconst tempCtx = tempCanvas.getContext('2d')!;\n\t\t\t\t\ttempCtx.putImageData(rgbaMask, 0, 0);\n\n\t\t\t\t\tsegmentMaskCtx.drawImage(tempCanvas, 0, 0, segmentMaskCanvas.width, segmentMaskCanvas.height);\n\t\t\t\t} else {\n\t\t\t\t\tsegmentMaskCtx.putImageData(rgbaMask, 0, 0);\n\t\t\t\t}\n\n\t\t\t\tshaderPad.updateTextures({ u_segmentMask: segmentMaskCanvas });\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Segmenter Plugin] Failed to generate mask texture:', error);\n\t\t\t}\n\t\t}\n\n\t\tfunction processSegmenterResults(result: any) {\n\t\t\tconst mask = result.categoryMask || (result.confidenceMasks && result.confidenceMasks[0]);\n\n\t\t\tif (mask) {\n\t\t\t\tupdateMaskTexture(mask).catch(error => {\n\t\t\t\t\tconsole.warn('[Segmenter Plugin] Mask texture update error:', error);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfunction callbackForImage(result: any) {\n\t\t\tprocessSegmenterResults(result);\n\t\t}\n\n\t\tfunction callbackForVideo(result: any) {\n\t\t\tprocessSegmenterResults(result);\n\t\t}\n\n\t\tshaderPad.registerHook('init', async () => {\n\t\t\tshaderPad.initializeTexture('u_segmentMask', segmentMaskCanvas);\n\t\t\tawait initializeImageSegmenter();\n\t\t});\n\n\t\tshaderPad.registerHook('updateTextures', async (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (!source) return;\n\n\t\t\tconst previousSource = textureSources.get(textureName);\n\t\t\tif (previousSource !== source) {\n\t\t\t\tlastVideoTime = -1;\n\t\t\t}\n\n\t\t\ttextureSources.set(textureName, source);\n\t\t\tif (!imageSegmenter) return;\n\n\t\t\ttry {\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (runningMode !== requiredMode) {\n\t\t\t\t\trunningMode = requiredMode;\n\t\t\t\t\tawait imageSegmenter.setOptions({ runningMode: runningMode });\n\t\t\t\t}\n\n\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (source.currentTime !== lastVideoTime) {\n\t\t\t\t\t\tlastVideoTime = source.currentTime;\n\t\t\t\t\t\tconst timestamp = performance.now();\n\t\t\t\t\t\timageSegmenter.segmentForVideo(source, timestamp, callbackForVideo);\n\t\t\t\t\t}\n\t\t\t\t} else if (source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {\n\t\t\t\t\tif (source.width === 0 || source.height === 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\timageSegmenter.segment(source, callbackForImage);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Segmenter Plugin] Segmentation error:', error);\n\t\t\t}\n\t\t});\n\n\t\tshaderPad.registerHook('destroy', () => {\n\t\t\tif (imageSegmenter) {\n\t\t\t\timageSegmenter.close();\n\t\t\t\timageSegmenter = null;\n\t\t\t}\n\t\t\tvision = null;\n\t\t\ttextureSources.clear();\n\t\t\tsegmentMaskCanvas.remove();\n\t\t});\n\n\t\tinjectGLSL(`\nuniform sampler2D u_segmentMask;\nfloat inSegment(vec2 pos) { return texture(u_segmentMask, pos).r; }`);\n\t};\n}\n\nexport default segmenter;\n"],"mappings":"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","names":["segmenter_exports","__export","segmenter_default","__toCommonJS","segmenter","config","textureName","options","defaultModelPath","shaderPad","context","injectGLSL","imageSegmenter","vision","lastVideoTime","runningMode","textureSources","numCategories","maskWidth","maskHeight","segmentMaskCanvas","segmentMaskCtx","initializeImageSegmenter","FilesetResolver","ImageSegmenter","labels","error","updateMaskTexture","segmentationMask","width","height","maskData","dataIsFloat","pixelCount","outputData","maxCategory","i","categoryValue","normalizedValue","normalizedByte","rgbaMask","tempCanvas","processSegmenterResults","result","mask","callbackForImage","callbackForVideo","updates","source","requiredMode","timestamp"]}