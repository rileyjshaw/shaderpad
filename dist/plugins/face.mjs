var h=478,W=2,E=h+W,o={LEFT_EYEBROW:[336,296,334,293,300,276,283,282,295,285],LEFT_EYE:[362,398,384,385,386,387,388,466,263,249,390,373,374,380,381,382],LEFT_EYE_CENTER:473,RIGHT_EYEBROW:[70,63,105,66,107,55,65,52,53,46],RIGHT_EYE:[33,246,161,160,159,158,157,173,133,155,154,153,145,144,163,7],RIGHT_EYE_CENTER:468,NOSE_TIP:4,OUTER_LIP:[61,185,40,39,37,0,267,269,270,409,291,375,321,405,314,17,84,181,91,146],INNER_LIP:[78,191,80,81,82,13,312,311,310,415,308,324,318,402,317,14,87,178,88,95],FACE_CENTER:h,MOUTH_CENTER:h+1};function X(H){let{textureName:A,options:m}=H,Y="https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task";return function(s,P){let{injectGLSL:U,gl:C}=P,d=null,N=null,I=-1,M="VIDEO",b=new Map,y=m?.maxFaces??1,p=512,O=0,t=null,K=512,V=512,c=document.createElement("canvas");c.width=K,c.height=V;let T=c.getContext("2d");T.globalCompositeOperation="lighten";async function $(){try{let{FilesetResolver:n,FaceLandmarker:e}=await import("@mediapipe/tasks-vision");N=await n.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"),d=await e.createFromOptions(N,{baseOptions:{modelAssetPath:m?.modelPath||Y},runningMode:M,numFaces:m?.maxFaces??1,minFaceDetectionConfidence:m?.minFaceDetectionConfidence??.5,minFacePresenceConfidence:m?.minFacePresenceConfidence??.5,minTrackingConfidence:m?.minTrackingConfidence??.5,outputFaceBlendshapes:m?.outputFaceBlendshapes??!1,outputFacialTransformationMatrixes:m?.outputFacialTransformationMatrixes??!1})}catch(n){throw console.error("Failed to initialize Face Landmarker:",n),n}}function S(n,e,a){let i=1/0,r=-1/0,f=1/0,u=-1/0,l=0,x=0;for(let G of a){let k=(e*E+G)*4,D=n[k],w=n[k+1];i=Math.min(i,D),r=Math.max(r,D),f=Math.min(f,w),u=Math.max(u,w),l+=n[k+2],x+=n[k+3]}let F=(i+r)/2,L=(f+u)/2,g=l/a.length,R=x/a.length;return[F,L,g,R]}function _(n,e,a){if(!t)return;T.fillStyle=`rgb(${Math.round(a.r*255)}, ${Math.round(a.g*255)}, ${Math.round(a.b*255)})`,T.beginPath();let i=(n*E+e[0])*4,r=t[i],f=t[i+1];T.moveTo(r*c.width,f*c.height);for(let u=1;u<e.length;++u){let l=(n*E+e[u])*4,x=t[l],F=t[l+1];T.lineTo(x*c.width,F*c.height)}T.closePath(),T.fill()}async function z(n){if(!d||!t){console.warn("[Face Plugin] Cannot update mask: faceLandmarker or landmarksDataArray missing");return}try{let{FaceLandmarker:e}=await import("@mediapipe/tasks-vision");T.clearRect(0,0,c.width,c.height);for(let a=0;a<n;++a)_(a,o.OUTER_LIP,{r:.25,g:0,b:0}),_(a,o.INNER_LIP,{r:.75,g:0,b:0}),_(a,e.FACE_LANDMARKS_TESSELATION.map(({start:i})=>i),{r:0,g:.25,b:0}),_(a,e.FACE_LANDMARKS_FACE_OVAL.map(({start:i})=>i),{r:0,g:1,b:0}),_(a,o.LEFT_EYEBROW,{r:0,g:0,b:.15}),_(a,o.RIGHT_EYEBROW,{r:0,g:0,b:.35}),_(a,o.LEFT_EYE,{r:0,g:0,b:.65}),_(a,o.RIGHT_EYE,{r:0,g:0,b:.85});s.updateTextures({u_faceMask:c})}catch(e){console.error("[Face Plugin] Failed to generate mask texture:",e)}}function B(n){if(!t)return;let e=n.length,a=e*E;for(let r=0;r<e;++r){let f=n[r];for(let L=0;L<h;++L){let g=f[L],R=(r*E+L)*4;t[R]=g.x,t[R+1]=1-g.y,t[R+2]=g.z??0,t[R+3]=g.visibility??1}let u=S(t,r,Array.from({length:h},(L,g)=>g)),l=(r*E+o.FACE_CENTER)*4;t[l]=u[0],t[l+1]=u[1],t[l+2]=0,t[l+3]=1;let x=S(t,r,o.INNER_LIP),F=(r*E+o.MOUTH_CENTER)*4;t[F]=x[0],t[F+1]=x[1],t[F+2]=0,t[F+3]=1}let i=Math.ceil(a/p);s.updateTextures({u_faceLandmarksTex:{data:t,width:p,height:i}})}function v(n){if(!n.faceLandmarks||!t)return;let e=n.faceLandmarks.length;B(n.faceLandmarks),z(e).catch(a=>{console.warn("Mask texture update error:",a)}),s.updateUniforms({u_nFaces:e}),m?.onResults?.(n)}s.registerHook("init",async()=>{s.initializeTexture("u_faceMask",c,{preserveY:!0}),s.initializeUniform("u_maxFaces","int",y),s.initializeUniform("u_nFaces","int",0);let n=y*E;O=Math.ceil(n/p);let e=p*O*4;t=new Float32Array(e),s.initializeTexture("u_faceLandmarksTex",{data:t,width:p,height:O},{internalFormat:C.RGBA32F,type:C.FLOAT,minFilter:C.NEAREST,magFilter:C.NEAREST}),await $()}),s.registerHook("updateTextures",async n=>{let e=n[A];if(!(!e||(b.get(A)!==e&&(I=-1),b.set(A,e),!d)))try{let i=e instanceof HTMLVideoElement?"VIDEO":"IMAGE";if(M!==i&&(M=i,await d.setOptions({runningMode:M})),e instanceof HTMLVideoElement){if(e.videoWidth===0||e.videoHeight===0||e.readyState<2)return;if(e.currentTime!==I){I=e.currentTime;let r=performance.now(),f=d.detectForVideo(e,r);v(f)}}else if(e instanceof HTMLImageElement||e instanceof HTMLCanvasElement){if(e.width===0||e.height===0)return;let r=d.detect(e);v(r)}}catch(i){console.warn("Face detection error:",i)}}),s.registerHook("destroy",()=>{d&&(d.close(),d=null),N=null,b.clear(),c.remove(),t=null}),U(`
uniform int u_maxFaces;
uniform int u_nFaces;
uniform sampler2D u_faceLandmarksTex;
uniform sampler2D u_faceMask;

#define FACE_LANDMARK_L_EYE_CENTER ${o.LEFT_EYE_CENTER}
#define FACE_LANDMARK_R_EYE_CENTER ${o.RIGHT_EYE_CENTER}
#define FACE_LANDMARK_NOSE_TIP ${o.NOSE_TIP}
#define FACE_LANDMARK_FACE_CENTER ${o.FACE_CENTER}
#define FACE_LANDMARK_MOUTH_CENTER ${o.MOUTH_CENTER}

vec4 faceLandmark(int faceIndex, int landmarkIndex) {
	int i = faceIndex * ${E} + landmarkIndex;
	int x = i % ${p};
	int y = i / ${p};
	return texelFetch(u_faceLandmarksTex, ivec2(x, y), 0);
}
float inFace(vec2 pos) { return texture(u_faceMask, pos).g; }
float inEye(vec2 pos) { return texture(u_faceMask, pos).b; }
float inMouth(vec2 pos) { return texture(u_faceMask, pos).r; }`)}}var j=X;export{j as default};
//# sourceMappingURL=face.mjs.map