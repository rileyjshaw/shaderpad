{"version":3,"sources":["../../src/plugins/face.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '../index';\nimport type { FaceLandmarker, FaceLandmarkerResult, NormalizedLandmark } from '@mediapipe/tasks-vision';\n\nexport interface FacePluginOptions {\n\tmodelPath?: string;\n\tmaxFaces?: number;\n\tminFaceDetectionConfidence?: number;\n\tminFacePresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\toutputFaceBlendshapes?: boolean;\n\toutputFacialTransformationMatrixes?: boolean;\n\tonReady?: () => void;\n\tonResults?: (results: FaceLandmarkerResult) => void;\n}\n\nconst STANDARD_LANDMARK_COUNT = 478;\nconst CUSTOM_LANDMARK_COUNT = 2;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst LANDMARKS_TEXTURE_WIDTH = 512;\n\nconst LEFT_EYEBROW_INDICES = [336, 296, 334, 293, 300, 276, 283, 282, 295, 285] as const;\nconst LEFT_EYE_INDICES = [362, 398, 384, 385, 386, 387, 388, 466, 263, 249, 390, 373, 374, 380, 381, 382] as const;\nconst RIGHT_EYEBROW_INDICES = [70, 63, 105, 66, 107, 55, 65, 52, 53, 46] as const;\nconst RIGHT_EYE_INDICES = [33, 246, 161, 160, 159, 158, 157, 173, 133, 155, 154, 153, 145, 144, 163, 7] as const;\nconst OUTER_MOUTH_INDICES = [\n\t61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146,\n] as const;\nconst INNER_MOUTH_INDICES = [\n\t78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308, 324, 318, 402, 317, 14, 87, 178, 88, 95,\n] as const;\nconst ALL_STANDARD_INDICES = Array.from({ length: STANDARD_LANDMARK_COUNT }, (_, i) => i);\nconst LANDMARK_INDICES = {\n\tLEFT_EYEBROW: LEFT_EYEBROW_INDICES,\n\tLEFT_EYE: LEFT_EYE_INDICES,\n\tLEFT_EYE_CENTER: 473,\n\tRIGHT_EYEBROW: RIGHT_EYEBROW_INDICES,\n\tRIGHT_EYE: RIGHT_EYE_INDICES,\n\tRIGHT_EYE_CENTER: 468,\n\tNOSE_TIP: 4,\n\tOUTER_MOUTH: OUTER_MOUTH_INDICES,\n\tINNER_MOUTH: INNER_MOUTH_INDICES,\n\t// Custom landmarks.\n\tFACE_CENTER: STANDARD_LANDMARK_COUNT,\n\tMOUTH_CENTER: STANDARD_LANDMARK_COUNT + 1,\n};\n\nconst REGION_NAMES = [\n\t'BACKGROUND',\n\t'LEFT_EYEBROW',\n\t'RIGHT_EYEBROW',\n\t'LEFT_EYE',\n\t'RIGHT_EYE',\n\t'OUTER_MOUTH',\n\t'INNER_MOUTH',\n] as const;\nconst nFaceRegions = REGION_NAMES.length - 1;\nconst RED_CHANNEL_VALUES = Object.fromEntries(REGION_NAMES.map((name, i) => [name, i / nFaceRegions])) as Record<\n\t(typeof REGION_NAMES)[number],\n\tnumber\n>;\nconst HALF_GAP = 0.5 / nFaceRegions;\n\nfunction fanTriangulate(indices: readonly number[]): number[] {\n\tconst tris: number[] = [];\n\tfor (let i = 1; i < indices.length - 1; ++i) {\n\t\ttris.push(indices[0], indices[i], indices[i + 1]);\n\t}\n\treturn tris;\n}\n\nfunction face(config: { textureName: string; options?: FacePluginOptions }) {\n\tconst { textureName, options } = config;\n\tconst defaultModelPath =\n\t\t'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task';\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, gl } = context;\n\n\t\tlet faceLandmarker: FaceLandmarker | null = null;\n\t\tlet vision: any = null;\n\t\tlet lastVideoTime = -1;\n\t\tlet runningMode: 'IMAGE' | 'VIDEO' = 'VIDEO';\n\t\tconst textureSources = new Map<string, TextureSource>();\n\t\tconst maxFaces = options?.maxFaces ?? 1;\n\n\t\tlet landmarksTextureHeight = 0;\n\t\tlet landmarksDataArray: Float32Array | null = null;\n\n\t\tconst mediaPipeCanvas = new OffscreenCanvas(1, 1);\n\t\tconst maskCanvas = new OffscreenCanvas(1, 1);\n\n\t\t// WebGL resources for triangle rendering (no antialiasing).\n\t\tlet maskGl: WebGL2RenderingContext | null = null;\n\t\tlet maskProgram: WebGLProgram | null = null;\n\t\tlet positionBuffer: WebGLBuffer | null = null;\n\t\tlet colorLocation: WebGLUniformLocation | null = null;\n\n\t\tconst regionTriangles: Record<string, number[]> = {\n\t\t\tLEFT_EYEBROW: fanTriangulate(LEFT_EYEBROW_INDICES),\n\t\t\tRIGHT_EYEBROW: fanTriangulate(RIGHT_EYEBROW_INDICES),\n\t\t\tLEFT_EYE: fanTriangulate(LEFT_EYE_INDICES),\n\t\t\tRIGHT_EYE: fanTriangulate(RIGHT_EYE_INDICES),\n\t\t\tOUTER_MOUTH: fanTriangulate(OUTER_MOUTH_INDICES),\n\t\t\tINNER_MOUTH: fanTriangulate(INNER_MOUTH_INDICES),\n\t\t\t// Populated after FaceLandmarker loads.\n\t\t\tTESSELATION: [],\n\t\t\tOVAL: [],\n\t\t};\n\n\t\tfunction initMaskRenderer() {\n\t\t\tmaskGl = maskCanvas.getContext('webgl2', { antialias: false, preserveDrawingBuffer: true });\n\t\t\tif (!maskGl) throw new Error('Failed to get WebGL2 context for mask');\n\n\t\t\tconst vertexShader = maskGl.createShader(maskGl.VERTEX_SHADER)!;\n\t\t\tmaskGl.shaderSource(\n\t\t\t\tvertexShader,\n\t\t\t\t`#version 300 es\nin vec2 a_pos;\nvoid main() {\n\tgl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n}`\n\t\t\t);\n\t\t\tmaskGl.compileShader(vertexShader);\n\n\t\t\tconst fragmentShader = maskGl.createShader(maskGl.FRAGMENT_SHADER)!;\n\t\t\tmaskGl.shaderSource(\n\t\t\t\tfragmentShader,\n\t\t\t\t`#version 300 es\nprecision mediump float;\nuniform vec4 u_color;\nout vec4 outColor;\nvoid main() { outColor = u_color; }`\n\t\t\t);\n\t\t\tmaskGl.compileShader(fragmentShader);\n\n\t\t\tmaskProgram = maskGl.createProgram()!;\n\t\t\tmaskGl.attachShader(maskProgram, vertexShader);\n\t\t\tmaskGl.attachShader(maskProgram, fragmentShader);\n\t\t\tmaskGl.linkProgram(maskProgram);\n\t\t\tmaskGl.deleteShader(vertexShader);\n\t\t\tmaskGl.deleteShader(fragmentShader);\n\n\t\t\tpositionBuffer = maskGl.createBuffer();\n\t\t\tmaskGl.bindBuffer(maskGl.ARRAY_BUFFER, positionBuffer);\n\t\t\tconst positionLocation = maskGl.getAttribLocation(maskProgram, 'a_pos');\n\t\t\tmaskGl.enableVertexAttribArray(positionLocation);\n\t\t\tmaskGl.vertexAttribPointer(positionLocation, 2, maskGl.FLOAT, false, 0, 0);\n\n\t\t\tcolorLocation = maskGl.getUniformLocation(maskProgram, 'u_color');\n\t\t\tmaskGl.useProgram(maskProgram);\n\n\t\t\t// Enable blending to handle overlapping faces (set once, never disabled).\n\t\t\tmaskGl.enable(maskGl.BLEND);\n\t\t\tmaskGl.blendEquation(maskGl.MAX);\n\t\t}\n\n\t\tfunction drawTriangles(triangleIndices: number[], faceIdx: number, r: number, g: number, b: number) {\n\t\t\tif (!maskGl || !landmarksDataArray || triangleIndices.length === 0) return;\n\n\t\t\tconst vertices = new Float32Array(triangleIndices.length * 2);\n\t\t\tfor (let i = 0; i < triangleIndices.length; ++i) {\n\t\t\t\tconst landmarkIdx = (faceIdx * LANDMARK_COUNT + triangleIndices[i]) * 4;\n\t\t\t\tvertices[i * 2] = landmarksDataArray[landmarkIdx];\n\t\t\t\tvertices[i * 2 + 1] = landmarksDataArray[landmarkIdx + 1];\n\t\t\t}\n\n\t\t\tmaskGl.bufferData(maskGl.ARRAY_BUFFER, vertices, maskGl.DYNAMIC_DRAW);\n\t\t\tmaskGl.uniform4f(colorLocation, r, g, b, 1.0);\n\t\t\tmaskGl.drawArrays(maskGl.TRIANGLES, 0, triangleIndices.length);\n\t\t}\n\n\t\tasync function initializeFaceLandmarker() {\n\t\t\ttry {\n\t\t\t\tconst { FilesetResolver, FaceLandmarker } = await import('@mediapipe/tasks-vision');\n\t\t\t\tvision = await FilesetResolver.forVisionTasks(\n\t\t\t\t\t'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'\n\t\t\t\t);\n\n\t\t\t\tfaceLandmarker = await FaceLandmarker.createFromOptions(vision, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options?.modelPath || defaultModelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: mediaPipeCanvas,\n\t\t\t\t\trunningMode: runningMode,\n\t\t\t\t\tnumFaces: options?.maxFaces ?? 1,\n\t\t\t\t\tminFaceDetectionConfidence: options?.minFaceDetectionConfidence ?? 0.5,\n\t\t\t\t\tminFacePresenceConfidence: options?.minFacePresenceConfidence ?? 0.5,\n\t\t\t\t\tminTrackingConfidence: options?.minTrackingConfidence ?? 0.5,\n\t\t\t\t\toutputFaceBlendshapes: options?.outputFaceBlendshapes ?? false,\n\t\t\t\t\toutputFacialTransformationMatrixes: options?.outputFacialTransformationMatrixes ?? false,\n\t\t\t\t});\n\n\t\t\t\tconst tesselationConnections = FaceLandmarker.FACE_LANDMARKS_TESSELATION;\n\t\t\t\tregionTriangles.TESSELATION = [];\n\t\t\t\tfor (let i = 0; i < tesselationConnections.length - 2; i += 3) {\n\t\t\t\t\tregionTriangles.TESSELATION.push(\n\t\t\t\t\t\ttesselationConnections[i].start,\n\t\t\t\t\t\ttesselationConnections[i + 1].start,\n\t\t\t\t\t\ttesselationConnections[i + 2].start\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst ovalIndices = FaceLandmarker.FACE_LANDMARKS_FACE_OVAL.map(({ start }) => start);\n\t\t\t\tregionTriangles.OVAL = fanTriangulate(ovalIndices);\n\n\t\t\t\tinitMaskRenderer();\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Face Plugin] Failed to initialize:', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tfunction calculateBoundingBoxCenter(\n\t\t\tdata: Float32Array,\n\t\t\tfaceIdx: number,\n\t\t\tindices: readonly number[] | number[]\n\t\t): [number, number, number, number] {\n\t\t\tlet minX = Infinity,\n\t\t\t\tmaxX = -Infinity,\n\t\t\t\tminY = Infinity,\n\t\t\t\tmaxY = -Infinity,\n\t\t\t\tavgZ = 0,\n\t\t\t\tavgVisibility = 0;\n\n\t\t\tfor (const idx of indices) {\n\t\t\t\tconst i = (faceIdx * LANDMARK_COUNT + idx) * 4;\n\t\t\t\tconst x = data[i],\n\t\t\t\t\ty = data[i + 1];\n\t\t\t\tminX = Math.min(minX, x);\n\t\t\t\tmaxX = Math.max(maxX, x);\n\t\t\t\tminY = Math.min(minY, y);\n\t\t\t\tmaxY = Math.max(maxY, y);\n\t\t\t\tavgZ += data[i + 2];\n\t\t\t\tavgVisibility += data[i + 3];\n\t\t\t}\n\t\t\treturn [(minX + maxX) / 2, (minY + maxY) / 2, avgZ / indices.length, avgVisibility / indices.length];\n\t\t}\n\n\t\tfunction updateLandmarksTexture(faces: NormalizedLandmark[][]) {\n\t\t\tif (!landmarksDataArray) return;\n\n\t\t\tconst nFaces = faces.length;\n\t\t\tconst totalLandmarks = nFaces * LANDMARK_COUNT;\n\n\t\t\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\t\t\tconst landmarks = faces[faceIdx];\n\t\t\t\tfor (let landmarkIdx = 0; landmarkIdx < STANDARD_LANDMARK_COUNT; ++landmarkIdx) {\n\t\t\t\t\tconst landmark = landmarks[landmarkIdx];\n\t\t\t\t\tconst dataIdx = (faceIdx * LANDMARK_COUNT + landmarkIdx) * 4;\n\t\t\t\t\tlandmarksDataArray[dataIdx] = landmark.x;\n\t\t\t\t\tlandmarksDataArray[dataIdx + 1] = 1 - landmark.y;\n\t\t\t\t\tlandmarksDataArray[dataIdx + 2] = landmark.z ?? 0;\n\t\t\t\t\tlandmarksDataArray[dataIdx + 3] = landmark.visibility ?? 1;\n\t\t\t\t}\n\n\t\t\t\tconst faceCenter = calculateBoundingBoxCenter(landmarksDataArray, faceIdx, ALL_STANDARD_INDICES);\n\t\t\t\tlandmarksDataArray.set(faceCenter, (faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.FACE_CENTER) * 4);\n\n\t\t\t\tconst mouthCenter = calculateBoundingBoxCenter(landmarksDataArray, faceIdx, INNER_MOUTH_INDICES);\n\t\t\t\tlandmarksDataArray.set(mouthCenter, (faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.MOUTH_CENTER) * 4);\n\t\t\t}\n\n\t\t\tconst rowsToUpdate = Math.ceil(totalLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures({\n\t\t\t\tu_faceLandmarksTex: {\n\t\t\t\t\tdata: landmarksDataArray,\n\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t\tisPartial: true,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tfunction updateMaskTexture(nFaces: number) {\n\t\t\tif (!maskGl || !landmarksDataArray) return;\n\n\t\t\t// Resize and clear.\n\t\t\tmaskCanvas.width = mediaPipeCanvas.width;\n\t\t\tmaskCanvas.height = mediaPipeCanvas.height;\n\t\t\tmaskGl.viewport(0, 0, maskCanvas.width, maskCanvas.height);\n\t\t\tmaskGl.clearColor(0, 0, 0, 0);\n\t\t\tmaskGl.clear(maskGl.COLOR_BUFFER_BIT);\n\n\t\t\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\t\t\tconst b = (faceIdx + 1) / maxFaces;\n\n\t\t\t\t// G channel: face mesh (0.5) and oval (1.0)\n\t\t\t\tdrawTriangles(regionTriangles.TESSELATION, faceIdx, 0, 0.5, b);\n\t\t\t\tdrawTriangles(regionTriangles.OVAL, faceIdx, 0, 1.0, b);\n\n\t\t\t\t// R channel: feature regions\n\t\t\t\tdrawTriangles(regionTriangles.LEFT_EYEBROW, faceIdx, RED_CHANNEL_VALUES.LEFT_EYEBROW, 0, b);\n\t\t\t\tdrawTriangles(regionTriangles.RIGHT_EYEBROW, faceIdx, RED_CHANNEL_VALUES.RIGHT_EYEBROW, 0, b);\n\t\t\t\tdrawTriangles(regionTriangles.LEFT_EYE, faceIdx, RED_CHANNEL_VALUES.LEFT_EYE, 0, b);\n\t\t\t\tdrawTriangles(regionTriangles.RIGHT_EYE, faceIdx, RED_CHANNEL_VALUES.RIGHT_EYE, 0, b);\n\t\t\t\tdrawTriangles(regionTriangles.OUTER_MOUTH, faceIdx, RED_CHANNEL_VALUES.OUTER_MOUTH, 0, b);\n\t\t\t\tdrawTriangles(regionTriangles.INNER_MOUTH, faceIdx, RED_CHANNEL_VALUES.INNER_MOUTH, 0, b);\n\t\t\t}\n\n\t\t\tshaderPad.updateTextures({ u_faceMask: maskCanvas });\n\t\t}\n\n\t\tfunction processFaceResults(result: FaceLandmarkerResult) {\n\t\t\tif (!result.faceLandmarks || !landmarksDataArray) return;\n\n\t\t\tconst nFaces = result.faceLandmarks.length;\n\t\t\tupdateLandmarksTexture(result.faceLandmarks);\n\t\t\tupdateMaskTexture(nFaces);\n\t\t\tshaderPad.updateUniforms({ u_nFaces: nFaces });\n\n\t\t\toptions?.onResults?.(result);\n\t\t}\n\n\t\tasync function detectFaces(source: TextureSource) {\n\t\t\tconst previousSource = textureSources.get(textureName);\n\t\t\tif (previousSource !== source) lastVideoTime = -1;\n\t\t\ttextureSources.set(textureName, source);\n\t\t\tif (!faceLandmarker) return;\n\n\t\t\ttry {\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (runningMode !== requiredMode) {\n\t\t\t\t\trunningMode = requiredMode;\n\t\t\t\t\tawait faceLandmarker.setOptions({ runningMode });\n\t\t\t\t}\n\n\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\tif (source.currentTime !== lastVideoTime) {\n\t\t\t\t\t\tlastVideoTime = source.currentTime;\n\t\t\t\t\t\tprocessFaceResults(faceLandmarker.detectForVideo(source, performance.now()));\n\t\t\t\t\t}\n\t\t\t\t} else if (source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {\n\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\tprocessFaceResults(faceLandmarker.detect(source));\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Face Plugin] Detection error:', error);\n\t\t\t}\n\t\t}\n\n\t\tshaderPad.registerHook('init', async () => {\n\t\t\tshaderPad.initializeTexture('u_faceMask', maskCanvas, {\n\t\t\t\tminFilter: gl.NEAREST,\n\t\t\t\tmagFilter: gl.NEAREST,\n\t\t\t});\n\t\t\tshaderPad.initializeUniform('u_maxFaces', 'int', maxFaces);\n\t\t\tshaderPad.initializeUniform('u_nFaces', 'int', 0);\n\n\t\t\tconst totalLandmarks = maxFaces * LANDMARK_COUNT;\n\t\t\tlandmarksTextureHeight = Math.ceil(totalLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tlandmarksDataArray = new Float32Array(LANDMARKS_TEXTURE_WIDTH * landmarksTextureHeight * 4);\n\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_faceLandmarksTex',\n\t\t\t\t{ data: landmarksDataArray, width: LANDMARKS_TEXTURE_WIDTH, height: landmarksTextureHeight },\n\t\t\t\t{ internalFormat: gl.RGBA32F, type: gl.FLOAT, minFilter: gl.NEAREST, magFilter: gl.NEAREST }\n\t\t\t);\n\n\t\t\tawait initializeFaceLandmarker();\n\t\t\toptions?.onReady?.();\n\t\t});\n\n\t\tshaderPad.registerHook('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName) detectFaces(source);\n\t\t});\n\n\t\tshaderPad.registerHook('updateTextures', (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (source) detectFaces(source);\n\t\t});\n\n\t\tshaderPad.registerHook('destroy', () => {\n\t\t\tfaceLandmarker?.close();\n\t\t\tfaceLandmarker = null;\n\t\t\tif (maskGl && maskProgram) {\n\t\t\t\tmaskGl.deleteProgram(maskProgram);\n\t\t\t\tmaskGl.deleteBuffer(positionBuffer);\n\t\t\t}\n\t\t\tmaskGl = null;\n\t\t\tmaskProgram = null;\n\t\t\tvision = null;\n\t\t\ttextureSources.clear();\n\t\t\tlandmarksDataArray = null;\n\t\t});\n\n\t\tconst checkAt = (\n\t\t\tregionMin: keyof typeof RED_CHANNEL_VALUES,\n\t\t\tregionMax: keyof typeof RED_CHANNEL_VALUES = regionMin\n\t\t) =>\n\t\t\t`vec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn (mask.r > ${(RED_CHANNEL_VALUES[regionMin] - HALF_GAP).toFixed(4)} && mask.r < ${(\n\t\t\t\tRED_CHANNEL_VALUES[regionMax] + HALF_GAP\n\t\t\t).toFixed(4)}) ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);`;\n\n\t\tinjectGLSL(`\nuniform int u_maxFaces;\nuniform int u_nFaces;\nuniform sampler2D u_faceLandmarksTex;\nuniform sampler2D u_faceMask;\n\n#define FACE_LANDMARK_L_EYE_CENTER ${LANDMARK_INDICES.LEFT_EYE_CENTER}\n#define FACE_LANDMARK_R_EYE_CENTER ${LANDMARK_INDICES.RIGHT_EYE_CENTER}\n#define FACE_LANDMARK_NOSE_TIP ${LANDMARK_INDICES.NOSE_TIP}\n#define FACE_LANDMARK_FACE_CENTER ${LANDMARK_INDICES.FACE_CENTER}\n#define FACE_LANDMARK_MOUTH_CENTER ${LANDMARK_INDICES.MOUTH_CENTER}\n\nvec4 faceLandmark(int faceIndex, int landmarkIndex) {\n\tint i = faceIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};\n\treturn texelFetch(u_faceLandmarksTex, ivec2(x, y), 0);\n}\n\nvec2 leftEyebrowAt(vec2 pos) {\n\t${checkAt('LEFT_EYEBROW')}\n}\n\nvec2 rightEyebrowAt(vec2 pos) {\n\t${checkAt('RIGHT_EYEBROW')}\n}\n\nvec2 leftEyeAt(vec2 pos) {\n\t${checkAt('LEFT_EYE')}\n}\n\nvec2 rightEyeAt(vec2 pos) {\n\t${checkAt('RIGHT_EYE')}\n}\n\nvec2 lipsAt(vec2 pos) {\n\t${checkAt('OUTER_MOUTH')}\n}\n\nvec2 outerMouthAt(vec2 pos) {\n\t${checkAt('OUTER_MOUTH', 'INNER_MOUTH')}\n}\n\nvec2 innerMouthAt(vec2 pos) {\n\t${checkAt('INNER_MOUTH')}\n}\n\nvec2 faceOvalAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn mask.g > 0.75 ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);\n}\n\n// Includes face mesh and oval.\nvec2 faceAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn mask.g > 0.25 ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);\n}\n\nvec2 eyeAt(vec2 pos) {\n\tvec2 left = leftEyeAt(pos);\n\treturn left.x > 0.0 ? left : rightEyeAt(pos);\n}\n\nvec2 eyebrowAt(vec2 pos) {\n\tvec2 left = leftEyebrowAt(pos);\n\treturn left.x > 0.0 ? left : rightEyebrowAt(pos);\n}\n\nfloat inEyebrow(vec2 pos) { return eyebrowAt(pos).x; }\nfloat inEye(vec2 pos) { return eyeAt(pos).x; }\nfloat inOuterMouth(vec2 pos) { return outerMouthAt(pos).x; }\nfloat inInnerMouth(vec2 pos) { return innerMouthAt(pos).x; }\nfloat inLips(vec2 pos) { return lipsAt(pos).x; }\nfloat inFace(vec2 pos) { return faceAt(pos).x; }`);\n\t};\n}\n\nexport default face;\n"],"mappings":"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","names":["face_exports","__export","face_default","__toCommonJS","STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","LANDMARKS_TEXTURE_WIDTH","LEFT_EYEBROW_INDICES","LEFT_EYE_INDICES","RIGHT_EYEBROW_INDICES","RIGHT_EYE_INDICES","OUTER_MOUTH_INDICES","INNER_MOUTH_INDICES","ALL_STANDARD_INDICES","_","LANDMARK_INDICES","REGION_NAMES","nFaceRegions","RED_CHANNEL_VALUES","name","HALF_GAP","fanTriangulate","indices","tris","i","face","config","textureName","options","defaultModelPath","shaderPad","context","injectGLSL","gl","faceLandmarker","vision","lastVideoTime","runningMode","textureSources","maxFaces","landmarksTextureHeight","landmarksDataArray","mediaPipeCanvas","maskCanvas","maskGl","maskProgram","positionBuffer","colorLocation","regionTriangles","initMaskRenderer","vertexShader","fragmentShader","positionLocation","drawTriangles","triangleIndices","faceIdx","r","g","b","vertices","landmarkIdx","initializeFaceLandmarker","FilesetResolver","FaceLandmarker","tesselationConnections","ovalIndices","start","error","calculateBoundingBoxCenter","data","minX","maxX","minY","maxY","avgZ","avgVisibility","idx","x","y","updateLandmarksTexture","faces","nFaces","totalLandmarks","landmarks","landmark","dataIdx","faceCenter","mouthCenter","rowsToUpdate","updateMaskTexture","processFaceResults","result","detectFaces","source","requiredMode","updates","checkAt","regionMin","regionMax"]}