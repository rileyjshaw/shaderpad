{"version":3,"sources":["../../src/plugins/face.ts","../../src/plugins/mediapipe-common.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tcalculateBoundingBoxCenter,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { FaceLandmarker, FaceLandmarkerResult, NormalizedLandmark } from '@mediapipe/tasks-vision';\n\nexport interface FacePluginOptions {\n\tmodelPath?: string;\n\tmaxFaces?: number;\n\tminFaceDetectionConfidence?: number;\n\tminFacePresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\toutputFaceBlendshapes?: boolean;\n\toutputFacialTransformationMatrixes?: boolean;\n}\n\nconst MASK_VERTEX_SHADER = `#version 300 es\nin vec2 a_pos;\nvoid main() { gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0); }`;\nconst MASK_FRAGMENT_SHADER = `#version 300 es\nprecision mediump float;\nuniform vec4 u_color;\nout vec4 outColor;\nvoid main() { outColor = u_color; }`;\n\nconst STANDARD_LANDMARK_COUNT = 478;\nconst CUSTOM_LANDMARK_COUNT = 2;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst LANDMARKS_TEXTURE_WIDTH = 512;\n\nconst LEFT_EYEBROW_INDICES = [336, 296, 334, 293, 300, 276, 283, 282, 295, 285] as const;\nconst LEFT_EYE_INDICES = [362, 398, 384, 385, 386, 387, 388, 466, 263, 249, 390, 373, 374, 380, 381, 382] as const;\nconst RIGHT_EYEBROW_INDICES = [70, 63, 105, 66, 107, 55, 65, 52, 53, 46] as const;\nconst RIGHT_EYE_INDICES = [33, 246, 161, 160, 159, 158, 157, 173, 133, 155, 154, 153, 145, 144, 163, 7] as const;\nconst OUTER_MOUTH_INDICES = [\n\t61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146,\n] as const;\nconst INNER_MOUTH_INDICES = [\n\t78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308, 324, 318, 402, 317, 14, 87, 178, 88, 95,\n] as const;\nconst ALL_STANDARD_INDICES = Array.from({ length: STANDARD_LANDMARK_COUNT }, (_, i) => i);\nconst LANDMARK_INDICES = {\n\tLEFT_EYEBROW: LEFT_EYEBROW_INDICES,\n\tLEFT_EYE: LEFT_EYE_INDICES,\n\tLEFT_EYE_CENTER: 473,\n\tRIGHT_EYEBROW: RIGHT_EYEBROW_INDICES,\n\tRIGHT_EYE: RIGHT_EYE_INDICES,\n\tRIGHT_EYE_CENTER: 468,\n\tNOSE_TIP: 4,\n\tOUTER_MOUTH: OUTER_MOUTH_INDICES,\n\tINNER_MOUTH: INNER_MOUTH_INDICES,\n\t// Custom landmarks.\n\tFACE_CENTER: STANDARD_LANDMARK_COUNT,\n\tMOUTH_CENTER: STANDARD_LANDMARK_COUNT + 1,\n};\n\nconst REGION_NAMES = [\n\t'BACKGROUND',\n\t'LEFT_EYEBROW',\n\t'RIGHT_EYEBROW',\n\t'LEFT_EYE',\n\t'RIGHT_EYE',\n\t'OUTER_MOUTH',\n\t'INNER_MOUTH',\n] as const;\nconst nFaceRegions = REGION_NAMES.length - 1;\nconst RED_CHANNEL_VALUES = Object.fromEntries(REGION_NAMES.map((name, i) => [name, i / nFaceRegions])) as Record<\n\t(typeof REGION_NAMES)[number],\n\tnumber\n>;\nconst HALF_GAP = 0.5 / nFaceRegions;\n\nconst DEFAULT_FACE_OPTIONS: Required<FacePluginOptions> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task',\n\tmaxFaces: 1,\n\tminFaceDetectionConfidence: 0.5,\n\tminFacePresenceConfidence: 0.5,\n\tminTrackingConfidence: 0.5,\n\toutputFaceBlendshapes: false,\n\toutputFacialTransformationMatrixes: false,\n};\n\nfunction fanTriangulate(indices: readonly number[]): number[] {\n\tconst tris: number[] = [];\n\tfor (let i = 1; i < indices.length - 1; ++i) {\n\t\ttris.push(indices[0], indices[i], indices[i + 1]);\n\t}\n\treturn tris;\n}\n\ntype FaceRegion = { triangles: number[]; vertices: Float32Array };\nlet faceRegions: Record<string, FaceRegion> | null = null;\nfunction initFaceRegions(LandmarkerClass: typeof FaceLandmarker): void {\n\tif (!faceRegions) {\n\t\tconst tesselationConnections = LandmarkerClass.FACE_LANDMARKS_TESSELATION;\n\t\tconst tesselation: number[] = [];\n\t\tfor (let i = 0; i < tesselationConnections.length - 2; i += 3) {\n\t\t\ttesselation.push(\n\t\t\t\ttesselationConnections[i].start,\n\t\t\t\ttesselationConnections[i + 1].start,\n\t\t\t\ttesselationConnections[i + 2].start\n\t\t\t);\n\t\t}\n\t\tconst ovalIndices = LandmarkerClass.FACE_LANDMARKS_FACE_OVAL.map(({ start }) => start);\n\t\tfaceRegions = Object.fromEntries(\n\t\t\tObject.entries({\n\t\t\t\tLEFT_EYEBROW: fanTriangulate(LEFT_EYEBROW_INDICES),\n\t\t\t\tRIGHT_EYEBROW: fanTriangulate(RIGHT_EYEBROW_INDICES),\n\t\t\t\tLEFT_EYE: fanTriangulate(LEFT_EYE_INDICES),\n\t\t\t\tRIGHT_EYE: fanTriangulate(RIGHT_EYE_INDICES),\n\t\t\t\tOUTER_MOUTH: fanTriangulate(OUTER_MOUTH_INDICES),\n\t\t\t\tINNER_MOUTH: fanTriangulate(INNER_MOUTH_INDICES),\n\t\t\t\tTESSELATION: tesselation,\n\t\t\t\tOVAL: fanTriangulate(ovalIndices),\n\t\t\t}).map(([key, triangles]) => [key, { triangles, vertices: new Float32Array(triangles.length * 2) }])\n\t\t);\n\t}\n}\n\ninterface Detector {\n\tlandmarker: FaceLandmarker;\n\tcanvas: OffscreenCanvas;\n\tsubscribers: Map<() => void, boolean>;\n\tmaxFaces: number;\n\tstate: {\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: FaceLandmarkerResult | null;\n\t\tpending: Promise<void>;\n\t\tnFaces: number;\n\t};\n\tlandmarks: {\n\t\tdata: Float32Array;\n\t\ttextureHeight: number;\n\t};\n\tmask: {\n\t\tcanvas: OffscreenCanvas;\n\t\tgl: WebGL2RenderingContext;\n\t\tprogram: WebGLProgram;\n\t\tpositionBuffer: WebGLBuffer;\n\t\tcolorLocation: WebGLUniformLocation;\n\t};\n}\nconst sharedDetectors = new Map<string, Detector>();\n\nfunction initMaskRenderer(detector: Detector) {\n\tconst gl = detector.mask.canvas.getContext('webgl2', { antialias: false, preserveDrawingBuffer: true })!;\n\n\tconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\n\tgl.shaderSource(vertexShader, MASK_VERTEX_SHADER);\n\tgl.compileShader(vertexShader);\n\n\tconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\n\tgl.shaderSource(fragmentShader, MASK_FRAGMENT_SHADER);\n\tgl.compileShader(fragmentShader);\n\n\tconst program = gl.createProgram()!;\n\tgl.attachShader(program, vertexShader);\n\tgl.attachShader(program, fragmentShader);\n\tgl.linkProgram(program);\n\tgl.deleteShader(vertexShader);\n\tgl.deleteShader(fragmentShader);\n\n\tconst positionBuffer = gl.createBuffer()!;\n\tgl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\tconst positionLocation = gl.getAttribLocation(program, 'a_pos');\n\tgl.enableVertexAttribArray(positionLocation);\n\tgl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\tconst colorLocation = gl.getUniformLocation(program, 'u_color')!;\n\tgl.useProgram(program);\n\tgl.enable(gl.BLEND);\n\tgl.blendEquation(gl.MAX);\n\n\tdetector.mask = { ...detector.mask, gl, program, positionBuffer, colorLocation };\n}\n\nfunction drawTriangles(detector: Detector, faceRegion: FaceRegion, faceIdx: number, r: number, g: number, b: number) {\n\tconst { triangles, vertices } = faceRegion;\n\tconst {\n\t\tmask: { gl, colorLocation },\n\t\tlandmarks,\n\t} = detector;\n\tconst { data: landmarksDataArray } = landmarks;\n\n\tfor (let i = 0; i < triangles.length; ++i) {\n\t\tconst landmarkIdx = (faceIdx * LANDMARK_COUNT + triangles[i]) * 4;\n\t\tvertices[i * 2] = landmarksDataArray[landmarkIdx];\n\t\tvertices[i * 2 + 1] = landmarksDataArray[landmarkIdx + 1];\n\t}\n\n\tgl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n\tgl.uniform4f(colorLocation, r, g, b, 1.0);\n\tgl.drawArrays(gl.TRIANGLES, 0, triangles.length);\n}\n\nfunction updateLandmarksData(detector: Detector, faces: NormalizedLandmark[][]) {\n\tconst data = detector.landmarks.data;\n\tconst nFaces = faces.length;\n\n\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\tconst landmarks = faces[faceIdx];\n\t\tfor (let landmarkIdx = 0; landmarkIdx < STANDARD_LANDMARK_COUNT; ++landmarkIdx) {\n\t\t\tconst landmark = landmarks[landmarkIdx];\n\t\t\tconst dataIdx = (faceIdx * LANDMARK_COUNT + landmarkIdx) * 4;\n\t\t\tdata[dataIdx] = landmark.x;\n\t\t\tdata[dataIdx + 1] = 1 - landmark.y;\n\t\t\tdata[dataIdx + 2] = landmark.z ?? 0;\n\t\t\tdata[dataIdx + 3] = landmark.visibility ?? 1;\n\t\t}\n\n\t\tconst faceCenter = calculateBoundingBoxCenter(data, faceIdx, ALL_STANDARD_INDICES, LANDMARK_COUNT);\n\t\tdata.set(faceCenter, (faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.FACE_CENTER) * 4);\n\n\t\tconst mouthCenter = calculateBoundingBoxCenter(data, faceIdx, INNER_MOUTH_INDICES, LANDMARK_COUNT);\n\t\tdata.set(mouthCenter, (faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.MOUTH_CENTER) * 4);\n\t}\n\n\tdetector.state.nFaces = nFaces;\n}\n\nfunction updateMaskCanvas(detector: Detector) {\n\tif (!faceRegions) return;\n\tconst {\n\t\tmask,\n\t\tcanvas,\n\t\tmaxFaces,\n\t\tstate: { nFaces },\n\t} = detector;\n\tconst { gl: maskGl, canvas: maskCanvas } = mask;\n\n\tmaskCanvas.width = canvas.width;\n\tmaskCanvas.height = canvas.height;\n\tmaskGl.viewport(0, 0, maskCanvas.width, maskCanvas.height);\n\tmaskGl.clearColor(0, 0, 0, 0);\n\tmaskGl.clear(maskGl.COLOR_BUFFER_BIT);\n\n\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\tconst b = (faceIdx + 1) / maxFaces;\n\n\t\t// G channel: face mesh (0.5) and oval (1.0)\n\t\tdrawTriangles(detector, faceRegions.TESSELATION, faceIdx, 0, 0.5, b);\n\t\tdrawTriangles(detector, faceRegions.OVAL, faceIdx, 0, 1.0, b);\n\n\t\t// R channel: feature regions\n\t\tdrawTriangles(detector, faceRegions.LEFT_EYEBROW, faceIdx, RED_CHANNEL_VALUES.LEFT_EYEBROW, 0, b);\n\t\tdrawTriangles(detector, faceRegions.RIGHT_EYEBROW, faceIdx, RED_CHANNEL_VALUES.RIGHT_EYEBROW, 0, b);\n\t\tdrawTriangles(detector, faceRegions.LEFT_EYE, faceIdx, RED_CHANNEL_VALUES.LEFT_EYE, 0, b);\n\t\tdrawTriangles(detector, faceRegions.RIGHT_EYE, faceIdx, RED_CHANNEL_VALUES.RIGHT_EYE, 0, b);\n\t\tdrawTriangles(detector, faceRegions.OUTER_MOUTH, faceIdx, RED_CHANNEL_VALUES.OUTER_MOUTH, 0, b);\n\t\tdrawTriangles(detector, faceRegions.INNER_MOUTH, faceIdx, RED_CHANNEL_VALUES.INNER_MOUTH, 0, b);\n\t}\n}\n\nfunction face(config: { textureName: string; options?: FacePluginOptions }) {\n\tconst { textureName, options: configOptions = {} } = config;\n\tconst options = { ...DEFAULT_FACE_OPTIONS, ...configOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\tconst nLandmarksMax = options.maxFaces * LANDMARK_COUNT;\n\tconst textureHeight = Math.ceil(nLandmarksMax / LANDMARKS_TEXTURE_WIDTH);\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, gl, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst landmarksData =\n\t\t\texistingDetector?.landmarks.data ?? new Float32Array(LANDMARKS_TEXTURE_WIDTH * textureHeight * 4);\n\t\tconst maskCanvas = existingDetector?.mask.canvas ?? new OffscreenCanvas(1, 1);\n\t\tlet detector: Detector | null = null;\n\n\t\tfunction onResult() {\n\t\t\tif (!detector) return;\n\t\t\tconst nFaces = detector.state.nFaces;\n\t\t\tconst nLandmarks = nFaces * LANDMARK_COUNT;\n\t\t\tconst rowsToUpdate = Math.ceil(nLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures({\n\t\t\t\tu_faceLandmarksTex: {\n\t\t\t\t\tdata: detector.landmarks.data,\n\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t\tisPartial: nFaces < options.maxFaces,\n\t\t\t\t},\n\t\t\t\tu_faceMask: detector.mask.canvas,\n\t\t\t});\n\t\t\tshaderPad.updateUniforms({ u_nFaces: nFaces });\n\t\t\temitHook('face:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { FaceLandmarker }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\n\t\t\t\tconst mediapipeCanvas = new OffscreenCanvas(1, 1);\n\t\t\t\tconst faceLandmarker = await FaceLandmarker.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\tnumFaces: options.maxFaces,\n\t\t\t\t\tminFaceDetectionConfidence: options.minFaceDetectionConfidence,\n\t\t\t\t\tminFacePresenceConfidence: options.minFacePresenceConfidence,\n\t\t\t\t\tminTrackingConfidence: options.minTrackingConfidence,\n\t\t\t\t\toutputFaceBlendshapes: options.outputFaceBlendshapes,\n\t\t\t\t\toutputFacialTransformationMatrixes: options.outputFacialTransformationMatrixes,\n\t\t\t\t});\n\n\t\t\t\tdetector = {\n\t\t\t\t\tlandmarker: faceLandmarker,\n\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tmaxFaces: options.maxFaces,\n\t\t\t\t\tstate: {\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t\tnFaces: 0,\n\t\t\t\t\t},\n\t\t\t\t\tlandmarks: {\n\t\t\t\t\t\tdata: landmarksData,\n\t\t\t\t\t\ttextureHeight,\n\t\t\t\t\t},\n\t\t\t\t\tmask: {\n\t\t\t\t\t\tcanvas: maskCanvas,\n\t\t\t\t\t} as Detector['mask'],\n\t\t\t\t};\n\n\t\t\t\tinitFaceRegions(FaceLandmarker);\n\t\t\t\tinitMaskRenderer(detector);\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectFaces(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tconst callOrder = ++nDetectionCalls;\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (callOrder !== nDetectionCalls || !detector) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.landmarker.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: FaceLandmarkerResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.landmarker.detectForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.landmarker.detect(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tupdateLandmarksData(detector, result.faceLandmarks);\n\t\t\t\t\t\tupdateMaskCanvas(detector);\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result && !detector.subscribers.get(onResult)) {\n\t\t\t\t\tonResult();\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_maxFaces', 'int', options.maxFaces);\n\t\t\tshaderPad.initializeUniform('u_nFaces', 'int', 0);\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_faceLandmarksTex',\n\t\t\t\t{ data: landmarksData, width: LANDMARKS_TEXTURE_WIDTH, height: textureHeight },\n\t\t\t\t{ internalFormat: gl.RGBA32F, type: gl.FLOAT, minFilter: gl.NEAREST, magFilter: gl.NEAREST }\n\t\t\t);\n\t\t\tshaderPad.initializeTexture('u_faceMask', maskCanvas, {\n\t\t\t\tminFilter: gl.NEAREST,\n\t\t\t\tmagFilter: gl.NEAREST,\n\t\t\t});\n\t\t\tinitPromise.then(() => emitHook('face:ready'));\n\t\t});\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) detectFaces(source);\n\t\t});\n\n\t\tshaderPad.on('updateTextures', (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (isMediaPipeSource(source)) detectFaces(source);\n\t\t});\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.landmarker.close();\n\t\t\t\t\tdetector.mask.gl.deleteProgram(detector.mask.program);\n\t\t\t\t\tdetector.mask.gl.deleteBuffer(detector.mask.positionBuffer);\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tconst checkAt = (\n\t\t\tregionMin: keyof typeof RED_CHANNEL_VALUES,\n\t\t\tregionMax: keyof typeof RED_CHANNEL_VALUES = regionMin\n\t\t) =>\n\t\t\t`vec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn (mask.r > ${(RED_CHANNEL_VALUES[regionMin] - HALF_GAP).toFixed(4)} && mask.r < ${(\n\t\t\t\tRED_CHANNEL_VALUES[regionMax] + HALF_GAP\n\t\t\t).toFixed(4)}) ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);`;\n\n\t\tinjectGLSL(`\nuniform int u_maxFaces;\nuniform int u_nFaces;\nuniform sampler2D u_faceLandmarksTex;\nuniform sampler2D u_faceMask;\n\n#define FACE_LANDMARK_L_EYE_CENTER ${LANDMARK_INDICES.LEFT_EYE_CENTER}\n#define FACE_LANDMARK_R_EYE_CENTER ${LANDMARK_INDICES.RIGHT_EYE_CENTER}\n#define FACE_LANDMARK_NOSE_TIP ${LANDMARK_INDICES.NOSE_TIP}\n#define FACE_LANDMARK_FACE_CENTER ${LANDMARK_INDICES.FACE_CENTER}\n#define FACE_LANDMARK_MOUTH_CENTER ${LANDMARK_INDICES.MOUTH_CENTER}\n\nvec4 faceLandmark(int faceIndex, int landmarkIndex) {\n\tint i = faceIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};\n\treturn texelFetch(u_faceLandmarksTex, ivec2(x, y), 0);\n}\n\nvec2 leftEyebrowAt(vec2 pos) {\n\t${checkAt('LEFT_EYEBROW')}\n}\n\nvec2 rightEyebrowAt(vec2 pos) {\n\t${checkAt('RIGHT_EYEBROW')}\n}\n\nvec2 leftEyeAt(vec2 pos) {\n\t${checkAt('LEFT_EYE')}\n}\n\nvec2 rightEyeAt(vec2 pos) {\n\t${checkAt('RIGHT_EYE')}\n}\n\nvec2 lipsAt(vec2 pos) {\n\t${checkAt('OUTER_MOUTH')}\n}\n\nvec2 outerMouthAt(vec2 pos) {\n\t${checkAt('OUTER_MOUTH', 'INNER_MOUTH')}\n}\n\nvec2 innerMouthAt(vec2 pos) {\n\t${checkAt('INNER_MOUTH')}\n}\n\nvec2 faceOvalAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn mask.g > 0.75 ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);\n}\n\n// Includes face mesh and oval.\nvec2 faceAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn mask.g > 0.25 ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);\n}\n\nvec2 eyeAt(vec2 pos) {\n\tvec2 left = leftEyeAt(pos);\n\treturn left.x > 0.0 ? left : rightEyeAt(pos);\n}\n\nvec2 eyebrowAt(vec2 pos) {\n\tvec2 left = leftEyebrowAt(pos);\n\treturn left.x > 0.0 ? left : rightEyebrowAt(pos);\n}\n\nfloat inEyebrow(vec2 pos) { return eyebrowAt(pos).x; }\nfloat inEye(vec2 pos) { return eyeAt(pos).x; }\nfloat inOuterMouth(vec2 pos) { return outerMouthAt(pos).x; }\nfloat inInnerMouth(vec2 pos) { return innerMouthAt(pos).x; }\nfloat inLips(vec2 pos) { return lipsAt(pos).x; }\nfloat inFace(vec2 pos) { return faceAt(pos).x; }`);\n\t};\n}\n\nexport default face;\n","import { TextureSource } from '..';\n\nexport type MediaPipeSource = HTMLVideoElement | HTMLImageElement | HTMLCanvasElement | OffscreenCanvas;\n\nexport function isMediaPipeSource(source: TextureSource): source is MediaPipeSource {\n\treturn (\n\t\tsource instanceof HTMLVideoElement ||\n\t\tsource instanceof HTMLImageElement ||\n\t\tsource instanceof HTMLCanvasElement ||\n\t\tsource instanceof OffscreenCanvas\n\t);\n}\n\nexport function hashOptions(options: object): string {\n\treturn JSON.stringify(options, Object.keys(options).sort());\n}\n\nexport function calculateBoundingBoxCenter(\n\tdata: Float32Array,\n\tentityIdx: number,\n\tlandmarkIndices: readonly number[] | number[],\n\tlandmarkCount: number\n): [number, number, number, number] {\n\tlet minX = Infinity,\n\t\tmaxX = -Infinity,\n\t\tminY = Infinity,\n\t\tmaxY = -Infinity,\n\t\tavgZ = 0,\n\t\tavgVisibility = 0;\n\n\tfor (const idx of landmarkIndices) {\n\t\tconst dataIdx = (entityIdx * landmarkCount + idx) * 4;\n\t\tconst x = data[dataIdx];\n\t\tconst y = data[dataIdx + 1];\n\t\tminX = Math.min(minX, x);\n\t\tmaxX = Math.max(maxX, x);\n\t\tminY = Math.min(minY, y);\n\t\tmaxY = Math.max(maxY, y);\n\t\tavgZ += data[dataIdx + 2];\n\t\tavgVisibility += data[dataIdx + 3];\n\t}\n\n\treturn [\n\t\t(minX + maxX) / 2,\n\t\t(minY + maxY) / 2,\n\t\tavgZ / landmarkIndices.length,\n\t\tavgVisibility / landmarkIndices.length,\n\t];\n}\n\nlet filesetPromise: Promise<any> | null = null;\nexport function getSharedFileset(): Promise<any> {\n\tif (!filesetPromise) {\n\t\tfilesetPromise = import('@mediapipe/tasks-vision').then(({ FilesetResolver }) =>\n\t\t\tFilesetResolver.forVisionTasks(\n\t\t\t\t`https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@${__MEDIAPIPE_TASKS_VISION_VERSION__}/wasm`\n\t\t\t)\n\t\t);\n\t}\n\treturn filesetPromise;\n}\n"],"mappings":"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","names":["face_exports","__export","face_default","__toCommonJS","isMediaPipeSource","source","hashOptions","options","calculateBoundingBoxCenter","data","entityIdx","landmarkIndices","landmarkCount","minX","maxX","minY","maxY","avgZ","avgVisibility","idx","dataIdx","x","y","filesetPromise","getSharedFileset","FilesetResolver","MASK_VERTEX_SHADER","MASK_FRAGMENT_SHADER","STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","LANDMARKS_TEXTURE_WIDTH","LEFT_EYEBROW_INDICES","LEFT_EYE_INDICES","RIGHT_EYEBROW_INDICES","RIGHT_EYE_INDICES","OUTER_MOUTH_INDICES","INNER_MOUTH_INDICES","ALL_STANDARD_INDICES","_","i","LANDMARK_INDICES","REGION_NAMES","nFaceRegions","RED_CHANNEL_VALUES","name","HALF_GAP","DEFAULT_FACE_OPTIONS","fanTriangulate","indices","tris","faceRegions","initFaceRegions","LandmarkerClass","tesselationConnections","tesselation","ovalIndices","start","key","triangles","sharedDetectors","initMaskRenderer","detector","gl","vertexShader","fragmentShader","program","positionBuffer","positionLocation","colorLocation","drawTriangles","faceRegion","faceIdx","r","g","b","vertices","landmarks","landmarksDataArray","landmarkIdx","updateLandmarksData","faces","data","nFaces","landmark","dataIdx","faceCenter","calculateBoundingBoxCenter","mouthCenter","updateMaskCanvas","mask","canvas","maxFaces","maskGl","maskCanvas","face","config","textureName","configOptions","options","optionsKey","hashOptions","nLandmarksMax","textureHeight","shaderPad","context","injectGLSL","emitHook","existingDetector","landmarksData","onResult","nLandmarks","rowsToUpdate","initializeDetector","mediaPipe","FaceLandmarker","getSharedFileset","mediapipeCanvas","initPromise","nDetectionCalls","detectFaces","source","now","callOrder","requiredMode","shouldDetect","result","cb","isMediaPipeSource","updates","checkAt","regionMin","regionMax","face_default"]}