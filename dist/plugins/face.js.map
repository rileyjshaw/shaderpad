{"version":3,"sources":["../../src/plugins/face.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '../index';\nimport type { FaceLandmarker, FaceLandmarkerResult, NormalizedLandmark } from '@mediapipe/tasks-vision';\n\nexport interface FacePluginOptions {\n\tmodelPath?: string;\n\tmaxFaces?: number;\n\tminFaceDetectionConfidence?: number;\n\tminFacePresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\toutputFaceBlendshapes?: boolean;\n\toutputFacialTransformationMatrixes?: boolean;\n\tonResults?: (results: FaceLandmarkerResult) => void;\n}\n\nconst STANDARD_LANDMARK_COUNT = 478;\nconst CUSTOM_LANDMARK_COUNT = 2;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\n\nconst LEFT_EYEBROW_INDICES = [336, 296, 334, 293, 300, 276, 283, 282, 295, 285] as const;\nconst LEFT_EYE_INDICES = [362, 398, 384, 385, 386, 387, 388, 466, 263, 249, 390, 373, 374, 380, 381, 382] as const;\nconst RIGHT_EYEBROW_INDICES = [70, 63, 105, 66, 107, 55, 65, 52, 53, 46] as const;\nconst RIGHT_EYE_INDICES = [33, 246, 161, 160, 159, 158, 157, 173, 133, 155, 154, 153, 145, 144, 163, 7] as const;\nconst OUTER_MOUTH_INDICES = [\n\t61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146,\n] as const;\nconst INNER_MOUTH_INDICES = [\n\t78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308, 324, 318, 402, 317, 14, 87, 178, 88, 95,\n] as const;\nconst ALL_STANDARD_INDICES = Array.from({ length: STANDARD_LANDMARK_COUNT }, (_, i) => i);\nconst LANDMARK_INDICES = {\n\tLEFT_EYEBROW: LEFT_EYEBROW_INDICES,\n\tLEFT_EYE: LEFT_EYE_INDICES,\n\tLEFT_EYE_CENTER: 473,\n\tRIGHT_EYEBROW: RIGHT_EYEBROW_INDICES,\n\tRIGHT_EYE: RIGHT_EYE_INDICES,\n\tRIGHT_EYE_CENTER: 468,\n\tNOSE_TIP: 4,\n\tOUTER_MOUTH: OUTER_MOUTH_INDICES,\n\tINNER_MOUTH: INNER_MOUTH_INDICES,\n\t// Custom landmarks.\n\tFACE_CENTER: STANDARD_LANDMARK_COUNT,\n\tMOUTH_CENTER: STANDARD_LANDMARK_COUNT + 1,\n};\n\n// Face region types for R channel encoding (evenly spaced 0-1).\nconst FACE_REGION_NAMES = [\n\t'BACKGROUND',\n\t'LEFT_EYEBROW',\n\t'RIGHT_EYEBROW',\n\t'LEFT_EYE',\n\t'RIGHT_EYE',\n\t'OUTER_MOUTH',\n\t'INNER_MOUTH',\n] as const;\nconst nFaceRegions = FACE_REGION_NAMES.length - 1;\nconst FACE_REGION = Object.fromEntries(FACE_REGION_NAMES.map((name, i) => [name, i / nFaceRegions])) as Record<\n\t(typeof FACE_REGION_NAMES)[number],\n\tnumber\n>;\nconst HALF_GAP = 0.5 / nFaceRegions;\n\nfunction face(config: { textureName: string; options?: FacePluginOptions }) {\n\tconst { textureName, options } = config;\n\tconst defaultModelPath =\n\t\t'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task';\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, gl } = context;\n\n\t\tlet faceLandmarker: FaceLandmarker | null = null;\n\t\tlet vision: any = null;\n\t\tlet lastVideoTime = -1;\n\t\tlet runningMode: 'IMAGE' | 'VIDEO' = 'VIDEO';\n\t\tconst textureSources = new Map<string, TextureSource>();\n\t\tconst maxFaces = options?.maxFaces ?? 1;\n\n\t\tconst LANDMARKS_TEXTURE_WIDTH = 512;\n\t\tlet landmarksTextureHeight = 0;\n\t\tlet landmarksDataArray: Float32Array | null = null;\n\n\t\tconst mediaPipeCanvas = new OffscreenCanvas(1, 1);\n\t\tconst faceMaskCanvas = document.createElement('canvas');\n\t\tconst faceMaskCtx = faceMaskCanvas.getContext('2d')!;\n\n\t\tlet faceTesselationIndices: number[] | null = null;\n\t\tlet faceOvalIndices: number[] | null = null;\n\t\tasync function initializeFaceLandmarker() {\n\t\t\ttry {\n\t\t\t\tconst { FilesetResolver, FaceLandmarker } = await import('@mediapipe/tasks-vision');\n\t\t\t\tvision = await FilesetResolver.forVisionTasks(\n\t\t\t\t\t'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'\n\t\t\t\t);\n\n\t\t\t\tfaceLandmarker = await FaceLandmarker.createFromOptions(vision, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options?.modelPath || defaultModelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: mediaPipeCanvas,\n\t\t\t\t\trunningMode: runningMode,\n\t\t\t\t\tnumFaces: options?.maxFaces ?? 1,\n\t\t\t\t\tminFaceDetectionConfidence: options?.minFaceDetectionConfidence ?? 0.5,\n\t\t\t\t\tminFacePresenceConfidence: options?.minFacePresenceConfidence ?? 0.5,\n\t\t\t\t\tminTrackingConfidence: options?.minTrackingConfidence ?? 0.5,\n\t\t\t\t\toutputFaceBlendshapes: options?.outputFaceBlendshapes ?? false,\n\t\t\t\t\toutputFacialTransformationMatrixes: options?.outputFacialTransformationMatrixes ?? false,\n\t\t\t\t});\n\n\t\t\t\tfaceTesselationIndices = FaceLandmarker.FACE_LANDMARKS_TESSELATION.map(({ start }) => start);\n\t\t\t\tfaceOvalIndices = FaceLandmarker.FACE_LANDMARKS_FACE_OVAL.map(({ start }) => start);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Face Plugin] Failed to initialize:', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tfunction calculateBoundingBoxCenter(\n\t\t\tlandmarksDataArray: Float32Array,\n\t\t\tfaceIdx: number,\n\t\t\tlandmarkIndices: readonly number[] | number[]\n\t\t): [number, number, number, number] {\n\t\t\tlet minX = Infinity,\n\t\t\t\tmaxX = -Infinity,\n\t\t\t\tminY = Infinity,\n\t\t\t\tmaxY = -Infinity,\n\t\t\t\tavgZ = 0,\n\t\t\t\tavgVisibility = 0;\n\n\t\t\tfor (const idx of landmarkIndices) {\n\t\t\t\tconst dataIdx = (faceIdx * LANDMARK_COUNT + idx) * 4;\n\t\t\t\tconst x = landmarksDataArray[dataIdx];\n\t\t\t\tconst y = landmarksDataArray[dataIdx + 1];\n\t\t\t\tminX = Math.min(minX, x);\n\t\t\t\tmaxX = Math.max(maxX, x);\n\t\t\t\tminY = Math.min(minY, y);\n\t\t\t\tmaxY = Math.max(maxY, y);\n\t\t\t\tavgZ += landmarksDataArray[dataIdx + 2];\n\t\t\t\tavgVisibility += landmarksDataArray[dataIdx + 3];\n\t\t\t}\n\n\t\t\tconst centerX = (minX + maxX) / 2;\n\t\t\tconst centerY = (minY + maxY) / 2;\n\t\t\tconst centerZ = avgZ / landmarkIndices.length;\n\t\t\tconst centerVisibility = avgVisibility / landmarkIndices.length;\n\t\t\treturn [centerX, centerY, centerZ, centerVisibility];\n\t\t}\n\n\t\tfunction fillRegion(\n\t\t\tfaceIdx: number,\n\t\t\tlandmarkIndices: readonly number[] | number[],\n\t\t\tcolor: { r: number; g: number; b: number }\n\t\t) {\n\t\t\tif (!landmarksDataArray) return;\n\n\t\t\tconst { width, height } = faceMaskCanvas;\n\t\t\tfaceMaskCtx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;\n\n\t\t\tfaceMaskCtx.beginPath();\n\t\t\tconst originIdx = (faceIdx * LANDMARK_COUNT + landmarkIndices[0]) * 4;\n\t\t\tfaceMaskCtx.moveTo(landmarksDataArray[originIdx] * width, landmarksDataArray[originIdx + 1] * height);\n\n\t\t\tfor (let i = 1; i < landmarkIndices.length; ++i) {\n\t\t\t\tconst destIdx = (faceIdx * LANDMARK_COUNT + landmarkIndices[i]) * 4;\n\t\t\t\tfaceMaskCtx.lineTo(landmarksDataArray[destIdx] * width, landmarksDataArray[destIdx + 1] * height);\n\t\t\t}\n\t\t\tfaceMaskCtx.closePath();\n\t\t\tfaceMaskCtx.fill();\n\t\t}\n\n\t\tfunction updateMaskTexture(nFaces: number) {\n\t\t\tif (!landmarksDataArray || !faceTesselationIndices || !faceOvalIndices) return;\n\n\t\t\tconst { width, height } = faceMaskCanvas;\n\t\t\tfaceMaskCtx.clearRect(0, 0, width, height);\n\n\t\t\tfaceMaskCtx.save();\n\t\t\tfaceMaskCtx.globalCompositeOperation = 'lighten';\n\n\t\t\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\t\t\tconst b = Math.round(((faceIdx + 1) / maxFaces) * 255);\n\n\t\t\t\t// Draw face regions in order (features on top).\n\t\t\t\t// First: face mesh and oval (for G channel - face mask).\n\t\t\t\tfillRegion(faceIdx, faceTesselationIndices, { r: 0, g: 128, b });\n\t\t\t\tfillRegion(faceIdx, faceOvalIndices, { r: 0, g: 255, b });\n\n\t\t\t\t// Then: specific regions (for R channel - region type).\n\t\t\t\tfillRegion(faceIdx, LEFT_EYEBROW_INDICES, { r: Math.round(FACE_REGION.LEFT_EYEBROW * 255), g: 0, b });\n\t\t\t\tfillRegion(faceIdx, RIGHT_EYEBROW_INDICES, { r: Math.round(FACE_REGION.RIGHT_EYEBROW * 255), g: 0, b });\n\t\t\t\tfillRegion(faceIdx, LEFT_EYE_INDICES, { r: Math.round(FACE_REGION.LEFT_EYE * 255), g: 0, b });\n\t\t\t\tfillRegion(faceIdx, RIGHT_EYE_INDICES, { r: Math.round(FACE_REGION.RIGHT_EYE * 255), g: 0, b });\n\t\t\t\tfillRegion(faceIdx, OUTER_MOUTH_INDICES, { r: Math.round(FACE_REGION.OUTER_MOUTH * 255), g: 0, b });\n\t\t\t\tfillRegion(faceIdx, INNER_MOUTH_INDICES, { r: Math.round(FACE_REGION.INNER_MOUTH * 255), g: 0, b });\n\t\t\t}\n\n\t\t\tfaceMaskCtx.restore();\n\t\t\tshaderPad.updateTextures({ u_faceMask: faceMaskCanvas });\n\t\t}\n\n\t\tfunction updateLandmarksTexture(faces: NormalizedLandmark[][]) {\n\t\t\tif (!landmarksDataArray) return;\n\n\t\t\tconst nFaces = faces.length;\n\t\t\tconst totalLandmarks = nFaces * LANDMARK_COUNT;\n\n\t\t\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\t\t\tconst landmarks = faces[faceIdx];\n\t\t\t\tfor (let lmIdx = 0; lmIdx < STANDARD_LANDMARK_COUNT; ++lmIdx) {\n\t\t\t\t\tconst landmark = landmarks[lmIdx];\n\t\t\t\t\tconst dataIdx = (faceIdx * LANDMARK_COUNT + lmIdx) * 4;\n\t\t\t\t\tlandmarksDataArray[dataIdx] = landmark.x;\n\t\t\t\t\tlandmarksDataArray[dataIdx + 1] = 1 - landmark.y;\n\t\t\t\t\tlandmarksDataArray[dataIdx + 2] = landmark.z ?? 0;\n\t\t\t\t\tlandmarksDataArray[dataIdx + 3] = landmark.visibility ?? 1;\n\t\t\t\t}\n\n\t\t\t\tconst faceCenter = calculateBoundingBoxCenter(landmarksDataArray, faceIdx, ALL_STANDARD_INDICES);\n\t\t\t\tconst faceCenterIdx = (faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.FACE_CENTER) * 4;\n\t\t\t\tlandmarksDataArray[faceCenterIdx] = faceCenter[0];\n\t\t\t\tlandmarksDataArray[faceCenterIdx + 1] = faceCenter[1];\n\t\t\t\tlandmarksDataArray[faceCenterIdx + 2] = faceCenter[2];\n\t\t\t\tlandmarksDataArray[faceCenterIdx + 3] = faceCenter[3];\n\n\t\t\t\tconst mouthCenter = calculateBoundingBoxCenter(landmarksDataArray, faceIdx, INNER_MOUTH_INDICES);\n\t\t\t\tconst mouthCenterIdx = (faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.MOUTH_CENTER) * 4;\n\t\t\t\tlandmarksDataArray[mouthCenterIdx] = mouthCenter[0];\n\t\t\t\tlandmarksDataArray[mouthCenterIdx + 1] = mouthCenter[1];\n\t\t\t\tlandmarksDataArray[mouthCenterIdx + 2] = mouthCenter[2];\n\t\t\t\tlandmarksDataArray[mouthCenterIdx + 3] = mouthCenter[3];\n\t\t\t}\n\n\t\t\tconst rowsToUpdate = Math.ceil(totalLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures({\n\t\t\t\tu_faceLandmarksTex: {\n\t\t\t\t\tdata: landmarksDataArray,\n\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t\tisPartial: true,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tfunction processFaceResults(result: FaceLandmarkerResult) {\n\t\t\tif (!result.faceLandmarks || !landmarksDataArray) return;\n\n\t\t\tfaceMaskCanvas.width = mediaPipeCanvas.width;\n\t\t\tfaceMaskCanvas.height = mediaPipeCanvas.height;\n\n\t\t\tconst nFaces = result.faceLandmarks.length;\n\t\t\tupdateLandmarksTexture(result.faceLandmarks);\n\t\t\tupdateMaskTexture(nFaces);\n\t\t\tshaderPad.updateUniforms({ u_nFaces: nFaces });\n\n\t\t\toptions?.onResults?.(result);\n\t\t}\n\n\t\tshaderPad.registerHook('init', async () => {\n\t\t\tshaderPad.initializeTexture('u_faceMask', faceMaskCanvas, { preserveY: true });\n\t\t\tshaderPad.initializeUniform('u_maxFaces', 'int', maxFaces);\n\t\t\tshaderPad.initializeUniform('u_nFaces', 'int', 0);\n\n\t\t\tconst totalLandmarks = maxFaces * LANDMARK_COUNT;\n\t\t\tlandmarksTextureHeight = Math.ceil(totalLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tconst textureSize = LANDMARKS_TEXTURE_WIDTH * landmarksTextureHeight * 4;\n\t\t\tlandmarksDataArray = new Float32Array(textureSize);\n\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_faceLandmarksTex',\n\t\t\t\t{\n\t\t\t\t\tdata: landmarksDataArray,\n\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\theight: landmarksTextureHeight,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tinternalFormat: gl.RGBA32F,\n\t\t\t\t\ttype: gl.FLOAT,\n\t\t\t\t\tminFilter: gl.NEAREST,\n\t\t\t\t\tmagFilter: gl.NEAREST,\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tawait initializeFaceLandmarker();\n\t\t});\n\n\t\tshaderPad.registerHook('updateTextures', async (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (!source) return;\n\n\t\t\tconst previousSource = textureSources.get(textureName);\n\t\t\tif (previousSource !== source) {\n\t\t\t\tlastVideoTime = -1;\n\t\t\t}\n\n\t\t\ttextureSources.set(textureName, source);\n\t\t\tif (!faceLandmarker) return;\n\n\t\t\ttry {\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (runningMode !== requiredMode) {\n\t\t\t\t\trunningMode = requiredMode;\n\t\t\t\t\tawait faceLandmarker.setOptions({ runningMode: runningMode });\n\t\t\t\t}\n\n\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (source.currentTime !== lastVideoTime) {\n\t\t\t\t\t\tlastVideoTime = source.currentTime;\n\t\t\t\t\t\tconst result = faceLandmarker.detectForVideo(source, performance.now());\n\t\t\t\t\t\tprocessFaceResults(result);\n\t\t\t\t\t}\n\t\t\t\t} else if (source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {\n\t\t\t\t\tif (source.width === 0 || source.height === 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst result = faceLandmarker.detect(source);\n\t\t\t\t\tprocessFaceResults(result);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Face Plugin] Detection error:', error);\n\t\t\t}\n\t\t});\n\n\t\tshaderPad.registerHook('destroy', () => {\n\t\t\tif (faceLandmarker) {\n\t\t\t\tfaceLandmarker.close();\n\t\t\t\tfaceLandmarker = null;\n\t\t\t}\n\t\t\tvision = null;\n\t\t\ttextureSources.clear();\n\t\t\tfaceMaskCanvas.remove();\n\t\t\tlandmarksDataArray = null;\n\t\t});\n\n\t\tconst regionCheck = (val: number) =>\n\t\t\t`(mask.r > ${(val - HALF_GAP).toFixed(4)} && mask.r < ${(val + HALF_GAP).toFixed(\n\t\t\t\t4\n\t\t\t)})  ? vec2(1.0, faceIndex) : vec2(0.0, -1.0)`;\n\n\t\tinjectGLSL(`\nuniform int u_maxFaces;\nuniform int u_nFaces;\nuniform sampler2D u_faceLandmarksTex;\nuniform sampler2D u_faceMask;\n\n#define FACE_LANDMARK_L_EYE_CENTER ${LANDMARK_INDICES.LEFT_EYE_CENTER}\n#define FACE_LANDMARK_R_EYE_CENTER ${LANDMARK_INDICES.RIGHT_EYE_CENTER}\n#define FACE_LANDMARK_NOSE_TIP ${LANDMARK_INDICES.NOSE_TIP}\n#define FACE_LANDMARK_FACE_CENTER ${LANDMARK_INDICES.FACE_CENTER}\n#define FACE_LANDMARK_MOUTH_CENTER ${LANDMARK_INDICES.MOUTH_CENTER}\n\nvec4 faceLandmark(int faceIndex, int landmarkIndex) {\n\tint i = faceIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};\n\treturn texelFetch(u_faceLandmarksTex, ivec2(x, y), 0);\n}\n\nvec2 leftEyebrowAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn ${regionCheck(FACE_REGION.LEFT_EYEBROW)};\n}\n\nvec2 rightEyebrowAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn ${regionCheck(FACE_REGION.RIGHT_EYEBROW)};\n}\n\nvec2 leftEyeAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn ${regionCheck(FACE_REGION.LEFT_EYE)};\n}\n\nvec2 rightEyeAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn ${regionCheck(FACE_REGION.RIGHT_EYE)};\n}\n\nvec2 outerMouthAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn ${regionCheck(FACE_REGION.OUTER_MOUTH)};\n}\n\nvec2 innerMouthAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn ${regionCheck(FACE_REGION.INNER_MOUTH)};\n}\n\nvec2 faceOvalAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn mask.g > 0.75 ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);\n}\n\n// Includes face mesh and oval.\nvec2 faceAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn mask.g > 0.25 ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);\n}\n\nvec2 eyeAt(vec2 pos) {\n\tvec2 left = leftEyeAt(pos);\n\tvec2 right = rightEyeAt(pos);\n\treturn left.x >= 0.0 ? left : right;\n}\n\nvec2 eyebrowAt(vec2 pos) {\n\tvec2 left = leftEyebrowAt(pos);\n\tvec2 right = rightEyebrowAt(pos);\n\treturn left.x >= 0.0 ? left : right;\n}\n\nfloat inEyebrow(vec2 pos) {\n\treturn eyebrowAt(pos).x;\n}\n\nfloat inEye(vec2 pos) {\n\treturn eyeAt(pos).x;\n}\n\nfloat inMouth(vec2 pos) {\n\treturn innerMouthAt(pos).x;\n}\n\nfloat inLips(vec2 pos) {\n\tfloat lips = outerMouthAt(pos).x;\n\tfloat mouth = innerMouthAt(pos).x;\n\treturn max(0.0, lips - mouth);\n}\n\nfloat inFace(vec2 pos) {\n\treturn faceAt(pos).x;\n}`);\n\t};\n}\n\nexport default face;\n"],"mappings":"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","names":["face_exports","__export","face_default","__toCommonJS","STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","LEFT_EYEBROW_INDICES","LEFT_EYE_INDICES","RIGHT_EYEBROW_INDICES","RIGHT_EYE_INDICES","OUTER_MOUTH_INDICES","INNER_MOUTH_INDICES","ALL_STANDARD_INDICES","_","i","LANDMARK_INDICES","FACE_REGION_NAMES","nFaceRegions","FACE_REGION","name","HALF_GAP","face","config","textureName","options","defaultModelPath","shaderPad","context","injectGLSL","gl","faceLandmarker","vision","lastVideoTime","runningMode","textureSources","maxFaces","LANDMARKS_TEXTURE_WIDTH","landmarksTextureHeight","landmarksDataArray","mediaPipeCanvas","faceMaskCanvas","faceMaskCtx","faceTesselationIndices","faceOvalIndices","initializeFaceLandmarker","FilesetResolver","FaceLandmarker","start","error","calculateBoundingBoxCenter","faceIdx","landmarkIndices","minX","maxX","minY","maxY","avgZ","avgVisibility","idx","dataIdx","x","y","centerX","centerY","centerZ","centerVisibility","fillRegion","color","width","height","originIdx","destIdx","updateMaskTexture","nFaces","b","updateLandmarksTexture","faces","totalLandmarks","landmarks","lmIdx","landmark","faceCenter","faceCenterIdx","mouthCenter","mouthCenterIdx","rowsToUpdate","processFaceResults","result","textureSize","updates","source","requiredMode","regionCheck","val"]}