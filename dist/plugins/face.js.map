{"version":3,"sources":["../../src/plugins/face.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '../index';\nimport type { FaceLandmarker, FaceLandmarkerResult, NormalizedLandmark } from '@mediapipe/tasks-vision';\n\nexport interface FacePluginOptions {\n\tmodelPath?: string;\n\tmaxFaces?: number;\n\tminFaceDetectionConfidence?: number;\n\tminFacePresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\toutputFaceBlendshapes?: boolean;\n\toutputFacialTransformationMatrixes?: boolean;\n\tonResults?: (results: FaceLandmarkerResult) => void;\n}\n\nconst STANDARD_LANDMARK_COUNT = 478;\nconst CUSTOM_LANDMARK_COUNT = 2;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst LANDMARK_INDICES = {\n\tLEFT_EYEBROW: [336, 296, 334, 293, 300, 276, 283, 282, 295, 285],\n\tLEFT_EYE: [362, 398, 384, 385, 386, 387, 388, 466, 263, 249, 390, 373, 374, 380, 381, 382],\n\tLEFT_EYE_CENTER: 473,\n\tRIGHT_EYEBROW: [70, 63, 105, 66, 107, 55, 65, 52, 53, 46],\n\tRIGHT_EYE: [33, 246, 161, 160, 159, 158, 157, 173, 133, 155, 154, 153, 145, 144, 163, 7],\n\tRIGHT_EYE_CENTER: 468,\n\tNOSE_TIP: 4,\n\tOUTER_LIP: [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146],\n\tINNER_LIP: [78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308, 324, 318, 402, 317, 14, 87, 178, 88, 95],\n\t// Custom landmarks.\n\tFACE_CENTER: STANDARD_LANDMARK_COUNT,\n\tMOUTH_CENTER: STANDARD_LANDMARK_COUNT + 1,\n};\n\nfunction face(config: { textureName: string; options?: FacePluginOptions }) {\n\tconst { textureName, options } = config;\n\tconst defaultModelPath =\n\t\t'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task';\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, gl } = context;\n\n\t\tlet faceLandmarker: FaceLandmarker | null = null;\n\t\tlet vision: any = null;\n\t\tlet lastVideoTime = -1;\n\t\tlet runningMode: 'IMAGE' | 'VIDEO' = 'VIDEO';\n\t\tconst textureSources = new Map<string, TextureSource>();\n\t\tconst maxFaces = options?.maxFaces ?? 1;\n\n\t\tconst LANDMARKS_TEXTURE_WIDTH = 512;\n\t\tlet landmarksTextureHeight = 0;\n\t\tlet landmarksDataArray: Float32Array | null = null;\n\n\t\tconst maskWidth = 512;\n\t\tconst maskHeight = 512;\n\t\tconst faceMaskCanvas = document.createElement('canvas');\n\t\tfaceMaskCanvas.width = maskWidth;\n\t\tfaceMaskCanvas.height = maskHeight;\n\t\tconst faceMaskCtx = faceMaskCanvas.getContext('2d')!;\n\t\tfaceMaskCtx.globalCompositeOperation = 'lighten'; // Keep the highest value of each channel.\n\n\t\tasync function initializeFaceLandmarker() {\n\t\t\ttry {\n\t\t\t\tconst { FilesetResolver, FaceLandmarker } = await import('@mediapipe/tasks-vision');\n\t\t\t\tvision = await FilesetResolver.forVisionTasks(\n\t\t\t\t\t'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'\n\t\t\t\t);\n\n\t\t\t\tfaceLandmarker = await FaceLandmarker.createFromOptions(vision, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options?.modelPath || defaultModelPath,\n\t\t\t\t\t},\n\t\t\t\t\trunningMode: runningMode,\n\t\t\t\t\tnumFaces: options?.maxFaces ?? 1,\n\t\t\t\t\tminFaceDetectionConfidence: options?.minFaceDetectionConfidence ?? 0.5,\n\t\t\t\t\tminFacePresenceConfidence: options?.minFacePresenceConfidence ?? 0.5,\n\t\t\t\t\tminTrackingConfidence: options?.minTrackingConfidence ?? 0.5,\n\t\t\t\t\toutputFaceBlendshapes: options?.outputFaceBlendshapes ?? false,\n\t\t\t\t\toutputFacialTransformationMatrixes: options?.outputFacialTransformationMatrixes ?? false,\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Failed to initialize Face Landmarker:', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tfunction calculateBoundingBoxCenter(\n\t\t\tlandmarksDataArray: Float32Array,\n\t\t\tfaceIdx: number,\n\t\t\tlandmarkIndices: number[]\n\t\t): [number, number, number, number] {\n\t\t\tlet minX = Infinity,\n\t\t\t\tmaxX = -Infinity,\n\t\t\t\tminY = Infinity,\n\t\t\t\tmaxY = -Infinity,\n\t\t\t\tavgZ = 0,\n\t\t\t\tavgVisibility = 0;\n\n\t\t\tfor (const idx of landmarkIndices) {\n\t\t\t\tconst dataIdx = (faceIdx * LANDMARK_COUNT + idx) * 4;\n\t\t\t\tconst x = landmarksDataArray[dataIdx];\n\t\t\t\tconst y = landmarksDataArray[dataIdx + 1];\n\t\t\t\tminX = Math.min(minX, x);\n\t\t\t\tmaxX = Math.max(maxX, x);\n\t\t\t\tminY = Math.min(minY, y);\n\t\t\t\tmaxY = Math.max(maxY, y);\n\t\t\t\tavgZ += landmarksDataArray[dataIdx + 2];\n\t\t\t\tavgVisibility += landmarksDataArray[dataIdx + 3];\n\t\t\t}\n\n\t\t\tconst centerX = (minX + maxX) / 2;\n\t\t\tconst centerY = (minY + maxY) / 2;\n\t\t\tconst centerZ = avgZ / landmarkIndices.length;\n\t\t\tconst centerVisibility = avgVisibility / landmarkIndices.length;\n\t\t\treturn [centerX, centerY, centerZ, centerVisibility];\n\t\t}\n\n\t\tfunction fillRegion(faceIdx: number, landmarkIndices: number[], color: { r: number; g: number; b: number }) {\n\t\t\tif (!landmarksDataArray) return;\n\t\t\tfaceMaskCtx.fillStyle = `rgb(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(\n\t\t\t\tcolor.b * 255\n\t\t\t)})`;\n\t\t\tfaceMaskCtx.beginPath();\n\t\t\tconst originIdx = (faceIdx * LANDMARK_COUNT + landmarkIndices[0]) * 4;\n\t\t\tconst originX = landmarksDataArray[originIdx];\n\t\t\tconst originY = landmarksDataArray[originIdx + 1];\n\t\t\tfaceMaskCtx.moveTo(originX * faceMaskCanvas.width, originY * faceMaskCanvas.height);\n\n\t\t\tfor (let i = 1; i < landmarkIndices.length; ++i) {\n\t\t\t\tconst destIdx = (faceIdx * LANDMARK_COUNT + landmarkIndices[i]) * 4;\n\t\t\t\tconst destX = landmarksDataArray[destIdx];\n\t\t\t\tconst destY = landmarksDataArray[destIdx + 1];\n\t\t\t\tfaceMaskCtx.lineTo(destX * faceMaskCanvas.width, destY * faceMaskCanvas.height);\n\t\t\t}\n\t\t\tfaceMaskCtx.closePath();\n\t\t\tfaceMaskCtx.fill();\n\t\t}\n\n\t\tasync function updateMaskTexture(nFaces: number) {\n\t\t\tif (!faceLandmarker || !landmarksDataArray) {\n\t\t\t\tconsole.warn('[Face Plugin] Cannot update mask: faceLandmarker or landmarksDataArray missing');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst { FaceLandmarker } = await import('@mediapipe/tasks-vision');\n\t\t\t\tfaceMaskCtx.clearRect(0, 0, faceMaskCanvas.width, faceMaskCanvas.height);\n\n\t\t\t\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\t\t\t\t// Build combined mask with RGBA channels\n\t\t\t\t\t// R: Mouth | G: Face | B: Eyes\n\t\t\t\t\t// Mouth (red channel).\n\t\t\t\t\t// Lips.\n\t\t\t\t\tfillRegion(faceIdx, LANDMARK_INDICES.OUTER_LIP, { r: 0.25, g: 0, b: 0 });\n\t\t\t\t\t// Inner mouth.\n\t\t\t\t\tfillRegion(faceIdx, LANDMARK_INDICES.INNER_LIP, { r: 0.75, g: 0, b: 0 });\n\n\t\t\t\t\t// Face (green channel).\n\t\t\t\t\t// Entire face.\n\t\t\t\t\tfillRegion(\n\t\t\t\t\t\tfaceIdx,\n\t\t\t\t\t\tFaceLandmarker.FACE_LANDMARKS_TESSELATION.map(({ start }) => start),\n\t\t\t\t\t\t{ r: 0, g: 0.25, b: 0 }\n\t\t\t\t\t);\n\t\t\t\t\t// Face contour (excludes nose in profile view).\n\t\t\t\t\tfillRegion(\n\t\t\t\t\t\tfaceIdx,\n\t\t\t\t\t\tFaceLandmarker.FACE_LANDMARKS_FACE_OVAL.map(({ start }) => start),\n\t\t\t\t\t\t{ r: 0, g: 1, b: 0 }\n\t\t\t\t\t);\n\n\t\t\t\t\t// Eyes (blue channel).\n\t\t\t\t\t// Eyebrows.\n\t\t\t\t\tfillRegion(faceIdx, LANDMARK_INDICES.LEFT_EYEBROW, {\n\t\t\t\t\t\tr: 0,\n\t\t\t\t\t\tg: 0,\n\t\t\t\t\t\tb: 0.15,\n\t\t\t\t\t});\n\t\t\t\t\tfillRegion(faceIdx, LANDMARK_INDICES.RIGHT_EYEBROW, {\n\t\t\t\t\t\tr: 0,\n\t\t\t\t\t\tg: 0,\n\t\t\t\t\t\tb: 0.35,\n\t\t\t\t\t});\n\t\t\t\t\t// Eyes.\n\t\t\t\t\tfillRegion(faceIdx, LANDMARK_INDICES.LEFT_EYE, { r: 0, g: 0, b: 0.65 });\n\t\t\t\t\tfillRegion(faceIdx, LANDMARK_INDICES.RIGHT_EYE, { r: 0, g: 0, b: 0.85 });\n\t\t\t\t}\n\n\t\t\t\tshaderPad.updateTextures({ u_faceMask: faceMaskCanvas });\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Face Plugin] Failed to generate mask texture:', error);\n\t\t\t}\n\t\t}\n\n\t\tfunction updateLandmarksTexture(faces: NormalizedLandmark[][]) {\n\t\t\tif (!landmarksDataArray) return;\n\n\t\t\tconst nFaces = faces.length;\n\t\t\tconst totalLandmarks = nFaces * LANDMARK_COUNT;\n\n\t\t\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\t\t\tconst landmarks = faces[faceIdx];\n\t\t\t\tfor (let lmIdx = 0; lmIdx < STANDARD_LANDMARK_COUNT; ++lmIdx) {\n\t\t\t\t\tconst landmark = landmarks[lmIdx];\n\t\t\t\t\tconst dataIdx = (faceIdx * LANDMARK_COUNT + lmIdx) * 4;\n\t\t\t\t\tlandmarksDataArray[dataIdx] = landmark.x; // R (X)\n\t\t\t\t\tlandmarksDataArray[dataIdx + 1] = 1 - landmark.y; // G (Inverted Y)\n\t\t\t\t\tlandmarksDataArray[dataIdx + 2] = landmark.z ?? 0; // B (Z)\n\t\t\t\t\tlandmarksDataArray[dataIdx + 3] = landmark.visibility ?? 1; // A (Visibility)\n\t\t\t\t}\n\n\t\t\t\tconst faceCenter = calculateBoundingBoxCenter(\n\t\t\t\t\tlandmarksDataArray,\n\t\t\t\t\tfaceIdx,\n\t\t\t\t\tArray.from({ length: STANDARD_LANDMARK_COUNT }, (_, i) => i)\n\t\t\t\t);\n\t\t\t\tconst faceCenterIdx = (faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.FACE_CENTER) * 4;\n\t\t\t\tlandmarksDataArray[faceCenterIdx] = faceCenter[0];\n\t\t\t\tlandmarksDataArray[faceCenterIdx + 1] = faceCenter[1];\n\t\t\t\tlandmarksDataArray[faceCenterIdx + 2] = 0; // Z\n\t\t\t\tlandmarksDataArray[faceCenterIdx + 3] = 1; // Visibility\n\n\t\t\t\t// Mouth center (landmark 479) - uses INNER_LIP landmarks\n\t\t\t\tconst mouthCenter = calculateBoundingBoxCenter(landmarksDataArray, faceIdx, LANDMARK_INDICES.INNER_LIP);\n\t\t\t\tconst mouthCenterIdx = (faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.MOUTH_CENTER) * 4;\n\t\t\t\tlandmarksDataArray[mouthCenterIdx] = mouthCenter[0];\n\t\t\t\tlandmarksDataArray[mouthCenterIdx + 1] = mouthCenter[1];\n\t\t\t\tlandmarksDataArray[mouthCenterIdx + 2] = 0; // Z\n\t\t\t\tlandmarksDataArray[mouthCenterIdx + 3] = 1; // Visibility\n\t\t\t}\n\n\t\t\tconst rowsToUpdate = Math.ceil(totalLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures({\n\t\t\t\tu_faceLandmarksTex: {\n\t\t\t\t\tdata: landmarksDataArray,\n\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tfunction processFaceResults(result: FaceLandmarkerResult) {\n\t\t\tif (!result.faceLandmarks || !landmarksDataArray) return;\n\n\t\t\tconst nFaces = result.faceLandmarks.length;\n\t\t\tupdateLandmarksTexture(result.faceLandmarks);\n\t\t\tupdateMaskTexture(nFaces).catch(error => {\n\t\t\t\tconsole.warn('Mask texture update error:', error);\n\t\t\t});\n\t\t\tshaderPad.updateUniforms({ u_nFaces: nFaces });\n\n\t\t\toptions?.onResults?.(result);\n\t\t}\n\n\t\tshaderPad.registerHook('init', async () => {\n\t\t\tshaderPad.initializeTexture('u_faceMask', faceMaskCanvas, { preserveY: true });\n\t\t\tshaderPad.initializeUniform('u_maxFaces', 'int', maxFaces);\n\t\t\tshaderPad.initializeUniform('u_nFaces', 'int', 0);\n\n\t\t\tconst totalLandmarks = maxFaces * LANDMARK_COUNT;\n\t\t\tlandmarksTextureHeight = Math.ceil(totalLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tconst textureSize = LANDMARKS_TEXTURE_WIDTH * landmarksTextureHeight * 4;\n\t\t\tlandmarksDataArray = new Float32Array(textureSize);\n\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_faceLandmarksTex',\n\t\t\t\t{\n\t\t\t\t\tdata: landmarksDataArray,\n\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\theight: landmarksTextureHeight,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tinternalFormat: gl.RGBA32F,\n\t\t\t\t\ttype: gl.FLOAT,\n\t\t\t\t\tminFilter: gl.NEAREST,\n\t\t\t\t\tmagFilter: gl.NEAREST,\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tawait initializeFaceLandmarker();\n\t\t});\n\n\t\tshaderPad.registerHook('updateTextures', async (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (!source) return;\n\n\t\t\tconst previousSource = textureSources.get(textureName);\n\t\t\tif (previousSource !== source) {\n\t\t\t\tlastVideoTime = -1;\n\t\t\t}\n\n\t\t\ttextureSources.set(textureName, source);\n\t\t\tif (!faceLandmarker) return;\n\t\t\ttry {\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (runningMode !== requiredMode) {\n\t\t\t\t\trunningMode = requiredMode;\n\t\t\t\t\tawait faceLandmarker.setOptions({ runningMode: runningMode });\n\t\t\t\t}\n\n\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (source.currentTime !== lastVideoTime) {\n\t\t\t\t\t\tlastVideoTime = source.currentTime;\n\t\t\t\t\t\tconst timestamp = performance.now();\n\t\t\t\t\t\tconst result = faceLandmarker.detectForVideo(source, timestamp);\n\t\t\t\t\t\tprocessFaceResults(result);\n\t\t\t\t\t}\n\t\t\t\t} else if (source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {\n\t\t\t\t\tif (source.width === 0 || source.height === 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst result = faceLandmarker.detect(source);\n\t\t\t\t\tprocessFaceResults(result);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn('Face detection error:', error);\n\t\t\t}\n\t\t});\n\n\t\tshaderPad.registerHook('destroy', () => {\n\t\t\tif (faceLandmarker) {\n\t\t\t\tfaceLandmarker.close();\n\t\t\t\tfaceLandmarker = null;\n\t\t\t}\n\t\t\tvision = null;\n\t\t\ttextureSources.clear();\n\t\t\tfaceMaskCanvas.remove();\n\t\t\tlandmarksDataArray = null;\n\t\t});\n\n\t\tinjectGLSL(`\nuniform int u_maxFaces;\nuniform int u_nFaces;\nuniform sampler2D u_faceLandmarksTex;\nuniform sampler2D u_faceMask;\n\n#define FACE_LANDMARK_L_EYE_CENTER ${LANDMARK_INDICES.LEFT_EYE_CENTER}\n#define FACE_LANDMARK_R_EYE_CENTER ${LANDMARK_INDICES.RIGHT_EYE_CENTER}\n#define FACE_LANDMARK_NOSE_TIP ${LANDMARK_INDICES.NOSE_TIP}\n#define FACE_LANDMARK_FACE_CENTER ${LANDMARK_INDICES.FACE_CENTER}\n#define FACE_LANDMARK_MOUTH_CENTER ${LANDMARK_INDICES.MOUTH_CENTER}\n\nvec4 faceLandmark(int faceIndex, int landmarkIndex) {\n\tint i = faceIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};\n\treturn texelFetch(u_faceLandmarksTex, ivec2(x, y), 0);\n}\nfloat inFace(vec2 pos) { return texture(u_faceMask, pos).g; }\nfloat inEye(vec2 pos) { return texture(u_faceMask, pos).b; }\nfloat inMouth(vec2 pos) { return texture(u_faceMask, pos).r; }`);\n\t};\n}\n\nexport default face;\n"],"mappings":"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","names":["face_exports","__export","face_default","__toCommonJS","STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","LANDMARK_INDICES","face","config","textureName","options","defaultModelPath","shaderPad","context","injectGLSL","gl","faceLandmarker","vision","lastVideoTime","runningMode","textureSources","maxFaces","LANDMARKS_TEXTURE_WIDTH","landmarksTextureHeight","landmarksDataArray","maskWidth","maskHeight","faceMaskCanvas","faceMaskCtx","initializeFaceLandmarker","FilesetResolver","FaceLandmarker","error","calculateBoundingBoxCenter","faceIdx","landmarkIndices","minX","maxX","minY","maxY","avgZ","avgVisibility","idx","dataIdx","x","y","centerX","centerY","centerZ","centerVisibility","fillRegion","color","originIdx","originX","originY","i","destIdx","destX","destY","updateMaskTexture","nFaces","start","updateLandmarksTexture","faces","totalLandmarks","landmarks","lmIdx","landmark","faceCenter","_","faceCenterIdx","mouthCenter","mouthCenterIdx","rowsToUpdate","processFaceResults","result","textureSize","updates","source","requiredMode","timestamp"]}