{"version":3,"sources":["../../src/plugins/face.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '../index';\nimport type { FaceLandmarker, FaceLandmarkerResult, NormalizedLandmark } from '@mediapipe/tasks-vision';\n\nexport interface FacePluginOptions {\n\tmodelPath?: string;\n\tmaxFaces?: number;\n\tminFaceDetectionConfidence?: number;\n\tminFacePresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\toutputFaceBlendshapes?: boolean;\n\toutputFacialTransformationMatrixes?: boolean;\n\tonResults?: (results: FaceLandmarkerResult) => void;\n}\n\nconst STANDARD_LANDMARK_COUNT = 478;\nconst CUSTOM_LANDMARK_COUNT = 2;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst LANDMARKS_TEXTURE_WIDTH = 512;\n\nconst LEFT_EYEBROW_INDICES = [336, 296, 334, 293, 300, 276, 283, 282, 295, 285] as const;\nconst LEFT_EYE_INDICES = [362, 398, 384, 385, 386, 387, 388, 466, 263, 249, 390, 373, 374, 380, 381, 382] as const;\nconst RIGHT_EYEBROW_INDICES = [70, 63, 105, 66, 107, 55, 65, 52, 53, 46] as const;\nconst RIGHT_EYE_INDICES = [33, 246, 161, 160, 159, 158, 157, 173, 133, 155, 154, 153, 145, 144, 163, 7] as const;\nconst OUTER_MOUTH_INDICES = [\n\t61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146,\n] as const;\nconst INNER_MOUTH_INDICES = [\n\t78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308, 324, 318, 402, 317, 14, 87, 178, 88, 95,\n] as const;\nconst ALL_STANDARD_INDICES = Array.from({ length: STANDARD_LANDMARK_COUNT }, (_, i) => i);\nconst LANDMARK_INDICES = {\n\tLEFT_EYEBROW: LEFT_EYEBROW_INDICES,\n\tLEFT_EYE: LEFT_EYE_INDICES,\n\tLEFT_EYE_CENTER: 473,\n\tRIGHT_EYEBROW: RIGHT_EYEBROW_INDICES,\n\tRIGHT_EYE: RIGHT_EYE_INDICES,\n\tRIGHT_EYE_CENTER: 468,\n\tNOSE_TIP: 4,\n\tOUTER_MOUTH: OUTER_MOUTH_INDICES,\n\tINNER_MOUTH: INNER_MOUTH_INDICES,\n\t// Custom landmarks.\n\tFACE_CENTER: STANDARD_LANDMARK_COUNT,\n\tMOUTH_CENTER: STANDARD_LANDMARK_COUNT + 1,\n};\n\n// Face region types for R channel encoding (evenly spaced 0-1).\nconst FACE_REGION_NAMES = [\n\t'BACKGROUND',\n\t'LEFT_EYEBROW',\n\t'RIGHT_EYEBROW',\n\t'LEFT_EYE',\n\t'RIGHT_EYE',\n\t'OUTER_MOUTH',\n\t'INNER_MOUTH',\n] as const;\nconst nFaceRegions = FACE_REGION_NAMES.length - 1;\nconst FACE_REGION = Object.fromEntries(FACE_REGION_NAMES.map((name, i) => [name, i / nFaceRegions])) as Record<\n\t(typeof FACE_REGION_NAMES)[number],\n\tnumber\n>;\nconst HALF_GAP = 0.5 / nFaceRegions;\n\nfunction face(config: { textureName: string; options?: FacePluginOptions }) {\n\tconst { textureName, options } = config;\n\tconst defaultModelPath =\n\t\t'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task';\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, gl } = context;\n\n\t\tlet faceLandmarker: FaceLandmarker | null = null;\n\t\tlet vision: any = null;\n\t\tlet lastVideoTime = -1;\n\t\tlet runningMode: 'IMAGE' | 'VIDEO' = 'VIDEO';\n\t\tconst textureSources = new Map<string, TextureSource>();\n\t\tconst maxFaces = options?.maxFaces ?? 1;\n\n\t\tlet landmarksTextureHeight = 0;\n\t\tlet landmarksDataArray: Float32Array | null = null;\n\n\t\tconst mediaPipeCanvas = new OffscreenCanvas(1, 1);\n\t\tconst faceMaskCanvas = document.createElement('canvas');\n\t\tconst faceMaskCtx = faceMaskCanvas.getContext('2d')!;\n\n\t\tlet faceTesselationIndices: number[] | null = null;\n\t\tlet faceOvalIndices: number[] | null = null;\n\t\tasync function initializeFaceLandmarker() {\n\t\t\ttry {\n\t\t\t\tconst { FilesetResolver, FaceLandmarker } = await import('@mediapipe/tasks-vision');\n\t\t\t\tvision = await FilesetResolver.forVisionTasks(\n\t\t\t\t\t'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'\n\t\t\t\t);\n\n\t\t\t\tfaceLandmarker = await FaceLandmarker.createFromOptions(vision, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options?.modelPath || defaultModelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: mediaPipeCanvas,\n\t\t\t\t\trunningMode: runningMode,\n\t\t\t\t\tnumFaces: options?.maxFaces ?? 1,\n\t\t\t\t\tminFaceDetectionConfidence: options?.minFaceDetectionConfidence ?? 0.5,\n\t\t\t\t\tminFacePresenceConfidence: options?.minFacePresenceConfidence ?? 0.5,\n\t\t\t\t\tminTrackingConfidence: options?.minTrackingConfidence ?? 0.5,\n\t\t\t\t\toutputFaceBlendshapes: options?.outputFaceBlendshapes ?? false,\n\t\t\t\t\toutputFacialTransformationMatrixes: options?.outputFacialTransformationMatrixes ?? false,\n\t\t\t\t});\n\n\t\t\t\tfaceTesselationIndices = FaceLandmarker.FACE_LANDMARKS_TESSELATION.map(({ start }) => start);\n\t\t\t\tfaceOvalIndices = FaceLandmarker.FACE_LANDMARKS_FACE_OVAL.map(({ start }) => start);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Face Plugin] Failed to initialize:', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tfunction calculateBoundingBoxCenter(\n\t\t\tdata: Float32Array,\n\t\t\tfaceIdx: number,\n\t\t\tindices: readonly number[] | number[]\n\t\t): [number, number, number, number] {\n\t\t\tlet minX = Infinity,\n\t\t\t\tmaxX = -Infinity,\n\t\t\t\tminY = Infinity,\n\t\t\t\tmaxY = -Infinity,\n\t\t\t\tavgZ = 0,\n\t\t\t\tavgVis = 0;\n\n\t\t\tfor (const idx of indices) {\n\t\t\t\tconst i = (faceIdx * LANDMARK_COUNT + idx) * 4;\n\t\t\t\tconst x = data[i],\n\t\t\t\t\ty = data[i + 1];\n\t\t\t\tminX = Math.min(minX, x);\n\t\t\t\tmaxX = Math.max(maxX, x);\n\t\t\t\tminY = Math.min(minY, y);\n\t\t\t\tmaxY = Math.max(maxY, y);\n\t\t\t\tavgZ += data[i + 2];\n\t\t\t\tavgVis += data[i + 3];\n\t\t\t}\n\t\t\treturn [(minX + maxX) / 2, (minY + maxY) / 2, avgZ / indices.length, avgVis / indices.length];\n\t\t}\n\n\t\tfunction fillRegion(faceIdx: number, indices: readonly number[] | number[], r: number, g: number, b: number) {\n\t\t\tif (!landmarksDataArray) return;\n\n\t\t\tconst { width, height } = faceMaskCanvas;\n\t\t\tfaceMaskCtx.fillStyle = `rgba(${r}, ${g}, ${b}, 255)`;\n\t\t\tfaceMaskCtx.beginPath();\n\t\t\tconst first = (faceIdx * LANDMARK_COUNT + indices[0]) * 4;\n\t\t\tfaceMaskCtx.moveTo(landmarksDataArray[first] * width, landmarksDataArray[first + 1] * height);\n\t\t\tfor (let i = 1; i < indices.length; ++i) {\n\t\t\t\tconst idx = (faceIdx * LANDMARK_COUNT + indices[i]) * 4;\n\t\t\t\tfaceMaskCtx.lineTo(landmarksDataArray[idx] * width, landmarksDataArray[idx + 1] * height);\n\t\t\t}\n\t\t\tfaceMaskCtx.closePath();\n\t\t\tfaceMaskCtx.fill();\n\t\t}\n\n\t\tfunction updateMaskTexture(nFaces: number) {\n\t\t\tif (!landmarksDataArray || !faceTesselationIndices || !faceOvalIndices) return;\n\n\t\t\tconst { width, height } = faceMaskCanvas;\n\t\t\tfaceMaskCtx.clearRect(0, 0, width, height);\n\n\t\t\tfaceMaskCtx.save();\n\t\t\tfaceMaskCtx.globalCompositeOperation = 'lighten';\n\n\t\t\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\t\t\tconst b = Math.round(((faceIdx + 1) / maxFaces) * 255);\n\n\t\t\t\t// G channel: face mesh (0.5) and oval (1.0)\n\t\t\t\tfillRegion(faceIdx, faceTesselationIndices, 0, 128, b);\n\t\t\t\tfillRegion(faceIdx, faceOvalIndices, 0, 255, b);\n\n\t\t\t\t// R channel: feature regions (drawn on top)\n\t\t\t\tfillRegion(faceIdx, LEFT_EYEBROW_INDICES, Math.round(FACE_REGION.LEFT_EYEBROW * 255), 0, b);\n\t\t\t\tfillRegion(faceIdx, RIGHT_EYEBROW_INDICES, Math.round(FACE_REGION.RIGHT_EYEBROW * 255), 0, b);\n\t\t\t\tfillRegion(faceIdx, LEFT_EYE_INDICES, Math.round(FACE_REGION.LEFT_EYE * 255), 0, b);\n\t\t\t\tfillRegion(faceIdx, RIGHT_EYE_INDICES, Math.round(FACE_REGION.RIGHT_EYE * 255), 0, b);\n\t\t\t\tfillRegion(faceIdx, OUTER_MOUTH_INDICES, Math.round(FACE_REGION.OUTER_MOUTH * 255), 0, b);\n\t\t\t\tfillRegion(faceIdx, INNER_MOUTH_INDICES, Math.round(FACE_REGION.INNER_MOUTH * 255), 0, b);\n\t\t\t}\n\n\t\t\tfaceMaskCtx.restore();\n\t\t\tshaderPad.updateTextures({ u_faceMask: faceMaskCanvas });\n\t\t}\n\n\t\tfunction updateLandmarksTexture(faces: NormalizedLandmark[][]) {\n\t\t\tif (!landmarksDataArray) return;\n\n\t\t\tconst nFaces = faces.length;\n\t\t\tconst totalLandmarks = nFaces * LANDMARK_COUNT;\n\n\t\t\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\t\t\tconst landmarks = faces[faceIdx];\n\t\t\t\tfor (let lmIdx = 0; lmIdx < STANDARD_LANDMARK_COUNT; ++lmIdx) {\n\t\t\t\t\tconst landmark = landmarks[lmIdx];\n\t\t\t\t\tconst dataIdx = (faceIdx * LANDMARK_COUNT + lmIdx) * 4;\n\t\t\t\t\tlandmarksDataArray[dataIdx] = landmark.x;\n\t\t\t\t\tlandmarksDataArray[dataIdx + 1] = 1 - landmark.y;\n\t\t\t\t\tlandmarksDataArray[dataIdx + 2] = landmark.z ?? 0;\n\t\t\t\t\tlandmarksDataArray[dataIdx + 3] = landmark.visibility ?? 1;\n\t\t\t\t}\n\n\t\t\t\tconst faceCenter = calculateBoundingBoxCenter(landmarksDataArray, faceIdx, ALL_STANDARD_INDICES);\n\t\t\t\tconst faceCenterIdx = (faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.FACE_CENTER) * 4;\n\t\t\t\tlandmarksDataArray.set(faceCenter, faceCenterIdx);\n\n\t\t\t\tconst mouthCenter = calculateBoundingBoxCenter(landmarksDataArray, faceIdx, INNER_MOUTH_INDICES);\n\t\t\t\tconst mouthCenterIdx = (faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.MOUTH_CENTER) * 4;\n\t\t\t\tlandmarksDataArray.set(mouthCenter, mouthCenterIdx);\n\t\t\t}\n\n\t\t\tconst rowsToUpdate = Math.ceil(totalLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures({\n\t\t\t\tu_faceLandmarksTex: {\n\t\t\t\t\tdata: landmarksDataArray,\n\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t\tisPartial: true,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tfunction processFaceResults(result: FaceLandmarkerResult) {\n\t\t\tif (!result.faceLandmarks || !landmarksDataArray) return;\n\n\t\t\tfaceMaskCanvas.width = mediaPipeCanvas.width;\n\t\t\tfaceMaskCanvas.height = mediaPipeCanvas.height;\n\n\t\t\tconst nFaces = result.faceLandmarks.length;\n\t\t\tupdateLandmarksTexture(result.faceLandmarks);\n\t\t\tupdateMaskTexture(nFaces);\n\t\t\tshaderPad.updateUniforms({ u_nFaces: nFaces });\n\n\t\t\toptions?.onResults?.(result);\n\t\t}\n\n\t\tshaderPad.registerHook('init', async () => {\n\t\t\tshaderPad.initializeTexture('u_faceMask', faceMaskCanvas, {\n\t\t\t\tpreserveY: true,\n\t\t\t\tminFilter: gl.NEAREST,\n\t\t\t\tmagFilter: gl.NEAREST,\n\t\t\t});\n\t\t\tshaderPad.initializeUniform('u_maxFaces', 'int', maxFaces);\n\t\t\tshaderPad.initializeUniform('u_nFaces', 'int', 0);\n\n\t\t\tconst totalLandmarks = maxFaces * LANDMARK_COUNT;\n\t\t\tlandmarksTextureHeight = Math.ceil(totalLandmarks / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tlandmarksDataArray = new Float32Array(LANDMARKS_TEXTURE_WIDTH * landmarksTextureHeight * 4);\n\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_faceLandmarksTex',\n\t\t\t\t{ data: landmarksDataArray, width: LANDMARKS_TEXTURE_WIDTH, height: landmarksTextureHeight },\n\t\t\t\t{ internalFormat: gl.RGBA32F, type: gl.FLOAT, minFilter: gl.NEAREST, magFilter: gl.NEAREST }\n\t\t\t);\n\n\t\t\tawait initializeFaceLandmarker();\n\t\t});\n\n\t\tshaderPad.registerHook('updateTextures', async (updates: Record<string, TextureSource>) => {\n\t\t\tconst source = updates[textureName];\n\t\t\tif (!source) return;\n\n\t\t\tconst previousSource = textureSources.get(textureName);\n\t\t\tif (previousSource !== source) lastVideoTime = -1;\n\t\t\ttextureSources.set(textureName, source);\n\t\t\tif (!faceLandmarker) return;\n\n\t\t\ttry {\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (runningMode !== requiredMode) {\n\t\t\t\t\trunningMode = requiredMode;\n\t\t\t\t\tawait faceLandmarker.setOptions({ runningMode });\n\t\t\t\t}\n\n\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\tif (source.currentTime !== lastVideoTime) {\n\t\t\t\t\t\tlastVideoTime = source.currentTime;\n\t\t\t\t\t\tprocessFaceResults(faceLandmarker.detectForVideo(source, performance.now()));\n\t\t\t\t\t}\n\t\t\t\t} else if (source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {\n\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\tprocessFaceResults(faceLandmarker.detect(source));\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('[Face Plugin] Detection error:', error);\n\t\t\t}\n\t\t});\n\n\t\tshaderPad.registerHook('destroy', () => {\n\t\t\tfaceLandmarker?.close();\n\t\t\tfaceLandmarker = null;\n\t\t\tvision = null;\n\t\t\ttextureSources.clear();\n\t\t\tfaceMaskCanvas.remove();\n\t\t\tlandmarksDataArray = null;\n\t\t});\n\n\t\tconst checkAt = (regionMin: keyof typeof FACE_REGION, regionMax: keyof typeof FACE_REGION = regionMin) =>\n\t\t\t`vec4 mask = texture(u_faceMask, pos);\n\tif (mask.a < 0.9) return vec2(0.0, -1.0);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn (mask.r > ${(FACE_REGION[regionMin] - HALF_GAP).toFixed(4)} && mask.r < ${(\n\t\t\t\tFACE_REGION[regionMax] + HALF_GAP\n\t\t\t).toFixed(4)}) ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);`;\n\n\t\tinjectGLSL(`\nuniform int u_maxFaces;\nuniform int u_nFaces;\nuniform sampler2D u_faceLandmarksTex;\nuniform sampler2D u_faceMask;\n\n#define FACE_LANDMARK_L_EYE_CENTER ${LANDMARK_INDICES.LEFT_EYE_CENTER}\n#define FACE_LANDMARK_R_EYE_CENTER ${LANDMARK_INDICES.RIGHT_EYE_CENTER}\n#define FACE_LANDMARK_NOSE_TIP ${LANDMARK_INDICES.NOSE_TIP}\n#define FACE_LANDMARK_FACE_CENTER ${LANDMARK_INDICES.FACE_CENTER}\n#define FACE_LANDMARK_MOUTH_CENTER ${LANDMARK_INDICES.MOUTH_CENTER}\n\nvec4 faceLandmark(int faceIndex, int landmarkIndex) {\n\tint i = faceIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};\n\treturn texelFetch(u_faceLandmarksTex, ivec2(x, y), 0);\n}\n\nvec2 leftEyebrowAt(vec2 pos) {\n\t${checkAt('LEFT_EYEBROW')}\n}\n\nvec2 rightEyebrowAt(vec2 pos) {\n\t${checkAt('RIGHT_EYEBROW')}\n}\n\nvec2 leftEyeAt(vec2 pos) {\n\t${checkAt('LEFT_EYE')}\n}\n\nvec2 rightEyeAt(vec2 pos) {\n\t${checkAt('RIGHT_EYE')}\n}\n\nvec2 lipsAt(vec2 pos) {\n\t${checkAt('OUTER_MOUTH')}\n}\n\nvec2 outerMouthAt(vec2 pos) {\n\t${checkAt('OUTER_MOUTH', 'INNER_MOUTH')}\n}\n\nvec2 innerMouthAt(vec2 pos) {\n\t${checkAt('INNER_MOUTH')}\n}\n\nvec2 faceOvalAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tif (mask.a < 0.9) return vec2(0.0, -1.0);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn mask.g > 0.75 ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);\n}\n\n// Includes face mesh and oval.\nvec2 faceAt(vec2 pos) {\n\tvec4 mask = texture(u_faceMask, pos);\n\tif (mask.a < 0.9) return vec2(0.0, -1.0);\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn mask.g > 0.25 ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);\n}\n\nvec2 eyeAt(vec2 pos) {\n\tvec2 left = leftEyeAt(pos);\n\treturn left.x > 0.0 ? left : rightEyeAt(pos);\n}\n\nvec2 eyebrowAt(vec2 pos) {\n\tvec2 left = leftEyebrowAt(pos);\n\treturn left.x > 0.0 ? left : rightEyebrowAt(pos);\n}\n\nfloat inEyebrow(vec2 pos) { return eyebrowAt(pos).x; }\nfloat inEye(vec2 pos) { return eyeAt(pos).x; }\nfloat inOuterMouth(vec2 pos) { return outerMouthAt(pos).x; }\nfloat inInnerMouth(vec2 pos) { return innerMouthAt(pos).x; }\nfloat inLips(vec2 pos) { return lipsAt(pos).x; }\nfloat inFace(vec2 pos) { return faceAt(pos).x; }`);\n\t};\n}\n\nexport default face;\n"],"mappings":"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","names":["face_exports","__export","face_default","__toCommonJS","STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","LANDMARKS_TEXTURE_WIDTH","LEFT_EYEBROW_INDICES","LEFT_EYE_INDICES","RIGHT_EYEBROW_INDICES","RIGHT_EYE_INDICES","OUTER_MOUTH_INDICES","INNER_MOUTH_INDICES","ALL_STANDARD_INDICES","_","i","LANDMARK_INDICES","FACE_REGION_NAMES","nFaceRegions","FACE_REGION","name","HALF_GAP","face","config","textureName","options","defaultModelPath","shaderPad","context","injectGLSL","gl","faceLandmarker","vision","lastVideoTime","runningMode","textureSources","maxFaces","landmarksTextureHeight","landmarksDataArray","mediaPipeCanvas","faceMaskCanvas","faceMaskCtx","faceTesselationIndices","faceOvalIndices","initializeFaceLandmarker","FilesetResolver","FaceLandmarker","start","error","calculateBoundingBoxCenter","data","faceIdx","indices","minX","maxX","minY","maxY","avgZ","avgVis","idx","x","y","fillRegion","r","g","b","width","height","first","updateMaskTexture","nFaces","updateLandmarksTexture","faces","totalLandmarks","landmarks","lmIdx","landmark","dataIdx","faceCenter","faceCenterIdx","mouthCenter","mouthCenterIdx","rowsToUpdate","processFaceResults","result","updates","source","requiredMode","checkAt","regionMin","regionMax"]}