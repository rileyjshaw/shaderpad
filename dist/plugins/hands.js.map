{"version":3,"sources":["../../src/plugins/hands.ts","../../src/plugins/mediapipe-common.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tcalculateBoundingBoxCenter,\n\tgenerateGLSLFn,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { HandLandmarker, HandLandmarkerResult, NormalizedLandmark } from '@mediapipe/tasks-vision';\n\nexport interface HandsPluginOptions {\n\tmodelPath?: string;\n\tmaxHands?: number;\n\tminHandDetectionConfidence?: number;\n\tminHandPresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\thistory?: number;\n}\n\nconst STANDARD_LANDMARK_COUNT = 21; // See https://ai.google.dev/edge/mediapipe/solutions/vision/hand_landmarker#models.\nconst CUSTOM_LANDMARK_COUNT = 1;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst HAND_CENTER_LANDMARKS = [0, 0, 5, 9, 13, 17] as const; // Wrist + MCP joints, weighted toward wrist.\nconst LANDMARKS_TEXTURE_WIDTH = 512;\nconst N_LANDMARK_METADATA_SLOTS = 1;\n\nconst DEFAULT_HANDS_OPTIONS: Required<Omit<HandsPluginOptions, 'history'>> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',\n\tmaxHands: 2,\n\tminHandDetectionConfidence: 0.5,\n\tminHandPresenceConfidence: 0.5,\n\tminTrackingConfidence: 0.5,\n};\n\ninterface Detector {\n\tlandmarker: HandLandmarker;\n\tcanvas: OffscreenCanvas;\n\tsubscribers: Map<() => void, boolean>;\n\tmaxHands: number;\n\tstate: {\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: HandLandmarkerResult | null;\n\t\tpending: Promise<void>;\n\t\tnHands: number;\n\t};\n\tlandmarks: {\n\t\tdata: Float32Array;\n\t\ttextureHeight: number;\n\t};\n}\nconst sharedDetectors = new Map<string, Detector>();\n\nfunction updateLandmarksData(\n\tdetector: Detector,\n\thands: NormalizedLandmark[][],\n\thandedness: { categoryName: string }[][]\n) {\n\tconst data = detector.landmarks.data;\n\tconst nHands = hands.length;\n\n\tdata[0] = nHands;\n\n\tfor (let handIdx = 0; handIdx < nHands; ++handIdx) {\n\t\tconst landmarks = hands[handIdx];\n\t\tconst isRightHand = handedness[handIdx]?.[0]?.categoryName === 'Right';\n\t\tfor (let lmIdx = 0; lmIdx < STANDARD_LANDMARK_COUNT; ++lmIdx) {\n\t\t\tconst landmark = landmarks[lmIdx];\n\t\t\tconst dataIdx = (N_LANDMARK_METADATA_SLOTS + handIdx * LANDMARK_COUNT + lmIdx) * 4;\n\t\t\tdata[dataIdx] = landmark.x;\n\t\t\tdata[dataIdx + 1] = 1 - landmark.y;\n\t\t\tdata[dataIdx + 2] = landmark.z ?? 0;\n\t\t\tdata[dataIdx + 3] = isRightHand ? 1 : 0;\n\t\t}\n\n\t\tconst handCenter = calculateBoundingBoxCenter(data, handIdx, HAND_CENTER_LANDMARKS, LANDMARK_COUNT, N_LANDMARK_METADATA_SLOTS);\n\t\tconst handCenterIdx = (N_LANDMARK_METADATA_SLOTS + handIdx * LANDMARK_COUNT + STANDARD_LANDMARK_COUNT) * 4;\n\t\tdata[handCenterIdx] = handCenter[0];\n\t\tdata[handCenterIdx + 1] = handCenter[1];\n\t\tdata[handCenterIdx + 2] = handCenter[2];\n\t\tdata[handCenterIdx + 3] = isRightHand ? 1 : 0;\n\t}\n\n\tdetector.state.nHands = nHands;\n}\n\nfunction hands(config: { textureName: string; options?: HandsPluginOptions }) {\n\tconst { textureName, options: { history, ...mediapipeOptions } = {} } = config;\n\tconst options = { ...DEFAULT_HANDS_OPTIONS, ...mediapipeOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\tconst nLandmarksMax = options.maxHands * LANDMARK_COUNT + N_LANDMARK_METADATA_SLOTS;\n\tconst textureHeight = Math.ceil(nLandmarksMax / LANDMARKS_TEXTURE_WIDTH);\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, gl, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst landmarksData =\n\t\t\texistingDetector?.landmarks.data ?? new Float32Array(LANDMARKS_TEXTURE_WIDTH * textureHeight * 4);\n\t\tlet detector: Detector | null = null;\n\t\tlet skipHistoryWrite = false;\n\n\t\tfunction onResult() {\n\t\t\tif (!detector) return;\n\t\t\tconst { nHands } = detector.state;\n\t\t\tconst nSlots = nHands * LANDMARK_COUNT + N_LANDMARK_METADATA_SLOTS;\n\t\t\tconst rowsToUpdate = Math.ceil(nSlots / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tshaderPad.updateTextures(\n\t\t\t\t{\n\t\t\t\t\tu_handLandmarksTex: {\n\t\t\t\t\t\tdata: detector.landmarks.data,\n\t\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t\t\tisPartial: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{ skipHistoryWrite }\n\t\t\t);\n\t\t\tshaderPad.updateUniforms({ u_nHands: nHands });\n\t\t\temitHook('hands:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { HandLandmarker }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\tconst mediapipeCanvas = new OffscreenCanvas(1, 1);\n\t\t\t\tconst handLandmarker = await HandLandmarker.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\tnumHands: options.maxHands,\n\t\t\t\t\tminHandDetectionConfidence: options.minHandDetectionConfidence,\n\t\t\t\t\tminHandPresenceConfidence: options.minHandPresenceConfidence,\n\t\t\t\t\tminTrackingConfidence: options.minTrackingConfidence,\n\t\t\t\t});\n\n\t\t\t\tdetector = {\n\t\t\t\t\tlandmarker: handLandmarker,\n\t\t\t\t\tcanvas: mediapipeCanvas,\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tmaxHands: options.maxHands,\n\t\t\t\t\tstate: {\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t\tnHands: 0,\n\t\t\t\t\t},\n\t\t\t\t\tlandmarks: {\n\t\t\t\t\t\tdata: landmarksData,\n\t\t\t\t\t\ttextureHeight,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tshaderPad.on('init', () => {\n\t\t\tshaderPad.initializeUniform('u_maxHands', 'int', options.maxHands);\n\t\t\tshaderPad.initializeUniform('u_nHands', 'int', 0);\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_handLandmarksTex',\n\t\t\t\t{ data: landmarksData, width: LANDMARKS_TEXTURE_WIDTH, height: textureHeight },\n\t\t\t\t{ internalFormat: gl.RGBA32F, type: gl.FLOAT, minFilter: gl.NEAREST, magFilter: gl.NEAREST, history }\n\t\t\t);\n\t\t\tinitPromise.then(() => emitHook('hands:ready'));\n\t\t});\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) detectHands(source);\n\t\t});\n\n\t\tshaderPad.on(\n\t\t\t'updateTextures',\n\t\t\t(updates: Record<string, TextureSource>, options?: { skipHistoryWrite?: boolean }) => {\n\t\t\t\tconst source = updates[textureName];\n\t\t\t\tif (isMediaPipeSource(source)) {\n\t\t\t\t\tskipHistoryWrite = options?.skipHistoryWrite ?? false;\n\t\t\t\t\tdetectHands(source);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tlet nDetectionCalls = 0;\n\t\tasync function detectHands(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tconst callOrder = ++nDetectionCalls;\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (callOrder !== nDetectionCalls || !detector) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.landmarker.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: HandLandmarkerResult | undefined;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\tresult = detector.landmarker.detectForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\tresult = detector.landmarker.detect(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tupdateLandmarksData(detector, result.landmarks, result.handedness);\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result && !detector.subscribers.get(onResult)) {\n\t\t\t\t\tonResult();\n\t\t\t\t\tdetector.subscribers.set(onResult, true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.landmarker.close();\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tconst { fn, historyParams } = generateGLSLFn(history);\n\n\t\tinjectGLSL(`\nuniform int u_maxHands;\nuniform int u_nHands;\nuniform highp sampler2D${history ? 'Array' : ''} u_handLandmarksTex;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_handLandmarksTexFrameOffset;`\n\t\t\t\t: ''\n\t\t}\n\n${fn(\n\t'int',\n\t'nHandsAt',\n\t'',\n\thistory\n\t\t? `\n\tint layer = (u_handLandmarksTexFrameOffset - framesAgo + ${history}) % ${history};\n\treturn int(texelFetch(u_handLandmarksTex, ivec3(0, 0, layer), 0).r + 0.5);`\n\t\t: `\n\treturn int(texelFetch(u_handLandmarksTex, ivec2(0, 0), 0).r + 0.5);`\n)}\n${fn(\n\t'vec4',\n\t'handLandmark',\n\t'int handIndex, int landmarkIndex',\n\t`int i = ${N_LANDMARK_METADATA_SLOTS} + handIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};${\n\t\thistory\n\t\t\t? `\n\tint layer = (u_handLandmarksTexFrameOffset - framesAgo + ${history}) % ${history};\n\treturn texelFetch(u_handLandmarksTex, ivec3(x, y, layer), 0);`\n\t\t\t: `\n\treturn texelFetch(u_handLandmarksTex, ivec2(x, y), 0);`\n\t}`\n)}\n${fn('float', 'isRightHand', 'int handIndex', `return handLandmark(handIndex, 0${historyParams}).w;`)}\n${fn('float', 'isLeftHand', 'int handIndex', `return 1.0 - handLandmark(handIndex, 0${historyParams}).w;`)}`);\n\t};\n}\n\nexport default hands;\n","import { TextureSource } from '..';\n\nexport const dummyTexture = { data: new Uint8Array(4), width: 1, height: 1 };\n\nexport type MediaPipeSource = HTMLVideoElement | HTMLImageElement | HTMLCanvasElement | OffscreenCanvas;\n\nexport function isMediaPipeSource(source: TextureSource): source is MediaPipeSource {\n\treturn (\n\t\tsource instanceof HTMLVideoElement ||\n\t\tsource instanceof HTMLImageElement ||\n\t\tsource instanceof HTMLCanvasElement ||\n\t\tsource instanceof OffscreenCanvas\n\t);\n}\n\nexport function hashOptions(options: object): string {\n\treturn JSON.stringify(options, Object.keys(options).sort());\n}\n\nexport function calculateBoundingBoxCenter(\n\tdata: Float32Array,\n\tentityIdx: number,\n\tlandmarkIndices: readonly number[] | number[],\n\tlandmarkCount: number,\n\toffset: number = 0\n): [number, number, number, number] {\n\tlet minX = Infinity,\n\t\tmaxX = -Infinity,\n\t\tminY = Infinity,\n\t\tmaxY = -Infinity,\n\t\tavgZ = 0,\n\t\tavgVisibility = 0;\n\n\tfor (const idx of landmarkIndices) {\n\t\tconst dataIdx = (offset + entityIdx * landmarkCount + idx) * 4;\n\t\tconst x = data[dataIdx];\n\t\tconst y = data[dataIdx + 1];\n\t\tminX = Math.min(minX, x);\n\t\tmaxX = Math.max(maxX, x);\n\t\tminY = Math.min(minY, y);\n\t\tmaxY = Math.max(maxY, y);\n\t\tavgZ += data[dataIdx + 2];\n\t\tavgVisibility += data[dataIdx + 3];\n\t}\n\n\treturn [\n\t\t(minX + maxX) / 2,\n\t\t(minY + maxY) / 2,\n\t\tavgZ / landmarkIndices.length,\n\t\tavgVisibility / landmarkIndices.length,\n\t];\n}\n\nlet filesetPromise: Promise<any> | null = null;\nexport function getSharedFileset(): Promise<any> {\n\tif (!filesetPromise) {\n\t\tfilesetPromise = import('@mediapipe/tasks-vision').then(({ FilesetResolver }) =>\n\t\t\tFilesetResolver.forVisionTasks(\n\t\t\t\t`https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@${__MEDIAPIPE_TASKS_VISION_VERSION__}/wasm`\n\t\t\t)\n\t\t);\n\t}\n\treturn filesetPromise;\n}\n\nexport function generateGLSLFn(history: number | undefined) {\n\tconst historyParams = history ? ', framesAgo' : '';\n\tconst fn = history\n\t\t? (returnType: string, name: string, args: string, body: string) => {\n\t\t\t\tconst argsOnly = args.replace(/\\w+ /g, '');\n\t\t\t\tconst historyArgs = args ? `${args}, int framesAgo` : 'int framesAgo';\n\t\t\t\tconst callArgs = argsOnly ? `${argsOnly}, 0` : '0';\n\t\t\t\treturn `${returnType} ${name}(${historyArgs}) {\\n${body}\\n}\n${returnType} ${name}(${args}) { return ${name}(${callArgs}); }`;\n\t\t  }\n\t\t: (returnType: string, name: string, args: string, body: string) =>\n\t\t\t\t`${returnType} ${name}(${args}) {\\n${body}\\n}`;\n\treturn { historyParams, fn };\n}\n"],"mappings":"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","names":["hands_exports","__export","hands_default","__toCommonJS","dummyTexture","isMediaPipeSource","source","hashOptions","options","calculateBoundingBoxCenter","data","entityIdx","landmarkIndices","landmarkCount","offset","minX","maxX","minY","maxY","avgZ","avgVisibility","idx","dataIdx","x","y","filesetPromise","getSharedFileset","FilesetResolver","generateGLSLFn","history","returnType","name","args","body","argsOnly","historyArgs","callArgs","STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","HAND_CENTER_LANDMARKS","LANDMARKS_TEXTURE_WIDTH","N_LANDMARK_METADATA_SLOTS","DEFAULT_HANDS_OPTIONS","sharedDetectors","updateLandmarksData","detector","hands","handedness","data","nHands","handIdx","landmarks","isRightHand","lmIdx","landmark","dataIdx","handCenter","calculateBoundingBoxCenter","handCenterIdx","config","textureName","history","mediapipeOptions","options","optionsKey","hashOptions","nLandmarksMax","textureHeight","shaderPad","context","injectGLSL","gl","emitHook","landmarksData","skipHistoryWrite","onResult","nSlots","rowsToUpdate","initializeDetector","mediaPipe","HandLandmarker","getSharedFileset","mediapipeCanvas","initPromise","name","source","isMediaPipeSource","detectHands","updates","nDetectionCalls","now","callOrder","requiredMode","shouldDetect","result","cb","fn","historyParams","generateGLSLFn","hands_default"]}