{"version":3,"sources":["../../src/plugins/face.ts"],"sourcesContent":["import ShaderPad, { PluginContext, TextureSource } from '..';\nimport {\n\tcalculateBoundingBoxCenter,\n\tgenerateGLSLFn,\n\tgetSharedFileset,\n\thashOptions,\n\tisMediaPipeSource,\n\tMediaPipeSource,\n} from './mediapipe-common';\nimport type { FaceLandmarker, FaceLandmarkerResult, NormalizedLandmark } from '@mediapipe/tasks-vision';\n\nexport interface FacePluginOptions {\n\tmodelPath?: string;\n\tmaxFaces?: number;\n\tminFaceDetectionConfidence?: number;\n\tminFacePresenceConfidence?: number;\n\tminTrackingConfidence?: number;\n\toutputFaceBlendshapes?: boolean;\n\toutputFacialTransformationMatrixes?: boolean;\n\thistory?: number;\n}\n\nconst MASK_VERTEX_SHADER = `#version 300 es\nin vec2 a_pos;\nvoid main() { gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0); }`;\nconst MASK_FRAGMENT_SHADER = `#version 300 es\nprecision mediump float;\nuniform vec4 u_color;\nout vec4 outColor;\nvoid main() { outColor = u_color; }`;\n\nconst STANDARD_LANDMARK_COUNT = 478;\nconst CUSTOM_LANDMARK_COUNT = 2;\nconst LANDMARK_COUNT = STANDARD_LANDMARK_COUNT + CUSTOM_LANDMARK_COUNT;\nconst LANDMARKS_TEXTURE_WIDTH = 512;\nconst N_LANDMARK_METADATA_SLOTS = 1;\n\nconst LEFT_EYEBROW_INDICES = [336, 296, 334, 293, 300, 276, 283, 282, 295, 285] as const;\nconst LEFT_EYE_INDICES = [362, 398, 384, 385, 386, 387, 388, 466, 263, 249, 390, 373, 374, 380, 381, 382] as const;\nconst RIGHT_EYEBROW_INDICES = [70, 63, 105, 66, 107, 55, 65, 52, 53, 46] as const;\nconst RIGHT_EYE_INDICES = [33, 246, 161, 160, 159, 158, 157, 173, 133, 155, 154, 153, 145, 144, 163, 7] as const;\nconst OUTER_MOUTH_INDICES = [\n\t61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146,\n] as const;\nconst INNER_MOUTH_INDICES = [\n\t78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308, 324, 318, 402, 317, 14, 87, 178, 88, 95,\n] as const;\nconst ALL_STANDARD_INDICES = Array.from({ length: STANDARD_LANDMARK_COUNT }, (_, i) => i);\nconst LANDMARK_INDICES = {\n\tLEFT_EYEBROW: LEFT_EYEBROW_INDICES,\n\tLEFT_EYE: LEFT_EYE_INDICES,\n\tLEFT_EYE_CENTER: 473,\n\tRIGHT_EYEBROW: RIGHT_EYEBROW_INDICES,\n\tRIGHT_EYE: RIGHT_EYE_INDICES,\n\tRIGHT_EYE_CENTER: 468,\n\tNOSE_TIP: 4,\n\tOUTER_MOUTH: OUTER_MOUTH_INDICES,\n\tINNER_MOUTH: INNER_MOUTH_INDICES,\n\t// Custom landmarks.\n\tFACE_CENTER: STANDARD_LANDMARK_COUNT,\n\tMOUTH_CENTER: STANDARD_LANDMARK_COUNT + 1,\n};\n\nconst REGION_NAMES = [\n\t'BACKGROUND',\n\t'LEFT_EYEBROW',\n\t'RIGHT_EYEBROW',\n\t'LEFT_EYE',\n\t'RIGHT_EYE',\n\t'OUTER_MOUTH',\n\t'INNER_MOUTH',\n] as const;\nconst nFaceRegions = REGION_NAMES.length - 1;\nconst RED_CHANNEL_VALUES = Object.fromEntries(REGION_NAMES.map((name, i) => [name, i / nFaceRegions])) as Record<\n\t(typeof REGION_NAMES)[number],\n\tnumber\n>;\nconst HALF_GAP = 0.5 / nFaceRegions;\n\nconst DEFAULT_FACE_OPTIONS: Required<Omit<FacePluginOptions, 'history'>> = {\n\tmodelPath:\n\t\t'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task',\n\tmaxFaces: 1,\n\tminFaceDetectionConfidence: 0.5,\n\tminFacePresenceConfidence: 0.5,\n\tminTrackingConfidence: 0.5,\n\toutputFaceBlendshapes: false,\n\toutputFacialTransformationMatrixes: false,\n};\n\nfunction fanTriangulate(indices: readonly number[]): number[] {\n\tconst tris: number[] = [];\n\tfor (let i = 1; i < indices.length - 1; ++i) {\n\t\ttris.push(indices[0], indices[i], indices[i + 1]);\n\t}\n\treturn tris;\n}\n\ntype FaceRegion = { triangles: number[]; vertices: Float32Array };\nlet faceRegions: Record<string, FaceRegion> | null = null;\nfunction initFaceRegions(LandmarkerClass: typeof FaceLandmarker): void {\n\tif (!faceRegions) {\n\t\tconst tesselationConnections = LandmarkerClass.FACE_LANDMARKS_TESSELATION;\n\t\tconst tesselation: number[] = [];\n\t\tfor (let i = 0; i < tesselationConnections.length - 2; i += 3) {\n\t\t\ttesselation.push(\n\t\t\t\ttesselationConnections[i].start,\n\t\t\t\ttesselationConnections[i + 1].start,\n\t\t\t\ttesselationConnections[i + 2].start\n\t\t\t);\n\t\t}\n\t\tconst ovalIndices = LandmarkerClass.FACE_LANDMARKS_FACE_OVAL.map(({ start }) => start);\n\t\tfaceRegions = Object.fromEntries(\n\t\t\tObject.entries({\n\t\t\t\tLEFT_EYEBROW: fanTriangulate(LEFT_EYEBROW_INDICES),\n\t\t\t\tRIGHT_EYEBROW: fanTriangulate(RIGHT_EYEBROW_INDICES),\n\t\t\t\tLEFT_EYE: fanTriangulate(LEFT_EYE_INDICES),\n\t\t\t\tRIGHT_EYE: fanTriangulate(RIGHT_EYE_INDICES),\n\t\t\t\tOUTER_MOUTH: fanTriangulate(OUTER_MOUTH_INDICES),\n\t\t\t\tINNER_MOUTH: fanTriangulate(INNER_MOUTH_INDICES),\n\t\t\t\tTESSELATION: tesselation,\n\t\t\t\tOVAL: fanTriangulate(ovalIndices),\n\t\t\t}).map(([key, triangles]) => [key, { triangles, vertices: new Float32Array(triangles.length * 2) }])\n\t\t);\n\t}\n}\n\ninterface MaskRenderer {\n\tcanvas: OffscreenCanvas;\n\tgl: WebGL2RenderingContext;\n\tprogram: WebGLProgram;\n\tpositionBuffer: WebGLBuffer;\n\tcolorLocation: WebGLUniformLocation;\n}\n\ninterface Detector {\n\tlandmarker: FaceLandmarker;\n\tmask: MaskRenderer;\n\tsubscribers: Map<Function, boolean>;\n\tmaxFaces: number;\n\tstate: {\n\t\tnCalls: number;\n\t\trunningMode: 'IMAGE' | 'VIDEO';\n\t\tsource: MediaPipeSource | null;\n\t\tvideoTime: number;\n\t\tresultTimestamp: number;\n\t\tresult: FaceLandmarkerResult | null;\n\t\tpending: Promise<void>;\n\t\tnFaces: number;\n\t};\n\tlandmarks: {\n\t\tdata: Float32Array;\n\t\ttextureHeight: number;\n\t};\n}\nconst sharedDetectors = new Map<string, Detector>();\n\nfunction initMaskRenderer(canvas: OffscreenCanvas): MaskRenderer {\n\tconst gl = canvas.getContext('webgl2', { antialias: false, preserveDrawingBuffer: true })!;\n\n\tconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\n\tgl.shaderSource(vertexShader, MASK_VERTEX_SHADER);\n\tgl.compileShader(vertexShader);\n\n\tconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\n\tgl.shaderSource(fragmentShader, MASK_FRAGMENT_SHADER);\n\tgl.compileShader(fragmentShader);\n\n\tconst program = gl.createProgram()!;\n\tgl.attachShader(program, vertexShader);\n\tgl.attachShader(program, fragmentShader);\n\tgl.linkProgram(program);\n\tgl.deleteShader(vertexShader);\n\tgl.deleteShader(fragmentShader);\n\n\tconst positionBuffer = gl.createBuffer()!;\n\tgl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\tconst positionLocation = gl.getAttribLocation(program, 'a_pos');\n\tgl.enableVertexAttribArray(positionLocation);\n\tgl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\tconst colorLocation = gl.getUniformLocation(program, 'u_color')!;\n\tgl.useProgram(program);\n\tgl.enable(gl.BLEND);\n\tgl.blendEquation(gl.MAX);\n\n\treturn { canvas, gl, program, positionBuffer, colorLocation };\n}\n\nfunction drawTriangles(\n\tmask: MaskRenderer,\n\tlandmarksData: Float32Array,\n\tfaceRegion: FaceRegion,\n\tfaceIdx: number,\n\tr: number,\n\tg: number,\n\tb: number\n) {\n\tconst { triangles, vertices } = faceRegion;\n\tconst { gl, colorLocation } = mask;\n\n\tfor (let i = 0; i < triangles.length; ++i) {\n\t\tconst landmarkIdx = (N_LANDMARK_METADATA_SLOTS + faceIdx * LANDMARK_COUNT + triangles[i]) * 4;\n\t\tvertices[i * 2] = landmarksData[landmarkIdx];\n\t\tvertices[i * 2 + 1] = landmarksData[landmarkIdx + 1];\n\t}\n\n\tgl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n\tgl.uniform4f(colorLocation, r, g, b, 1.0);\n\tgl.drawArrays(gl.TRIANGLES, 0, triangles.length);\n}\n\nfunction updateLandmarksData(detector: Detector, faces: NormalizedLandmark[][]) {\n\tconst data = detector.landmarks.data;\n\tconst nFaces = faces.length;\n\tdata[0] = nFaces;\n\n\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\tconst landmarks = faces[faceIdx];\n\t\tfor (let landmarkIdx = 0; landmarkIdx < STANDARD_LANDMARK_COUNT; ++landmarkIdx) {\n\t\t\tconst landmark = landmarks[landmarkIdx];\n\t\t\tconst dataIdx = (N_LANDMARK_METADATA_SLOTS + faceIdx * LANDMARK_COUNT + landmarkIdx) * 4;\n\t\t\tdata[dataIdx] = landmark.x;\n\t\t\tdata[dataIdx + 1] = 1 - landmark.y;\n\t\t\tdata[dataIdx + 2] = landmark.z ?? 0;\n\t\t\tdata[dataIdx + 3] = landmark.visibility ?? 1;\n\t\t}\n\n\t\tconst faceCenter = calculateBoundingBoxCenter(\n\t\t\tdata,\n\t\t\tfaceIdx,\n\t\t\tALL_STANDARD_INDICES,\n\t\t\tLANDMARK_COUNT,\n\t\t\tN_LANDMARK_METADATA_SLOTS\n\t\t);\n\t\tdata.set(faceCenter, (N_LANDMARK_METADATA_SLOTS + faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.FACE_CENTER) * 4);\n\n\t\tconst mouthCenter = calculateBoundingBoxCenter(data, faceIdx, INNER_MOUTH_INDICES, LANDMARK_COUNT, 1);\n\t\tdata.set(\n\t\t\tmouthCenter,\n\t\t\t(N_LANDMARK_METADATA_SLOTS + faceIdx * LANDMARK_COUNT + LANDMARK_INDICES.MOUTH_CENTER) * 4\n\t\t);\n\t}\n\n\tdetector.state.nFaces = nFaces;\n}\n\nfunction updateMask(detector: Detector, width: number, height: number) {\n\tconst {\n\t\tmask,\n\t\tmaxFaces,\n\t\tlandmarks,\n\t\tstate: { nFaces },\n\t} = detector;\n\tconst { gl, canvas: maskCanvas } = mask;\n\tconst { data: landmarksData } = landmarks;\n\n\tif (maskCanvas.width !== width || maskCanvas.height !== height) {\n\t\tmaskCanvas.width = width;\n\t\tmaskCanvas.height = height;\n\t}\n\tgl.viewport(0, 0, maskCanvas.width, maskCanvas.height);\n\tgl.clearColor(0, 0, 0, 0);\n\tgl.clear(gl.COLOR_BUFFER_BIT);\n\n\tif (!faceRegions) return;\n\n\tfor (let faceIdx = 0; faceIdx < nFaces; ++faceIdx) {\n\t\tconst b = (faceIdx + 1) / maxFaces;\n\n\t\t// G channel: face mesh (0.5) and oval (1.0)\n\t\tdrawTriangles(mask, landmarksData, faceRegions.TESSELATION, faceIdx, 0, 0.5, b);\n\t\tdrawTriangles(mask, landmarksData, faceRegions.OVAL, faceIdx, 0, 1.0, b);\n\n\t\t// R channel: feature regions\n\t\tdrawTriangles(mask, landmarksData, faceRegions.LEFT_EYEBROW, faceIdx, RED_CHANNEL_VALUES.LEFT_EYEBROW, 0, b);\n\t\tdrawTriangles(mask, landmarksData, faceRegions.RIGHT_EYEBROW, faceIdx, RED_CHANNEL_VALUES.RIGHT_EYEBROW, 0, b);\n\t\tdrawTriangles(mask, landmarksData, faceRegions.LEFT_EYE, faceIdx, RED_CHANNEL_VALUES.LEFT_EYE, 0, b);\n\t\tdrawTriangles(mask, landmarksData, faceRegions.RIGHT_EYE, faceIdx, RED_CHANNEL_VALUES.RIGHT_EYE, 0, b);\n\t\tdrawTriangles(mask, landmarksData, faceRegions.OUTER_MOUTH, faceIdx, RED_CHANNEL_VALUES.OUTER_MOUTH, 0, b);\n\t\tdrawTriangles(mask, landmarksData, faceRegions.INNER_MOUTH, faceIdx, RED_CHANNEL_VALUES.INNER_MOUTH, 0, b);\n\t}\n}\n\nfunction face(config: { textureName: string; options?: FacePluginOptions }) {\n\tconst { textureName, options: { history, ...mediapipeOptions } = {} } = config;\n\tconst options = { ...DEFAULT_FACE_OPTIONS, ...mediapipeOptions };\n\tconst optionsKey = hashOptions({ ...options, textureName });\n\n\tconst nLandmarksMax = options.maxFaces * LANDMARK_COUNT + N_LANDMARK_METADATA_SLOTS;\n\tconst textureHeight = Math.ceil(nLandmarksMax / LANDMARKS_TEXTURE_WIDTH);\n\n\treturn function (shaderPad: ShaderPad, context: PluginContext) {\n\t\tconst { injectGLSL, emitHook } = context;\n\n\t\tconst existingDetector = sharedDetectors.get(optionsKey);\n\t\tconst landmarksData =\n\t\t\texistingDetector?.landmarks.data ?? new Float32Array(LANDMARKS_TEXTURE_WIDTH * textureHeight * 4);\n\t\tconst maskCanvas = existingDetector?.mask.canvas ?? new OffscreenCanvas(1, 1);\n\t\tlet detector: Detector | null = null;\n\t\tlet destroyed = false;\n\t\tlet skipHistoryWrite = false;\n\n\t\tfunction onResult(singleHistoryWriteIndex?: number) {\n\t\t\tif (!detector) return;\n\t\t\tconst nFaces = detector.state.nFaces;\n\t\t\tconst nSlots = nFaces * LANDMARK_COUNT + N_LANDMARK_METADATA_SLOTS;\n\t\t\tconst rowsToUpdate = Math.ceil(nSlots / LANDMARKS_TEXTURE_WIDTH);\n\t\t\tlet historyWriteIndex: number | number[] | undefined = singleHistoryWriteIndex;\n\t\t\tif (typeof historyWriteIndex === 'undefined' && pendingBackfillSlots.length > 0) {\n\t\t\t\thistoryWriteIndex = pendingBackfillSlots;\n\t\t\t\tpendingBackfillSlots = [];\n\t\t\t}\n\t\t\tshaderPad.updateTextures(\n\t\t\t\t{\n\t\t\t\t\tu_faceLandmarksTex: {\n\t\t\t\t\t\tdata: detector.landmarks.data,\n\t\t\t\t\t\twidth: LANDMARKS_TEXTURE_WIDTH,\n\t\t\t\t\t\theight: rowsToUpdate,\n\t\t\t\t\t\tisPartial: true,\n\t\t\t\t\t},\n\t\t\t\t\tu_faceMask: detector.mask.canvas,\n\t\t\t\t},\n\t\t\t\thistory ? { skipHistoryWrite, historyWriteIndex } : undefined\n\t\t\t);\n\t\t\tshaderPad.updateUniforms({ u_nFaces: nFaces });\n\t\t\temitHook('face:result', detector.state.result);\n\t\t}\n\n\t\tasync function initializeDetector() {\n\t\t\tif (sharedDetectors.has(optionsKey)) {\n\t\t\t\tdetector = sharedDetectors.get(optionsKey)!;\n\t\t\t} else {\n\t\t\t\tconst [mediaPipe, { FaceLandmarker }] = await Promise.all([\n\t\t\t\t\tgetSharedFileset(),\n\t\t\t\t\timport('@mediapipe/tasks-vision'),\n\t\t\t\t]);\n\t\t\t\tif (destroyed) return;\n\n\t\t\t\tconst faceLandmarker = await FaceLandmarker.createFromOptions(mediaPipe, {\n\t\t\t\t\tbaseOptions: {\n\t\t\t\t\t\tmodelAssetPath: options.modelPath,\n\t\t\t\t\t\tdelegate: 'GPU',\n\t\t\t\t\t},\n\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\tnumFaces: options.maxFaces,\n\t\t\t\t\tminFaceDetectionConfidence: options.minFaceDetectionConfidence,\n\t\t\t\t\tminFacePresenceConfidence: options.minFacePresenceConfidence,\n\t\t\t\t\tminTrackingConfidence: options.minTrackingConfidence,\n\t\t\t\t\toutputFaceBlendshapes: options.outputFaceBlendshapes,\n\t\t\t\t\toutputFacialTransformationMatrixes: options.outputFacialTransformationMatrixes,\n\t\t\t\t});\n\t\t\t\tif (destroyed) {\n\t\t\t\t\tfaceLandmarker.close();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdetector = {\n\t\t\t\t\tlandmarker: faceLandmarker,\n\t\t\t\t\tmask: initMaskRenderer(maskCanvas),\n\t\t\t\t\tsubscribers: new Map(),\n\t\t\t\t\tmaxFaces: options.maxFaces,\n\t\t\t\t\tstate: {\n\t\t\t\t\t\tnCalls: 0,\n\t\t\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\t\t\tsource: null,\n\t\t\t\t\t\tvideoTime: -1,\n\t\t\t\t\t\tresultTimestamp: 0,\n\t\t\t\t\t\tresult: null,\n\t\t\t\t\t\tpending: Promise.resolve(),\n\t\t\t\t\t\tnFaces: 0,\n\t\t\t\t\t},\n\t\t\t\t\tlandmarks: {\n\t\t\t\t\t\tdata: landmarksData,\n\t\t\t\t\t\ttextureHeight,\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tinitFaceRegions(FaceLandmarker);\n\t\t\t\tsharedDetectors.set(optionsKey, detector);\n\t\t\t}\n\n\t\t\tdetector.subscribers.set(onResult, false);\n\t\t}\n\t\tconst initPromise = initializeDetector();\n\n\t\tasync function detectFaces(source: MediaPipeSource) {\n\t\t\tconst now = performance.now();\n\t\t\tawait initPromise;\n\t\t\tif (!detector) return;\n\t\t\tconst callOrder = ++detector.state.nCalls;\n\n\t\t\tdetector.state.pending = detector.state.pending.then(async () => {\n\t\t\t\tif (!detector || callOrder !== detector.state.nCalls) return;\n\n\t\t\t\tconst requiredMode = source instanceof HTMLVideoElement ? 'VIDEO' : 'IMAGE';\n\t\t\t\tif (detector.state.runningMode !== requiredMode) {\n\t\t\t\t\tdetector.state.runningMode = requiredMode;\n\t\t\t\t\tawait detector.landmarker.setOptions({ runningMode: requiredMode });\n\t\t\t\t}\n\n\t\t\t\tlet shouldDetect = false;\n\n\t\t\t\tif (source !== detector.state.source) {\n\t\t\t\t\tdetector.state.source = source;\n\t\t\t\t\tdetector.state.videoTime = -1;\n\t\t\t\t\tshouldDetect = true;\n\t\t\t\t} else if (source instanceof HTMLVideoElement) {\n\t\t\t\t\tif (source.currentTime !== detector.state.videoTime) {\n\t\t\t\t\t\tdetector.state.videoTime = source.currentTime;\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(source instanceof HTMLImageElement)) {\n\t\t\t\t\tif (now - detector.state.resultTimestamp > 2) {\n\t\t\t\t\t\tshouldDetect = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldDetect) {\n\t\t\t\t\tlet result: FaceLandmarkerResult | undefined;\n\t\t\t\t\tlet width: number, height: number;\n\t\t\t\t\tif (source instanceof HTMLVideoElement) {\n\t\t\t\t\t\tif (source.videoWidth === 0 || source.videoHeight === 0 || source.readyState < 2) return;\n\t\t\t\t\t\twidth = source.videoWidth;\n\t\t\t\t\t\theight = source.videoHeight;\n\t\t\t\t\t\tresult = detector.landmarker.detectForVideo(source, now);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (source.width === 0 || source.height === 0) return;\n\t\t\t\t\t\twidth = source.width;\n\t\t\t\t\t\theight = source.height;\n\t\t\t\t\t\tresult = detector.landmarker.detect(source);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdetector.state.resultTimestamp = now;\n\t\t\t\t\t\tdetector.state.result = result;\n\t\t\t\t\t\tupdateLandmarksData(detector, result.faceLandmarks);\n\t\t\t\t\t\tupdateMask(detector, width, height);\n\t\t\t\t\t\tfor (const cb of detector.subscribers.keys()) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (detector.state.result) {\n\t\t\t\t\tfor (const [cb, hasCalled] of detector.subscribers.entries()) {\n\t\t\t\t\t\tif (!hasCalled) {\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\tdetector.subscribers.set(cb, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait detector.state.pending;\n\t\t}\n\n\t\tshaderPad.on('_init', () => {\n\t\t\tshaderPad.initializeUniform('u_maxFaces', 'int', options.maxFaces);\n\t\t\tshaderPad.initializeUniform('u_nFaces', 'int', 0);\n\t\t\tshaderPad.initializeTexture(\n\t\t\t\t'u_faceLandmarksTex',\n\t\t\t\t{ data: landmarksData, width: LANDMARKS_TEXTURE_WIDTH, height: textureHeight },\n\t\t\t\t{ internalFormat: 'RGBA32F', type: 'FLOAT', minFilter: 'NEAREST', magFilter: 'NEAREST', history }\n\t\t\t);\n\t\t\tshaderPad.initializeTexture('u_faceMask', maskCanvas, {\n\t\t\t\tminFilter: 'NEAREST',\n\t\t\t\tmagFilter: 'NEAREST',\n\t\t\t\thistory,\n\t\t\t});\n\t\t\tinitPromise.then(() => {\n\t\t\t\tif (destroyed || !detector) return;\n\t\t\t\temitHook('face:ready');\n\t\t\t});\n\t\t});\n\n\t\tlet historyWriteCounter = 0;\n\t\tlet pendingBackfillSlots: number[] = [];\n\t\tconst writeToHistory = () => {\n\t\t\tif (!history) return;\n\t\t\tonResult(historyWriteCounter); // Write stale data immediately.\n\t\t\tpendingBackfillSlots.push(historyWriteCounter); // Queue up backfill with more recent data.\n\t\t\thistoryWriteCounter = (historyWriteCounter + 1) % (history + 1);\n\t\t};\n\n\t\tshaderPad.on('initializeTexture', (name: string, source: TextureSource) => {\n\t\t\tif (name === textureName && isMediaPipeSource(source)) {\n\t\t\t\twriteToHistory();\n\t\t\t\tdetectFaces(source);\n\t\t\t}\n\t\t});\n\n\t\tshaderPad.on(\n\t\t\t'updateTextures',\n\t\t\t(updates: Record<string, TextureSource>, options?: { skipHistoryWrite?: boolean }) => {\n\t\t\t\tconst source = updates[textureName];\n\t\t\t\tif (isMediaPipeSource(source)) {\n\t\t\t\t\tskipHistoryWrite = options?.skipHistoryWrite ?? false;\n\t\t\t\t\tif (!skipHistoryWrite) writeToHistory();\n\t\t\t\t\tdetectFaces(source);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tshaderPad.on('destroy', () => {\n\t\t\tdestroyed = true;\n\t\t\tif (detector) {\n\t\t\t\tdetector.subscribers.delete(onResult);\n\t\t\t\tif (detector.subscribers.size === 0) {\n\t\t\t\t\tdetector.landmarker.close();\n\t\t\t\t\tdetector.mask.gl.deleteProgram(detector.mask.program);\n\t\t\t\t\tdetector.mask.gl.deleteBuffer(detector.mask.positionBuffer);\n\t\t\t\t\tsharedDetectors.delete(optionsKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetector = null;\n\t\t});\n\n\t\tconst { fn, historyParams } = generateGLSLFn(history);\n\t\tconst sampleMask = history ? `_sampleFaceMask(pos, framesAgo)` : `texture(u_faceMask, pos)`;\n\n\t\tconst checkAt = (\n\t\t\tfnName: string,\n\t\t\tregionMin: keyof typeof RED_CHANNEL_VALUES,\n\t\t\tregionMax: keyof typeof RED_CHANNEL_VALUES = regionMin\n\t\t) =>\n\t\t\tfn(\n\t\t\t\t'vec2',\n\t\t\t\t`${fnName}At`,\n\t\t\t\t'vec2 pos',\n\t\t\t\t`vec4 mask = ${sampleMask};\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn (mask.r > ${(RED_CHANNEL_VALUES[regionMin] - HALF_GAP).toFixed(4)} && mask.r < ${(\n\t\t\t\t\tRED_CHANNEL_VALUES[regionMax] + HALF_GAP\n\t\t\t\t).toFixed(4)}) ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);`\n\t\t\t);\n\n\t\tconst checkMaskG = (fnName: string, threshold: number) =>\n\t\t\tfn(\n\t\t\t\t'vec2',\n\t\t\t\t`${fnName}At`,\n\t\t\t\t'vec2 pos',\n\t\t\t\t`vec4 mask = ${sampleMask};\n\tfloat faceIndex = floor(mask.b * float(u_maxFaces) + 0.5) - 1.0;\n\treturn mask.g > ${threshold.toFixed(2)} ? vec2(1.0, faceIndex) : vec2(0.0, -1.0);`\n\t\t\t);\n\n\t\tconst combineLeftRight = (fnName: string, leftFn: string, rightFn: string) =>\n\t\t\tfn(\n\t\t\t\t'vec2',\n\t\t\t\t`${fnName}At`,\n\t\t\t\t'vec2 pos',\n\t\t\t\t`vec2 left = ${leftFn}(pos${historyParams});\n\treturn left.x > 0.0 ? left : ${rightFn}(pos${historyParams});`\n\t\t\t);\n\n\t\tconst checkIn = (fnNames: string[]) =>\n\t\t\tfnNames\n\t\t\t\t.map(fnName =>\n\t\t\t\t\tfn(\n\t\t\t\t\t\t'float',\n\t\t\t\t\t\t`in${fnName[0].toUpperCase() + fnName.slice(1)}`,\n\t\t\t\t\t\t'vec2 pos',\n\t\t\t\t\t\t`vec2 a = ${fnName}At(pos${historyParams}); return step(0.0, a.y) * a.x;`\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.join('\\n');\n\n\t\tinjectGLSL(`\nuniform int u_maxFaces;\nuniform int u_nFaces;\nuniform highp sampler2D${history ? 'Array' : ''} u_faceLandmarksTex;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_faceLandmarksTexFrameOffset;`\n\t\t\t\t: ''\n\t\t}\nuniform ${history ? 'highp' : 'mediump'} sampler2D${history ? 'Array' : ''} u_faceMask;${\n\t\t\thistory\n\t\t\t\t? `\nuniform int u_faceMaskFrameOffset;`\n\t\t\t\t: ''\n\t\t}\n\n#define FACE_LANDMARK_L_EYE_CENTER ${LANDMARK_INDICES.LEFT_EYE_CENTER}\n#define FACE_LANDMARK_R_EYE_CENTER ${LANDMARK_INDICES.RIGHT_EYE_CENTER}\n#define FACE_LANDMARK_NOSE_TIP ${LANDMARK_INDICES.NOSE_TIP}\n#define FACE_LANDMARK_FACE_CENTER ${LANDMARK_INDICES.FACE_CENTER}\n#define FACE_LANDMARK_MOUTH_CENTER ${LANDMARK_INDICES.MOUTH_CENTER}\n\n${fn(\n\t'int',\n\t'nFacesAt',\n\t'',\n\thistory\n\t\t? `\n\tint layer = (u_faceLandmarksTexFrameOffset - framesAgo + ${history + 1}) % ${history + 1};\n\treturn int(texelFetch(u_faceLandmarksTex, ivec3(0, 0, layer), 0).r + 0.5);`\n\t\t: `\n\treturn int(texelFetch(u_faceLandmarksTex, ivec2(0, 0), 0).r + 0.5);`\n)}\n${fn(\n\t'vec4',\n\t'faceLandmark',\n\t'int faceIndex, int landmarkIndex',\n\t`int i = ${N_LANDMARK_METADATA_SLOTS} + faceIndex * ${LANDMARK_COUNT} + landmarkIndex;\n\tint x = i % ${LANDMARKS_TEXTURE_WIDTH};\n\tint y = i / ${LANDMARKS_TEXTURE_WIDTH};${\n\t\thistory\n\t\t\t? `\n\tint layer = (u_faceLandmarksTexFrameOffset - framesAgo + ${history + 1}) % ${history + 1};\n\treturn texelFetch(u_faceLandmarksTex, ivec3(x, y, layer), 0);`\n\t\t\t: `\n\treturn texelFetch(u_faceLandmarksTex, ivec2(x, y), 0);`\n\t}`\n)}\n${\n\thistory\n\t\t? `\nvec4 _sampleFaceMask(vec2 pos, int framesAgo) {\n\tint layer = (u_faceMaskFrameOffset - framesAgo + ${history + 1}) % ${history + 1};\n\treturn texture(u_faceMask, vec3(pos, float(layer)));\n}\n`\n\t\t: ''\n}\n${checkAt('leftEyebrow', 'LEFT_EYEBROW')}\n${checkAt('rightEyebrow', 'RIGHT_EYEBROW')}\n${checkAt('leftEye', 'LEFT_EYE')}\n${checkAt('rightEye', 'RIGHT_EYE')}\n${checkAt('lips', 'OUTER_MOUTH')}\n${checkAt('outerMouth', 'OUTER_MOUTH', 'INNER_MOUTH')}\n${checkAt('innerMouth', 'INNER_MOUTH')}\n${checkMaskG('faceOval', 0.75)}\n${checkMaskG('face', 0.25)}\n${combineLeftRight('eye', 'leftEyeAt', 'rightEyeAt')}\n${combineLeftRight('eyebrow', 'leftEyebrowAt', 'rightEyebrowAt')}\n${checkIn(['eyebrow', 'eye', 'outerMouth', 'innerMouth', 'lips', 'face'])}`);\n\t};\n}\n\nexport default face;\n"],"mappings":"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","names":["MASK_VERTEX_SHADER","MASK_FRAGMENT_SHADER","STANDARD_LANDMARK_COUNT","CUSTOM_LANDMARK_COUNT","LANDMARK_COUNT","LANDMARKS_TEXTURE_WIDTH","N_LANDMARK_METADATA_SLOTS","LEFT_EYEBROW_INDICES","LEFT_EYE_INDICES","RIGHT_EYEBROW_INDICES","RIGHT_EYE_INDICES","OUTER_MOUTH_INDICES","INNER_MOUTH_INDICES","ALL_STANDARD_INDICES","_","i","LANDMARK_INDICES","REGION_NAMES","nFaceRegions","RED_CHANNEL_VALUES","name","HALF_GAP","DEFAULT_FACE_OPTIONS","fanTriangulate","indices","tris","faceRegions","initFaceRegions","LandmarkerClass","tesselationConnections","tesselation","ovalIndices","start","key","triangles","sharedDetectors","initMaskRenderer","canvas","gl","vertexShader","fragmentShader","program","positionBuffer","positionLocation","colorLocation","drawTriangles","mask","landmarksData","faceRegion","faceIdx","r","g","b","vertices","landmarkIdx","updateLandmarksData","detector","faces","data","nFaces","landmarks","landmark","dataIdx","faceCenter","calculateBoundingBoxCenter","mouthCenter","updateMask","width","height","maxFaces","maskCanvas","face","config","textureName","history","mediapipeOptions","options","optionsKey","hashOptions","nLandmarksMax","textureHeight","shaderPad","context","injectGLSL","emitHook","existingDetector","destroyed","skipHistoryWrite","onResult","singleHistoryWriteIndex","nSlots","rowsToUpdate","historyWriteIndex","pendingBackfillSlots","initializeDetector","mediaPipe","FaceLandmarker","getSharedFileset","faceLandmarker","initPromise","detectFaces","source","now","callOrder","requiredMode","shouldDetect","result","cb","hasCalled","historyWriteCounter","writeToHistory","isMediaPipeSource","updates","fn","historyParams","generateGLSLFn","sampleMask","checkAt","fnName","regionMin","regionMax","checkMaskG","threshold","combineLeftRight","leftFn","rightFn","checkIn","fnNames","face_default"]}